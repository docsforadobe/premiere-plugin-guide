{"config":{"lang":["en"],"separator":"[\\s\\-,\\.:!=\\[\\]()\"/]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the Adobe\u00ae Premiere\u00ae Pro Software Development Kit!</p> <p>This is a living document, and is constantly being updated and edited. The latest release of the SDK is available at: https://www.adobe.io/apis/creativecloud/premierepro.html.</p> <p>If you have questions about the APIs described in this document, or about integration with Premiere Pro, your question may already be answered on the Premiere Pro SDK forum at: https://community.adobe.com/t5/forums/filteredbylabelpage/board-id/premiere-pro/label-name/sdk.</p>"},{"location":"history/","title":"Version History","text":"Date Maintainer Version 23 Oct 2023 Bruce Bullis Version 24.0 6 Oct 2021 Sanaz Golbabaei Version 22.0 8 May 2020 Bruce Bullis Version 14.2 1 May 2019 Bruce Bullis Version 13.1 1 November 2018 Bruce Bullis Version CC 13.0 16 July 2018 Zac Lam Version CC 13.0 pre-release 13 November 2017 Zac Lam Version CC 12.0 6 April 2017 Zac Lam Version CC 2017.1 4 November 2016 Zac Lam Version CC 2017 4 August 2015 Zac Lam Version CC 2015 16 June 2014 Zac Lam Version CC 2014 21 October 2013 Zac Lam Version CC October release 16 July 2013 Zac Lam Version CC 19 June 2012 Zac Lam Version CS6 release 2 30 April 2012 Zac Lam Version CS6 release 1 2 May 2011 Zac Lam Version CS5.5 28 April 2010 Zac Lam Version CS5 21 September 2009 Zac Lam Version CS4 5 October 2007 Zac Lam Version CS3 13 July 2006 Zac Lam Version 2.0 release 2 17 January 2006 Zac Lam Version 2.0 release 1 25 May 2004 Zac Lam Version 1.5 21 August 2003 Zac Lam Version 1.0 (Premiere Pro) 19 July 2002 Zac Lam &amp; Bruce Bullis Version 6.5 10 May 2001 Bruce Bullis Version 6 release 2 10 December 2000 Bruce Bullis &amp; Eric Sanders Version 6 release 1 20 April 1998 Brian Andrews Version 5 9 February 1996 Brian Andrews Version 4.2 13 February 1995 Matt Foster, Nick Schlott Version 4.0 - first Windows release"},{"location":"ae-transition-extensions/PF_TransitionSuite/","title":"PF_TransitionSuite","text":"<p>In PrSDKAESupport.h, we've added <code>PF_TransitionSuite::RegisterTransitionInputParam()</code>.</p> <p>This call must be made before the <code>PF_ADD_PARAM()</code> call during <code>PF_Cmd_PARAM_SETUP</code>.</p> <p>Pass in the param to be used as the input layer for the other side of the transition.</p> <p>This enables your effect to be applied between two clips in the timeline just like our native transitions, but it will show up in the Effect Controls panel with full keyframable parameters similar to existing AE effects.</p>"},{"location":"ae-transition-extensions/ae-transition-extensions/","title":"AE Transition Extensions","text":"<p>This chapter describes how to build native transitions in Premiere Pro based on the After Effects API. From a user-perspective, plugins built this way can show their parameters directly in the Effect Controls panel, even providing custom parameter UI in that panel or in the Sequence Monitor. Such plugins can run not only in Premiere Pro, but also in After Effects, although they will appear as effects rather than transitions.</p> <p>The transition extensions work on top of effects built using the After Effects SDK. Since AE effects only have a single input, the second input is a layer parameter defined by the plugin.</p>"},{"location":"ae-transition-extensions/getting-started/","title":"Getting Started","text":""},{"location":"ae-transition-extensions/getting-started/#setting-up-the-sample-project","title":"Setting up the Sample Project","text":"<p>If you are developing an transition, begin with the SDK_CrossDissolve sample project, progressively replacing its functionality with your own. Refer to Introduction for general instructions on how to build sample projects.</p> <p>In addition to those general instructions, the sample project is also dependent on the After Effects SDK. Download it here. On Windows, create an environment variable pointing to it named \"AE_SDK_BASE_PATH\", so that the compiler will find the AE headers that the project includes. On</p> <p>MacOS, in XCode &gt; Preferences &gt; Locations &gt; Custom Paths, specify AE_SDK_BASE_PATH to be the root folder of the AE SDK you have downloaded and unzipped.</p> <p>As of version 15.4, Premiere Pro no longer supports OpenCL.</p> <p>If your transition uses CUDA, you'll need to download the CUDA SDK. On Windows, create an environment variable pointing to it named \"CUDA_SDK_BASE_PATH\", so that the linker will find the right libraries.</p>"},{"location":"ae-transition-extensions/getting-started/#compatibility-considerations","title":"Compatibility Considerations","text":"<p>For compatibility with plugin hosts that doesn't support the AE Transition Extensions, a plugin should check first for the existence of the PF_TransitionSuite suite. If it isn't available, the plugin should act as a normal effect. This is demonstrated in the SDK_CrossDissolve sample project.</p>"},{"location":"control-surfaces/control-surfaces/","title":"Control Surfaces","text":"<p>Starting in Premiere Pro CC 2014, a control surface plugin can interface with a hardware control surface. This is the API that provides built-in support for EUCON and Mackie devices to control audio mixing and basic transport controls. The API supports two-way communication with Premiere Pro, so that hardware faders, VU meters, etc are in sync with the application.</p> <p>Compile the sample plugin into a subfolder of the main application folder: <code>Plugins\\\\ ControlSurface\\\\</code></p> <p>You should see the plugin in the PPro UI in Preferences &gt; Control Surface, when you hit the Add button, as one of the options in the Device Class drop-down next to Mackie and EUCON (currently shows as \"SDK Control Surface Sample\").</p> <p>You'll want to implement handlers for any relevant functions defined in the plugin suites here: <code>adobesdk\\controlsurface\\plugin</code></p> <p>And to do that, you can use any APIs to call into the host defined in the host suites here: <code>adobesdk\\controlsurface\\host</code></p>"},{"location":"control-surfaces/control-surfaces/#calling-sequence","title":"Calling Sequence","text":"<p>When the application is launched, the control surface plugins are loaded, and the entry point is called. The host ID and API version is passed in, and the plugin passes back ADOBESDK_ControlSurfacePluginFuncs, an array of function pointers.</p> <p>Next, the Startup() function is called, where the plugin registers a suite of functions as defined in ControlSurfacePluginSuite.h. For each base class it will inherit from (defined in adobesdkcontrolsurfacepluginwrapper), it calls RegisterSuite(). These suites are the way for the host application to call the control surface plugin later on. There are separate base classes for the transport controls, audio mixer, Lumetri Color controls, and more.</p> <p>Then, CreatePluginInstance() is called. When a project is opened, Connect() is called. Here the plugin instantiates a ControlSurface object, which inherits from any of the previously mentioned base classes. It acquire any host suites it needs, and then it passes back a reference to the ControlSurface object.</p>"},{"location":"control-surfaces/control-surfaces/#getting-started","title":"Getting Started","text":"<p>Please write us if you would like further guidance.</p>"},{"location":"export-controllers/export-controllers/","title":"Export Controllers","text":"<p>Starting in Premiere Pro 5.0.2, an export controller can drive any exporter to generate a file in any format and perform custom post-processing operations. Developers wanting to integrate Premiere Pro with an asset management system will want to use this API instead.</p> <p>An export controller adds its own custom menu item to the File &gt; Export submenu. When the user chooses the menu item, the plugin is called with a TimelineID, which represents the current sequence. Although details on the current sequence are not passed in, the export controller can use the Sequence Info Suite to query for various properties. The export controller can then optionally display any custom modal UI to allow the user to set any parameters for the export.</p> <p>This UI will need to be provided by the export controller.</p> <p>The export controller should then call ExportFile in the Export Controller Suite, which takes the TimelineID, a path to an exporter preset, and a path for the output. This will tell Premiere Pro to handle the export, displaying progress. The call will return either a success value, an error, or that the user canceled. During the export, the UI will be blocked, just as when doing a standard export that doesn't use the Adobe Media Encoder Render Queue.</p> <p>Once Premiere Pro completes the export, the call will return to the export controller. The plugin can then perform any post-processing operations, such as transferring the newly exported file over the network, or registering the file in an asset management system.</p>"},{"location":"exporters/additional-details/","title":"Additional Details","text":""},{"location":"exporters/additional-details/#multiplexer-tab-ordering","title":"Multiplexer Tab Ordering","text":"<p>If your exporter provides a Multiplexer tab like some of the built-in exporters do, you may find that it appears after the Video and Audio tab, rather than before those tabs as in the case of our exporters. The key is to use the following define as the parameter identifer for the multiplexer tab group:</p> <pre><code>#define ADBEMultiplexerTabGroup \"ADBEAudienceTabGroup\"\n</code></pre>"},{"location":"exporters/additional-details/#creating-a-non-editable-string-in-the-parameter-ui","title":"Creating a Non-Editable String in the Parameter UI","text":"<p>During <code>exSelGenerateDefaultParams</code>, add a parameter with <code>exNewParamInfo.flags = exParamFlag_none</code>.</p> <p>Then during <code>exSelPostProcessParams</code>, call <code>AddConstrainedValuePair()</code> in the Export Param Suite.</p> <p>If you only add one value pair, then the parameter will be a non-editable string.</p> <p>In the case of the SDK Exporter sample, it adds two, which appear as a pair of radio buttons side-by-side.</p>"},{"location":"exporters/additional-details/#guidelines-for-exporters-in-premiere-elements","title":"Guidelines for Exporters in Premiere Elements","text":"<p>First, make sure you are building the exporter using the right SDK. Premiere Elements 8 requires the Premiere Pro CS4 SDK. The next version of Premiere Elements will likely use the CS5 SDK.</p>"},{"location":"exporters/additional-details/#exporter-preset","title":"Exporter Preset","text":"<p>For an exporter to show up in the Premiere Elements UI, you'll need to create and install a preset in a specific location:</p> <ol> <li>Create a folder named \"OTHERS\" in [App installation folder]/sharingcenter/Presets/pc/</li> <li>Create a sub-folder with your name (e.g. MyCompany) under OTHERS and place the preset file (.epr) in it. The final path of the preset file should be something like [App installation folder]/ sharingcenter/Presets/pc/OTHERS/MyCompany/MyPreset.epr</li> <li>Relaunch Premiere Elements.</li> <li>Add a clip to the timeline</li> <li>Goto the \"Share\" tab</li> <li>Under that choose \"Personal Computer\"</li> <li>You should see the \"Others - 3rd Party Plugins\" in the list of formats. Select this.</li> <li>Your preset should be seen in the drop-down.</li> </ol>"},{"location":"exporters/additional-details/#return-values","title":"Return Values","text":"<p>Premiere Elements 8 uses a slightly different definition of the return values. Use the following definition instead:</p> <pre><code>enum {\n  exportReturn_ErrNone = 0,\n  exportReturn_Abort,\n  exportReturn_Done,\n  exportReturn_InternalError,\n  exportReturn_OutputFormatAccept,\n  exportReturn_OutputFormatDecline,\n  exportReturn_OutOfDiskSpace,\n  exportReturn_BufferFull,\n  exportReturn_ErrOther,\n  exportReturn_ErrMemory,\n  exportReturn_ErrFileNotFound,\n  exportReturn_ErrTooManyOpenFiles,\n  exportReturn_ErrPermErr,\n  exportReturn_ErrOpenErr,\n  exportReturn_ErrInvalidDrive,\n  exportReturn_ErrDupFile,\n  exportReturn_ErrIo,\n  exportReturn_ErrInUse,\n  exportReturn_IterateExporter,\n  exportReturn_IterateExporterDone,\n  exportReturn_InternalErrorSilent,\n  exportReturn_ErrCodecBadInput,\n  exportReturn_ErrLastErrorSet,\n  exportReturn_ErrLastWarningSet,\n  exportReturn_ErrLastInfoSet,\n  exportReturn_ErrExceedsMaxFormatDuration,\n  exportReturn_VideoCodecNeedsActivation,\n  exportReturn_AudioCodecNeedsActivation,\n  exportReturn_IncompatibleAudioChannelType,\n  exportReturn_Unsupported = -100\n};\n</code></pre> <p>The red values are unique to Premiere Elements 8, and shifted the subsequent return values 2 values higher than their definition in the Premiere Pro SDK.</p>"},{"location":"exporters/exporters/","title":"Exporters","text":"<p>Exporters are used to export video, audio, and markers in any format. Exporters get individual video frames in a requested pixel format (generally, uncompressed video) and uncompressed audio. The exporter is responsible for any compression of the video and audio data, and wrapping the output in a file format. To reuse an existing exporter, you may provide an export controller.</p> <p>Exporters can be used from within Premiere Pro, or from Adobe Media Encoder. From within Premiere Pro, go to the File &gt; Export &gt; Media dialog. From there, the Export Settings dialog appears. The format chosen in the Format drop-down determines the exporter used, and the exporter provides the parameter settings and summary displayed in the Export Settings dialog.</p> <p>Exporters can optionally provide hardware acceleration by coordinating with a renderer plugin to render timeline segments. Legacy editing modes are formed by the combination of an exporter and a player; the exporter generates preview files and the player manages the cutlist.</p> <p>If you've never developed an exporter before, you can skip Whats New, and go directly to Getting Started.</p>"},{"location":"exporters/getting-started/","title":"Getting Started","text":"<p>Start your plugin by modifying the SDK sample. Step through the code in your debugger to learn the order of events.</p>"},{"location":"exporters/getting-started/#media-encoder-as-a-test-harness","title":"Media Encoder as a Test Harness","text":"<p>It may be faster to developing exporters using Media Encoder, since it is a lighter-weight application. However, you will want to test your exporter in Premiere Pro, to make sure the behavior is the same as when running in Media Encoder.</p>"},{"location":"exporters/getting-started/#adding-parameters","title":"Adding Parameters","text":"<p>Starting in CS6, the Export Standard Param Suite provides a way to add several basic sets of parameters, whether for video, audio, still sequences, etc. Beyond the standard parameters, custom defined parameters can be added using the Export Param Suite.</p> <p>First register the parameters during <code>exSelGenerateDefaultParams</code>. Then provide the localized strings and min/max parameter values during <code>exSelPostProcessParams</code>. When the exporter is sent <code>exSelExport</code> to export, get the user-specified parameter values using the Export Param Suite.</p>"},{"location":"exporters/getting-started/#updating-parameters-dynamically","title":"Updating Parameters Dynamically","text":"<p>Parameters can be updated dynamically based on user interaction with any related parameter. The time to update is during the <code>exSelValidateParamChanged</code> selector. Use ChangeParam in the Export Param Suite to make the change. Then, set <code>exParamChangedRec.rebuildAllParams</code> to true before returning. If you don't set that flag, parameters may appear out of order after a change.</p>"},{"location":"exporters/getting-started/#supporting-match-source","title":"Supporting \"Match Source\"","text":"<p>The exporter must set <code>exExporterInfoRec.canMatchSource</code> to true. This will add the Match Source button to the Video tab in the Export Settings.</p> <p>Next, if the Match Source button is pressed in the Export Settings, <code>exPostProcessParamsRec.doConformToMatchParams</code> will be true. The exporter should respond by updating any parameter values it can to match the source settings.</p>"},{"location":"exporters/getting-started/#get-video-frames-and-audio-samples","title":"Get Video Frames and Audio Samples","text":"<p>Starting in CS6, exporters can use the new push model, or the legacy pull model for obtaining frames. The new push model is supported starting in CS6, and the pull model is still supported.</p> <p>Push Model</p> <p>Using the push model, the exporter host can simply push frames to a thread-safe exporter-specified callback. Use DoMultiPassExportLoop in the Exporter Utility Suite to register the callback.</p> <p>Compared with the pull model, this will cut down on the code previously required for render loop management. It should also yield substantial performance increases for exporters that haven't finely tuned their multithreaded rendering.</p>"},{"location":"exporters/getting-started/#pull-model","title":"Pull Model","text":"<p>Using the pull model to get video and audio data involves making calls to the host to ask for this data. Use the Sequence Render Suite to get individual video frames, and the Sequence Audio Suite to get buffers of audio samples.</p> <p>Video frames can be requested synchronously or asynchronously. The asynchronous method can yield better performance, but it is up to the exporter to provide its asynchronous render loop.</p>"},{"location":"exporters/getting-started/#handling-a-pause-or-cancel-by-the-user-pull-model-only","title":"Handling a Pause or Cancel by the User (Pull Model only)","text":"<p>Push model export does not require any special code to handle pause or cancel by the user. For pull model export, the way to check if the user has paused or cancelled the export is to call UpdateProgressPercent in the Export Progress Suite, and check the return value. If the return value is suiteError_ExporterSuspended, the user has hit the pause button, which is only available in the Media Encoder UI. If the return value is <code>exportReturn_Abort</code>, then the export has been cancelled by the user.</p> <p>If UpdateProgressPercent returns <code>suiteError_ExporterSuspended</code>, then the exporter should next call <code>WaitForResume</code>, which will block until the user has unpaused the export.</p> <p>If UpdateProgressPercent returns <code>exportReturn_Abort</code>, the exporter should take steps to abort the export and clean up. Note that the exporter can still continue to ask for video frames and audio samples after a cancel has been received, which is useful in certain circumstances, such as if an exporter needs a few more frames to complete an MPEG GOP, or if it wants to include the audio for the video exported up to the point of cancel. This allows the exporter to generate well-formed output files, even in the case of a cancel.</p>"},{"location":"exporters/getting-started/#creating-presets","title":"Creating Presets","text":"<p>Create your own presets using the Export Settings UI, either from within Premiere Pro, or Media Encoder. Just modify the parameters the way you want, and hit the Save icon to save the preset to disk. The presets are saved with the extension '.epr'.</p> <p>Starting in CS5, all the presets are saved to the same location, regardless of whether saved from Premiere Pro or Media Encoder:</p> <p>On Windows 7, presets are saved here: <code>[User folder]\\AppData\\Roaming\\Adobe\\Common\\AME\\[version]\\Presets\\\\</code></p> <p>On Mac OS: <code>~/Library/Preferences/Adobe/Common/AME/[version]/Presets/</code></p> <p>In CS4, where the files are saved depends on whether you've opened the Export Settings UI in Premiere Pro or Media Encoder:</p>"},{"location":"exporters/getting-started/#media-encoder-presets","title":"Media Encoder presets","text":"<p>On Windows Vista, presets are saved here: <code>[User folder]\\AppData\\Roaming\\Adobe\\Adobe Media Encoder\\[version]\\Presets\\\\</code></p> <p>On Windows XP: <code>[Documents and Settings folder]\\[user name]\\Application Data\\\\ Adobe\\Adobe Media Encoder\\[version]\\Presets\\\\</code></p> <p>On Mac OS: <code>~/Library/Preferences/Adobe/Adobe Media Encoder/[version]/ Presets/</code></p>"},{"location":"exporters/getting-started/#premiere-pro-presets","title":"Premiere Pro presets","text":"<p>On Windows Vista, presets are saved here: <code>[User folder]\\AppData\\Roaming\\Adobe\\Premiere Pro\\[version]\\\\ Presets\\\\</code></p> <p>On Windows XP: <code>[Documents and Settings folder]\\[user name]\\Application Data\\\\ Adobe\\Premiere Pro\\[version]\\Presets\\\\</code></p> <p>On Mac OS: <code>~/Library/Preferences/Adobe/Adobe Premiere Pro/[version]/Presets/</code></p>"},{"location":"exporters/getting-started/#ame-preset-browser","title":"AME Preset Browser","text":"<p>Starting in CS6, Adobe Media Encoder has a Preset Browser with provides a structured organization of presets. Third-party presets can be added to any folder or subfolder within the main categories. Once you have created a preset, it will default to the Other folder. You can set the desired folder location in the <code>&lt;FolderDisplayPath&gt;</code> tag in the preset XML.</p> <p>For example, if you set it to: <code>&lt;FolderDisplayPath&gt;System Presets/Image Sequence/PNG&lt;/ FolderDisplayPath&gt;</code> then AME will display the preset in the <code>System Presets &gt; Image Sequence &gt; PNG folder</code>.</p> <p>It is essential to use: \"System Presets/xxx/\" where the xxx must be any of the existing main categories (use the English name for this). Only one level below can you can create a custom-named folder. If the folder doesn't already exist, it will be created.</p> <p>The Preset Browser data is cached in a file at: <code>[User Folder]\\AppData\\Roaming\\Adobe\\Common\\AME\\[version]\\Presets\\\\ PresetTree.xml</code></p> <p>If you want to force a refresh of the Preset Browser data, just quit AME, delete this file, and re-launch AME.</p>"},{"location":"exporters/getting-started/#installation-in-cs4","title":"Installation in CS4","text":"<p>For better performance, in CS4, we recommend you install any presets for your exporter in the application folder for Premiere Pro and Media Encoder.</p> <p>For both Windows and Mac OS: <code>[App installation path]\\MediaIO\\systempresets\\[exporter subfolder]</code></p> <p>The subfolder must be named based on the hexadecimal fourCCs of the ClassID and filetype of the exporter. For example, the SDK exporter has a ClassID of 'DTEK' or 0x4454454B, and a filetype of <code>SDK</code> or 0x53444B5F. So the subfolder must be named '4454454B_53444B5F'. For convenience, you can find the ClassID and filetype fourCCs in the preset file itself, in a decimal representation.</p>"},{"location":"exporters/getting-started/#parameter-caching","title":"Parameter Caching","text":"<p>During development, when you modify parameters in your exporter and reload the plugin into the host, the Settings UI may continue to show stale parameter data. New parameters that you have added may not appear, or old ones may continue to appear. Or if you have changed the UI for an existing parameter, it may not take effect.</p> <p>At a minimum, any old presets must be deleted. This includes Media Encoder presets and Premiere Pro presets. After deleting the old presets, there are two options, depending on whether the an older version of the exporter has already been distributed and is in use.</p>"},{"location":"exporters/getting-started/#increment-the-parameter-version","title":"Increment the Parameter Version","text":"<p>If an older version of the exporter is already being used by customers, you'll need to use parameter versioning. During <code>exSelGenerateDefaultParams</code>, you should call SetParamsVersion() in the Export Param Suite and increment the version number.</p> <p>After that, create new presets and sequence encoder presets (if needed) using the new set of parameters. Make sure your installer removes the old presets, and installs the new ones.</p>"},{"location":"exporters/getting-started/#flush-the-parameter-cache","title":"Flush the Parameter Cache","text":"<p>If you don't increment the parameter version, you can manually flush the parameter cache in a few steps. After you've deleted the old presets, do the following:</p> <ol> <li>Delete hidden presets that were created by the hosts for the most recently used parameter settings. Look for a file called Placeholder Preset.epr in both the folders above the Media Encoder presets and the Premiere Pro presets.</li> <li>Delete batch.xml, used by Media Encoder. This is also in the folder above the Media Encoder presets. Deleting this is equivalent to deleting the items out of the Media Encoder render queue.</li> <li>Delete Premiere Pro sequence encoder presets that use the exporter, if any</li> <li>Even after deleting all the old presets, Media Encoder may initially show old cached parameter UI. In the Settings UI, just switch to a different format and then back to yours.</li> </ol>"},{"location":"exporters/getting-started/#multichannel-audio-layouts","title":"Multichannel Audio Layouts","text":"<p>To support multichannel audio layouts, kPrAudioChannelType_MaxChannel should be the type requested in MakeAudioRenderer().</p> <p>The audio buffers you use for GetAudio() should likewise be an array of kPrAudioChannelType_MaxChannel channels, and yes, this means you may be allocating more space than actually used.</p> <p>In the exporter's Audio tab UI, you can provide a parameter to choose between various multi-channel audio layouts. You can compare your settings to what we have with the built-in formats, QuickTime and MXF (such as MXF OP1a and DNxHD). From the user selection in your audio export settings (e.g., 2x stereo, etc), you will know how many of those channels passed back in GetAudio() should actually be written to the file.</p> <p>Here's a helpful video on audio track mapping: http://www.video2brain.com/en/lessons/changes-in-audio-tracks-and-merged-clip-audio</p>"},{"location":"exporters/getting-started/#closed-captioning","title":"Closed Captioning","text":"<p>Starting in CC, the Export Settings includes a new Captions tab, for Closed Captioning export. For all formats, a sidecar file containing the captions can be exported. Additionally, exporters can optionally embed Closed Captioning directly in the output file. First, the exporter must set exExporterInfoRec.canEmbedCaptions to true. This will add the option to embed the captions in the output file, from the Export Options drop-down in the Captions tab. If this option is selected during export, exDoExportRec.embedCaptions will be true. The exporter should retrieve the captions using the Captioning Suite.</p>"},{"location":"exporters/getting-started/#multiple-file-formats","title":"Multiple File Formats","text":"<p>To support more than one file format in a single exporter, describe one format at a time during <code>exSelStartup</code>. After describing the first one, return exportReturn_IterateExporter from <code>exSelStartup</code>, and the exporter will be called again to describe the second format, and so on. After describing the last format, return exportReturn_IterateExporter, and the exporter will be called yet again. This time, return exportReturn_IterateExporterDone.</p> <p>Use a unique fileType for each format. When you are later sent <code>exSelGenerateDefaultParams</code>, <code>exSelPostProcessParams</code>, etc, you'll want to pay attention to the fileType, and respond according to the format.</p>"},{"location":"exporters/getting-started/#exporters-used-for-editing-modes","title":"Exporters Used for Editing Modes","text":"<p>An exporter that is used in an editing mode must have a codec parameter, and that parameter ID must be ADBEVideoCodec. If Premiere Pro cannot find this parameter, it will not be able to reopen projects in the custom editing mode, and will revert the project to Desktop mode.</p>"},{"location":"exporters/getting-started/#sequence-encoder-presets","title":"Sequence Encoder Presets","text":"<p>Sequence preview presets are now required for editing modes. These contain the exporter parameters to generate preview files. This makes preview file formats much easier to define, by using the Media Encoder or Premiere Pro UI to create presets, rather than directly editing XML.</p> <p>To create a sequence encoder preset:</p> <ol> <li>Create a preset. The name that you give it will be the name that will be used in the Sequence Settings &gt; General &gt; Preview File Format drop-down.</li> <li>Make sure this preset is installed in the application folder for Premiere Pro, along with the other sequence presets:</li> </ol> <p>On Windows, they should be installed here: <code>[App installation path]\\Settings\\EncoderPresets\\SequencePreview\\[editing mode GUID]*.epr</code></p> <p>On MacOS, it is basically the same (inside the application package): <code>[App installation path]/[Premiere Pro package]/Contents/Settings/EncoderPresets/ SequencePreview/[editing mode GUID]/*.epr</code></p> <p>As you can see by the installation paths above, Premiere Pro associates the sequence preview presets with the editing mode they go with, by using the presets in the folder that matches the GUID of the editing mode. The editing mode GUID is defined in the editing mode XML file, using the <code>&lt;EditingMode.ID&gt;</code> tag.</p>"},{"location":"exporters/getting-started/#adding-new-preview-file-formats-to-existing-editing-modes","title":"Adding new Preview File Formats to Existing Editing Modes","text":"<p>You can not only provide sequence preview presets for your own editing mode, but you could even add additional sequence preview presets for one of the built-in editing modes. Editing mode GUIDs for built-in editing modes can be found in the Adobe Editing Modes. xml file. For example, the Desktop editing mode on Windows has the GUID 9678AF98A7B7-4bdb-B477-7AC9C8DF4A4E. On Mac OS it is 795454D9-D3C2-429d-9474- 923AB13B7018.</p> <p>You can additionally restrict the list and specify which one is chosen by default, by editing the <code>&lt;PresetComments&gt;</code> tag in the preset file.</p> <p>If the value of the tag starts with \"IsConstrained,\", then a comma delimited list of 4ccs follows that dictates which codecs are available, and the first one is chosen by default.</p> <p>For example, QuickTime DV NTSC.epr for the Mac DV NTSC editing mode has this: <code>&lt;PresetComments&gt;IsConstrained,dvc &lt;/PresetComments&gt;</code></p> <p>Which restricts the codec selection of the exporter to be only the single codec choice.</p>"},{"location":"exporters/getting-started/#stereoscopic-video","title":"Stereoscopic Video","text":"<p>Note</p> <p>Currently stereoscopic exporters must use the old \"pull\" model, and only receive stereoscopic video when exporting directly from Premiere Pro. In other words, when exports are queued to run in Adobe Media Encoder, they will not get stereoscopic video.</p> <p>To get rendered frames for both left and right eye, use the Video Segment Suite to request the left and right cutlists, and render frames from both. An exporter can tell if segments in both of them are identical (implying that they have nothing stereoscopic about them) by looking at the segment hashes, and you can tell if two frames are identical (by looking at the request identifiers).</p>"},{"location":"exporters/getting-started/#timeline-segments-in-exporters","title":"Timeline Segments in Exporters","text":"<p>The timeline segments available to exporters do not always fully describe the sequence being exported. To consistently get timeline segments that fully describe the sequence, an exporter needs to work along with a renderer plugin.</p> <p>During a sequence export, Premiere Pro makes a copy of the project file and passes it to Media Encoder. Media Encoder takes that project and uses the PProHeadless process to generate rendered frames. So when an exporter, which is running in Media Encoder, parses the sequence, it only has a very high-level view. It sees the entire sequence as a single clip, and sees any optional cropping or filters as applied effects. So when parsing that simple, high-level sequence, if there are no effects, an exporter can just use the MediaNode's ClipID with the Clip Render Suite to get frames directly from the PProHeadless process. In the PProHeadless process, a renderer plugin can step in, parse the real sequence in all its glory, and optionally provide frames in a custom pixel format.</p> <p>When rendering preview files, Premiere Pro does the rendering without Media Encoder, so an exporter can get the individual segments for each clip, similar to before.</p>"},{"location":"exporters/getting-started/#smart-rendering","title":"Smart Rendering","text":"<p>Under very specific circumstances, an exporter can request compressed frames, avoiding unnecessary de/recompression.</p> <p>This would be done by providing both exporter and renderer plugins that parse timeline segments.</p> <p>If the source can be copied over to the destination, the compressed frames can be passed in a custom pixel format.</p> <p>These compressed frames are not guaranteed, however, so the exporter should be prepared to handle uncompressed frames.</p>"},{"location":"exporters/getting-started/#entry-point","title":"Entry Point","text":"<pre><code>DllExport PREMPLUGENTRY xSDKExport (\n  csSDK_int32      selector,\n  exportStdParms*  stdParmsP,\n  void*            param1,\n  void*            param2)\n</code></pre> <ul> <li><code>selector</code> is the action the host wants the exporter to perform.</li> <li><code>stdParms</code> provides callbacks to obtain additional information from the host or to have the host perform tasks.</li> <li>Parameters 1 and 2 vary with the selector; they may contain a specific value or a pointer to a structure.</li> </ul> <p>Return <code>exportReturn_ErrNone</code> if successful, or an appropriate return code.</p>"},{"location":"exporters/getting-started/#standard-parameters","title":"Standard Parameters","text":"<p>A pointer to this structure is sent from the host to the plugin with every selector.</p> <pre><code>typedef struct {\n  csSDK_int32               interfaceVer;\n  plugGetSPBasicSuiteFunc*  getSPBasicSuite;\n} exportStdParms;\n</code></pre> Member Description <code>interfaceVer</code> Exporter API version<ul><li>Premiere Pro CC - prExportVersion400</li><li>Premiere Pro CS6 - prExportVersion300</li><li>Premiere Pro CS5.5 - prExportVersion250</li><li>Premiere Pro CS5 - prExportVersion200</li><li>Premiere Pro 4.0.1 through 4.2.1 - prExportVersion101</li><li>Premiere Pro CS4 - prExportVersion100</li></ul> <code>getSPBasicSuite</code> This very important call returns the SweetPea suite that allows plugins to acquire and release all other SweetPea Suites.<code>SPBasicSuite* getSPBasicSuite();</code>"},{"location":"exporters/return-codes/","title":"Return Codes","text":"Return Code Reason <code>exportReturn_ErrNone</code> Operation has completed without error. <code>exportReturn_Abort</code> User aborted the export. <code>exportReturn_Done</code> Export finished normally. <code>exportReturn_InternalError</code> Return this if none of the other errors apply. <code>exportReturn_OutOfDiskSpace</code> Out of disk space error. <code>exportReturn_BufferFull</code> The offset into the buffer would overflow it. <code>exportReturn_ErrOther</code> The vaguer the better, right? <code>exportReturn_ErrMemory</code> Out of memory. <code>exportReturn_ErrFileNotFound</code> File not found. <code>exportReturn_ErrTooManyOpenFiles</code> Too many open files. <code>exportReturn_ErrPermErr</code> Permission violation. <code>exportReturn_ErrOpenErr</code> Unable to open the file. <code>exportReturn_ErrInvalidDrive</code> Invalid drive. <code>exportReturn_ErrDupFile</code> Duplicate filename. <code>exportReturn_ErrIo</code> File I/O error. <code>exportReturn_ErrInUse</code> File is in use. <code>exportReturn_IterateExporter</code> Return value from <code>exSelStartup</code> to request exporter iteration. <code>exportReturn_IterateExporterDone</code> Return value from <code>exSelStartup</code> to indicate there are no more exporters. <code>exportReturn_InternalErrorSilent</code> Return error code from <code>exSelExport</code> to put a custom error message on screen just before returning control to the host. <code>exportReturn_ErrCodecBadInput</code> A video codec refused the input format. <code>exportReturn_ErrLastErrorSet</code> The exporter is returning an error using the Error Suite. <code>exportReturn_ErrLastWarningSet</code> The exporter is returning a warning using the Error Suite. <code>exportReturn_ErrLastInfoSet</code> The exporter is returning information using the Error Suite. <code>exportReturn_ErrExceedsMaxFormatDuration</code> The exporter (or the host) has deemed the duration of the export to be too large. <code>exportReturn_VideoCodecNeedsActivation</code> The current video codec is not activated and cannot be used. <code>exportReturn_AudioCodecNeedsActivation</code> The current audio codec is not activated and cannot be used. <code>exportReturn_IncompatibleAudioChannelType</code> The requested audio channels are not compatible with the source audio. <code>exportReturn_IncompatibleVideoCodec</code> New in CS5. User tried to load a preset with an invalid video codec <code>exportReturn_IncompatibleAudioCodec</code> New in CS5. User tried to load a preset with an invalid audio codec <code>exportReturn_ParamButtonCancel</code> New in CS5.5. Return this from <code>exSelParamButton</code> if the user cancelled settings dialog by pressing cancel button. <code>exportReturn_ErrMediaFormat</code> Error encountered writing to media format. <code>exportReturn_ErrVideoEncoderCreation</code> Error encountered while creating video encoder. <code>exportReturn_ErrAudioEncoderConfiguration</code> Error encountered configuring audio encoder. <code>exportReturn_ErrVideoEncoderConfiguration</code> Error encountered configuring video encoder. <code>exportReturn_ErrInvalidPixelFormat</code> Pixel format not compatible with output format. <code>exportReturn_ErrOutputBuffer</code> Error creating output buffer. <code>exportReturn_ErrInputBuffer</code> Error accessing input buffer. <code>exportReturn_ErrAudioEncoder</code> Error encountered during audio encoding. <code>exportReturn_ErrVideoEncoder</code> Error encountered during video encoding. <code>exportReturn_ErrMuxer</code> Error encountered during muxing. <code>exportReturn_ErrVersion</code> Error encountered because of versions. <code>exportReturn_ErrColorSpace</code> Specified color space is not compatible with output format. <code>exportReturn_ErrVideoEncoderAdaptor</code> Error encountered using video encoding adaptor. <code>exportReturn_ErrPixelBufferCreation</code> Error creating pixel buffer. <code>exportReturn_ErrPixelBufferLock</code> Error encountered locking buffer. <code>exportReturn_ErrPixelBufferPlanarFormat</code> Error encountered with pixel buffer planar format. <code>exportReturn_ErrPixelBufferBytesMatch</code> Error encountered with byte matching, within pixel buffer. <code>exportReturn_ErrPixelBufferUnlock</code> Error encountered unlocking buffer. <code>exportReturn_ErrPixelBufferException</code> Error encountered; exception accessing buffer. <code>exportReturn_ErrPixelBufferAppend</code> Error appending to pixel buffer. <code>exportReturn_Unsupported</code> Unsupported selector."},{"location":"exporters/selector-descriptions/","title":"Selector Descriptions","text":"<p>This section provides a brief overview of each selector and highlights implementation issues.</p> <p>Additional implementation details are at the end of the chapter.</p>"},{"location":"exporters/selector-descriptions/#exselstartup","title":"exSelStartup","text":"<ul> <li>param1 - exExporterInfoRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Sent during application launch, unless the exporter has been cached.</p> <p>A single exporter can support multiple codecs and file extensions.</p> <p><code>exExporterInfoRec</code> describes the exporter's attributes, such as the format display name.</p>"},{"location":"exporters/selector-descriptions/#exselbegininstance","title":"exSelBeginInstance","text":"<ul> <li>param1 - exExporterInstanceRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Allocate any private data.</p>"},{"location":"exporters/selector-descriptions/#exselgeneratedefaultparams","title":"exSelGenerateDefaultParams","text":"<ul> <li>param1 - exGenerateDefaultParamRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Set the exporter's default parameters using the Export Param Suite.</p>"},{"location":"exporters/selector-descriptions/#exselpostprocessparams","title":"exSelPostProcessParams","text":"<ul> <li>param1 - exPostProcessParamsRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Post process parameters. This is where the localized strings for the parameter UI must be provided.</p>"},{"location":"exporters/selector-descriptions/#exselvalidateparamchanged","title":"exSelValidateParamChanged","text":"<ul> <li>param1 - exParamChangedRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Validate any parameters that have changed. Based on a change to a parameter value, the exporter may update other parameter values, or show/hide certain parameter controls, using the Export Param Suite.</p> <p>To notify the host that the plugin is changing other parameters, set <code>exParamChangedRec.rebuildAllParams</code> to a non-zero value.</p>"},{"location":"exporters/selector-descriptions/#exselgetparamsummary","title":"exSelGetParamSummary","text":"<ul> <li>param1 - exParamSummaryRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Provide a text summary of the current parameter settings, which will be displayed in the summary area of the Export Settings dialog.</p>"},{"location":"exporters/selector-descriptions/#exselparambutton","title":"exSelParamButton","text":"<ul> <li>param1 - exParamButtonRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Sent if exporter has one or more buttons in its parameter UI, and the user clicks one of the buttons in the Export Settings.</p> <p>The ID of the button pressed is passed in <code>exParamButtonRec.buttonParamIdentifier</code>.</p> <p>Display any dialog using platform-specific UI, collect any user input, and save any changes back to <code>privateData</code>.</p> <p>If the user cancels the dialog, return <code>exportReturn_ParamButtonCancel</code> to signify that nothing in the <code>privateData</code> has changed.</p>"},{"location":"exporters/selector-descriptions/#exselexport","title":"exSelExport","text":"<ul> <li>param1 - exDoExportRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Do the export! Sent when the user starts an export to the format supported by the exporter, or if the exporter is used in an Editing Mode and the user renders the work area.</p> <p>Single file exporters are sent this selector only once per export (e.g. AVI, QuickTime). To create a single file, setup a loop where you request each frame in the startTime to endTime range using one of the render calls in the Sequence Render Suite and GetAudio in the Sequence Audio Suite. For better performance, you can use the asynchronous calls in the Sequence Render Suite to have the host render multiple frames on multiple threads.</p> <p>Still frame exporters are sent <code>exSelExport</code> for each frame in the sequence (e.g. numbered TIFFs). The host will name the files appropriately.</p> <p>Save render time by checking to see if frames are repeated. Inspect the SequenceRender_GetFrameReturnRec.repeatCount returned from a render call, which holds a frame repeat count.</p>"},{"location":"exporters/selector-descriptions/#exselexport2","title":"exSelExport2","text":"<ul> <li>param1 - exDoExportRec2*</li> <li>param2 - <code>unused</code></li> </ul> <p>Do the export! Identical to exSelExport, except that exDoExportRec2 (which contains a LUT description) is passed.</p> <p>Exporter can specify the ID of the LUT that needs to be applied as last step in export processing. This is for including LUT for doing color space conversion in export path.</p> <p>In case LUT is specified, <code>ExportColorSpace</code> signifies the output color space of LUT.</p>"},{"location":"exporters/selector-descriptions/#exselqueryexportfileextension","title":"exSelQueryExportFileExtension","text":"<ul> <li>param1 - exQueryExportFileExtensionRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>For exporters that support more than one file extension, specify an extension given the file type.</p> <p>If this selector is not supported by the exporter, the extension is specified by the exporter in <code>exExporterInfoRec.fileTypeDefaultExtension</code>.</p>"},{"location":"exporters/selector-descriptions/#exselqueryoutputfilelist","title":"exSelQueryOutputFileList","text":"<ul> <li>param1 - exQueryOutputFileListRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>For exporters that export to more than one file. This is called before an export for the host to find out which files would need to be overwritten.</p> <p>It is called after an export so the host will know about all the files created, for any post encoding tasks, such as FTP. If this selector is not supported by the exporter, the host application will only know about the original path.</p> <p>This selector will be called three times. On the first call, the plugin fills out numOutputFiles. The host will then make numOutputFiles count of outputFileRecs, but empty.</p> <p>On the second call, the plugin fills out the path length (incl trailing null) for each exOutputFileRec element in outputFileRecs. The host will then allocate all paths in each outputFileRec.</p> <p>On the third call, the plugin fills in the path members of the outputFileRecs.</p>"},{"location":"exporters/selector-descriptions/#exselquerystillsequence","title":"exSelQueryStillSequence","text":"<ul> <li>param1 - exQueryStillSequenceRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>The host application asks a still-only exporter if it wants to export as a sequence, and at what frame rate.</p>"},{"location":"exporters/selector-descriptions/#exselqueryoutputsettings","title":"exSelQueryOutputSettings","text":"<ul> <li>param1 - exQueryOutputSettingsRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>The host application asks the exporter for general details about the current settings. This is a required selector.</p>"},{"location":"exporters/selector-descriptions/#exselvalidateoutputsettings","title":"exSelValidateOutputSettings","text":"<ul> <li>param1 - exValidateOutputSettingsRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>The host application asks the exporter if it can export with the current settings.</p> <p>The exporter should return <code>exportReturn_ErrLastErrorSet</code> if not, and the error string should be set to a description of the failure.</p>"},{"location":"exporters/selector-descriptions/#exselendinstance","title":"exSelEndInstance","text":"<ul> <li>param1 - exExporterInstanceRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Deallocate any private data.</p>"},{"location":"exporters/selector-descriptions/#exselshutdown","title":"exSelShutdown","text":"<ul> <li>param1 - <code>unused</code></li> <li>param2 - <code>unused</code></li> </ul> <p>Sent immediately before shutdown. Free all remaining memory and close any open file handles.</p>"},{"location":"exporters/selector-descriptions/#exselqueryexportcolorspace","title":"exSelQueryExportColorSpace","text":"<ul> <li>param1 - exExporterInstanceRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Describe the color space to be used during export.</p>"},{"location":"exporters/selector-table/","title":"Selector Table","text":"<p>This table summarizes the various selector commands an exporter can receive.</p> Selector param1 param2 exSelStartup exExporterInfoRec* unused exSelBeginInstance exExporterInstanceRec* unused exSelGenerateDefaultParams exGenerateDefaultParamRec* unused exSelPostProcessParams exPostProcessParamsRec* unused exSelValidateParamChanged exParamChangedRec* unused exSelGetParamSummary exParamSummaryRec* unused exSelParamButton exParamButtonRec* unused exSelExport exDoExportRec* unused exSelQueryExportFileExtension exQueryExportFileExtensionRec* unused exSelQueryOutputFileList exQueryOutputFileListRec* unused exSelQueryStillSequence exQueryStillSequenceRec* unused exSelQueryOutputSettings exQueryOutputSettingsRec* unused exSelValidateOutputSettings exValidateOutputSettingsRec* unused exSelExport2 exDoExportRec2* unused exSelQueryExportColorSpace exQueryExportColorSpaceRec* unused exSelShutdown exExporterInfoRec* unused"},{"location":"exporters/structure-descriptions/","title":"Structure Descriptions","text":""},{"location":"exporters/structure-descriptions/#exdoexportrec","title":"exDoExportRec","text":"<p>Selector: exSelExport</p> <p>Provides general export settings. The exporter should retrieve the parameter settings from the Export Param Suite.</p> <pre><code>typedef struct {\n  csSDK_uint32  exporterPluginID;\n  void*         privateData;\n  csSDK_uint32  fileType;\n  csSDK_int32   exportAudio;\n  csSDK_int32   exportVideo;\n  PrTime        startTime;\n  PrTime        endTime;\n  csSDK_uint32  fileObject;\n  PrTimelineID  timelineData;\n  csSDK_int32   reserveMetaDataSpace;\n  csSDK_int32   maximumRenderQuality;\n  csSDK_int32   embedCaptions\n} exDoExportRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter, used for various suite calls, such as in the Sequence Render Suite and Sequence Audio Suite. <code>privateData</code> Data allocated and managed by the exporter. <code>fileType</code> The file format four character code set by the exporter during exSelStartup.Indicates which format the exporter should write, since exporters can support multiple formats. <code>exportAudio</code> If non-zero, export audio. <code>exportVideo</code> If non-zero, export video. <code>startTime</code> The start time of the sequence to export. <code>endTime</code> The end time of the sequence to export. If startTime is 0, also the total duration to export.Range specified is <code>[startTime, endTime)</code>, meaning the <code>endTime</code> is not actually included in the range. <code>fileObject</code> For use with the Export File Suite, to get and manipulate the file specified by the user. <code>timelineData</code> Handle used for the Timeline Functions. <code>reserveMetaDataSpace</code> Amount to reserve in a file for metadata storage. <code>maximumRenderQuality</code> If non-zero, the exporter should set <code>SequenceRender_ParamsRec.inRenderQuality</code> and <code>inDeinterlaceQuality</code> to <code>kPrRenderQuality_Max</code>. <code>embedCaptions</code> New in CC. If non-zero, the exporter should embed captions obtained from the Captioning Suite. <code>colorProfile</code> Amount to reserve in a file for metadata storage. <code>exportColorSpaceID</code> Amount to reserve in a file for metadata storage. <code>maximumFileSize</code> Amount to reserve in a file for metadata storage."},{"location":"exporters/structure-descriptions/#exdoexportrec2","title":"exDoExportRec2","text":"<p>Selector: exSelExport</p> <p>Provides general export settings. The exporter should retrieve the parameter settings from the Export Param Suite.</p> <pre><code>typedef struct {\n  csSDK_uint32      exporterPluginID;\n  void*             privateData;\n  csSDK_uint32      fileType;\n  csSDK_int32       exportAudio;\n  csSDK_int32       exportVideo;\n  PrTime            startTime;\n  PrTime            endTime;\n  csSDK_uint32      fileObject;\n  PrTimelineID      timelineData;\n  csSDK_int32       reserveMetaDataSpace;\n  csSDK_int32       maximumRenderQuality;\n  csSDK_int32       embedCaptions;\n  ColorProfileRec       colorProfile;                         // if color profile is valid, exporter should embed into output per format standards; for formats that set canEmbedColorProfile to True\n  PrSDKColorSpaceID exportColorSpaceID;               // opaque color space ID that exporter should pass to the host when using color managed APIs\n  csSDK_int32             maximumFileSize;                    // if non-0, try to export a file not exceeding this size an possible adjust the TragetBitrate for this.\n  PrSDKLUTID              exportLUTID;\n} exDoExportRec2;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter, used for various suite calls, such as in the Sequence Render Suite and Sequence Audio Suite. <code>privateData</code> Data allocated and managed by the exporter. <code>fileType</code> The file format four character code set by the exporter during exSelStartup.Indicates which format the exporter should write, since exporters can support multiple formats. <code>exportAudio</code> If non-zero, export audio. <code>exportVideo</code> If non-zero, export video. <code>startTime</code> The start time of the sequence to export. <code>endTime</code> The end time of the sequence to export. If startTime is 0, also the total duration to export.Range specified is <code>[startTime, endTime)</code>, meaning the <code>endTime</code> is not actually included in the range. <code>fileObject</code> For use with the Export File Suite, to get and manipulate the file specified by the user. <code>timelineData</code> Handle used for the Timeline Functions. <code>reserveMetaDataSpace</code> Amount to reserve in a file for metadata storage. <code>maximumRenderQuality</code> If non-zero, the exporter should set <code>SequenceRender_ParamsRec.inRenderQuality</code> and <code>inDeinterlaceQuality</code> to <code>kPrRenderQuality_Max</code>. <code>embedCaptions</code> New in CC. If non-zero, the exporter should embed captions obtained from the Captioning Suite. <code>colorProfile</code> New in 13.1.  Color profile, to be embedded into output per format standards. For formats which have set <code>canEmbedColorProfile</code> to true. <code>exportColorSpaceID</code> New in 13.1.  ID of the color space to be used. Must not be <code>kPrSDKColorSpaceID_Invalid</code>. <code>maximumFileSize</code> New in 15.x.  If non-zero, the Exporter should consider this as a ceiling for file size, and re-compress as needed in order to meet that target. <code>exportLUTID</code> New in 14.x. the LUT being used for export."},{"location":"exporters/structure-descriptions/#exexporterinforec","title":"exExporterInfoRec","text":"<p>Selector: exSelStartup and exSelShutdown (starting in CS6)</p> <p>Describe the exporter's capabilities by filling out this structure during exSelStartup.</p> <p>For each filetype, populate exExporterInfoRec and return <code>exportReturnIterateExporter</code>.</p> <p>exSelStartup will then be resent. Repeat the process until there are no more file formats to describe, then return <code>exportReturn_IterateExporterDone</code>.</p> <p>The fileType indicates which format the exporter should currently work with in subsequent calls.</p> <pre><code>typedef struct {\n  csSDK_uint32  unused;\n  csSDK_uint32  fileType;\n  prUTF16Char   fileTypeName[256];\n  prUTF16Char   fileTypeDefaultExtension[256];\n  csSDK_uint32  classID;\n  csSDK_int32   exportReqIndex;\n  csSDK_int32   wantsNoProgressBar;\n  csSDK_int32   hideInUI;\n  csSDK_int32   doesNotSupportAudioOnly;\n  csSDK_int32   canExportVideo;\n  csSDK_int32   canExportAudio;\n  csSDK_int32   singleFrameOnly;\n  csSDK_int32   maxAudiences;\n  csSDK_int32   interfaceVersion;\n  csSDK_uint32  isCacheable;\n  csSDK_uint32  canConformToMatchParams;\n  csSDK_uint32  canEmbedCaptions;\n} exExporterInfoRec;\n</code></pre> Member Description <code>fileType</code> The file format four character code (e.g. 'AVIV' = Video for Windows, 'MooV' = QuickTime). <code>fileTypeName</code> The localized display name for the fileype. <code>fileTypeDefaultExtension</code> The default extension for the filetype. An exporter can support multiple extensions per filetype, by implementing <code>exSelQueryExportFileExtension</code>. <code>classID</code> Class identifier for the module, differentiates between exporters that support the same filetype and creates associations between different Media Abstraction Layer plugins. <code>exportReqIndex</code> If an exporter supports multiple filetypes, this index will be incremented by the host for each call, as the exporter is requested to describe its capabilities for each filetype.Initially zero, incremented by the host each time the exporter returns <code>exportReturn_IterateExporter</code>. <code>wantsNoProgressBar</code> If non-zero, the default exporter progress dialog will be turned off, allowing the exporter to display its own progress dialog.The exporter also will not get <code>exportReturn_Abort</code> errors from the host during callbacks - it must detect an abort on its own, and return <code>exportReturn_Abort</code> from <code>exSelExport</code> if the user aborts the export. <code>hideInUI</code> Set this to non-zero if this filetype should only be used for making preview files, and should not be visible as a general export choice. <code>doesNotSupportAudioOnly</code> Set this to non-zero for filetypes that do not support audio-only exports. <code>canExportVideo</code> Set this to non-zero if the exporter can output video. <code>canExportAudio</code> Set this to non-zero if the exporter can output audio. <code>singleFrameOnly</code> Set this to non-zero if the exporter makes single frames (used by still image exporters). <code>maxAudiences</code> <code>interfaceVersion</code> Exporter API version that the plugin supports. <code>isCacheable</code> New in CS5. Set this non-zero to have Premiere Pro cache this exporter. <code>canConformToMatchParams</code> New in CC. Set this to non-zero if the exporter wants to support the Match Source button. <code>canEmbedCaptions</code> New in CC. Set this to non-zero if the exporter can embed Closed Captioning directly in the file. <code>flags</code> New in 13.0. Will be some combination of the following flag:<ul><li><code>kExInfoRecFlag_None</code></li><li><code>kExInfoRecFlag_VideoOnlyExportNotSupported</code> - exports only video and audio together</li><li><code>kExInfoRecFlag_PostEncodePublishNotSupported</code> - exported result is a complex folder structure or otherwise unsuitable for enabling upload options</li></ul> <code>canEmbedColorProfile</code> New in 11.1. Set this to non-zero if the exporter can embed color profile into the resulting media file <code>supportsColorManagement</code> New in 13.0. Set this to non-zero if the exporter supports color management."},{"location":"exporters/structure-descriptions/#exexporterinstancerec","title":"exExporterInstanceRec","text":"<p>Selector: exSelBeginInstance and exSelEndInstance</p> <p>Provides access to the privateData for the indicated filetype, so that the exporter can allocate privateData and pass it to the host, or deallocate it.</p> <pre><code>typedef struct {\n  csSDK_uint32  exporterPluginID;\n  csSDK_uint32  fileType;\n  void*         privateData;\n} exExporterInstanceRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter. Do not modify. <code>fileType</code> The file format four character code set by the exporter during exSelStartup. <code>privateData</code> Data allocated and managed by the exporter."},{"location":"exporters/structure-descriptions/#exgeneratedefaultparamrec","title":"exGenerateDefaultParamRec","text":"<p>Selector: exSelGenerateDefaultParams</p> <p>Provides access to the privateData for the indicated filetype, so that the exporter can generate the default parameter set.</p> <pre><code>typedef struct {\n  csSDK_uint32  exporterPluginID;\n  void*         privateData;\n  csSDK_uint32  fileType;\n} exExporterInstanceRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter. Do not modify. <code>privateData</code> Data allocated and managed by the exporter. <code>fileType</code> The file format four character code set by the exporter during exSelStartup."},{"location":"exporters/structure-descriptions/#exparambuttonrec","title":"exParamButtonRec","text":"<p>Selector: exSelParamButton</p> <p>Provides access to the privateData for the indicated filetype, and discloses the specific button hit by the user, since there can be multiple button parameters.</p> <pre><code>typedef struct {\n  csSDK_uint32       exporterPluginID;\n  void*              privateData;\n  csSDK_uint32       fileType;\n  csSDK_int32        exportAudio;\n  csSDK_int32        exportVideo;\n  csSDK_int32        multiGroupIndex;\n  exParamIdentifier  buttonParamIdentifier;\n} exParamButtonRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter. Do not modify. <code>privateData</code> Data allocated and managed by the exporter. <code>fileType</code> The file format four character code set by the exporter during exSelStartup. <code>exportAudio</code> If non-zero, the current settings are set to export audio. <code>exportVideo</code> If non-zero, the current settings are set to export video. <code>multiGroupIndex</code> Discloses the index of the multi-group, containing the button hit by the user. <code>buttonParamIdentifier</code> Discloses the parameter ID of the button hit by the user."},{"location":"exporters/structure-descriptions/#exparamchangedrec","title":"exParamChangedRec","text":"<p>Selector: exSelValidateParamChanged</p> <p>Provides access to the privateData for the indicated filetype, and discloses the specific parameter changed by the user.</p> <p>To notify the host that the plugin is changing other parameters, set <code>rebuildAllParams</code> to a non-zero value.</p> <pre><code>typedef struct {\n  csSDK_uint32       exporterPluginID;\n  void*              privateData;\n  csSDK_uint32       fileType;\n  csSDK_int32        exportAudio;\n  csSDK_int32        exportVideo;\n  csSDK_int32        multiGroupIndex;\n  exParamIdentifier  changedParamIdentifier;\n  csSDK_int32        rebuildAllParams;\n} exParamChangedRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter. Do not modify. <code>privateData</code> Data allocated and managed by the exporter. <code>fileType</code> The file format four character code set by the exporter during exSelStartup. <code>exportAudio</code> If non-zero, the current settings are set to export audio. <code>exportVideo</code> If non-zero, the current settings are set to export video. <code>multiGroupIndex</code> Discloses the index of the multi-group, containing the parameter changed by the user. <code>changedParamIdentifier</code> Discloses the parameter ID of the parameter changed by the user.May be empty if the changed item was exportAudio, exportVideo or the current multiGroupIndex. <code>rebuildAllParams</code> Set this to non-zero to tell the host to refresh ALL parameters using the latest provided information.This can solve various problems when dynamically updating parameter visibility, valid ranges, etc."},{"location":"exporters/structure-descriptions/#exparamsummaryrec","title":"exParamSummaryRec","text":"<p>Selector: exSelGetParamSummary</p> <p>Provides access to the privateData for the indicated filetype, and provides buffers for the exporter to fill in with a localized summary of the parameters.</p> <pre><code>typedef struct {\n  csSDK_uint32  exporterPluginID;\n  void*         privateData;\n  csSDK_int32   exportAudio;\n  csSDK_int32   exportVideo;\n  prUTF16Char   videoSummary[256];\n  prUTF16Char   audioSummary[256];\n  prUTF16Char   bitrateSummary[256];\n} exParamSummaryRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter. Do not modify. <code>privateData</code> Data allocated and managed by the exporter. <code>exportAudio</code> If non-zero, the current settings are set to export audio. <code>exportVideo</code> If non-zero, the current settings are set to export video. <code>videoSummary</code> Fill these in with a line of a localized summary of the parameters. <code>audioSummary</code> <code>bitrateSummary</code>"},{"location":"exporters/structure-descriptions/#expostprocessparamsrec","title":"exPostProcessParamsRec","text":"<p>Selector: exSelPostProcessParams</p> <p>Provides access to the privateData for the indicated filetype.</p> <pre><code>typedef struct {\n  csSDK_uint32  exporterPluginID;\n  void*         privateData;\n  csSDK_uint32  fileType;\n  csSDK_int32   exportAudio;\n  csSDK_int32   exportVideo;\n  csSDK_int32   doConformToMatchParams;\n} exPostProcessParamsRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter. Do not modify. <code>privateData</code> Data allocated and managed by the exporter. <code>fileType</code> The file format four character code set by the exporter during exSelStartup. <code>exportAudio</code> If non-zero, the current settings are set to export audio. <code>exportVideo</code> If non-zero, the current settings are set to export video. <code>doConformToMatchParams</code> New in CC."},{"location":"exporters/structure-descriptions/#exqueryexportfileextensionrec","title":"exQueryExportFileExtensionRec","text":"<p>Selector: exSelQueryExportFileExtension</p> <p>Provides access to the privateData for the indicated filetype, and provides a buffer for the exporter to fill in with the file extension.</p> <pre><code>typedef struct {\n  csSDK_uint32  exporterPluginID;\n  void*         privateData;\n  csSDK_uint32  fileType;\n  prUTF16Char   outFileExtension[256];\n} exQueryExportFileExtensionRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter. Do not modify. <code>privateData</code> Data allocated and managed by the exporter. <code>fileType</code> The file format four character code set by the exporter during exSelStartup. <code>outFileExtension</code> Provide the file extension here, given the current parameter settings."},{"location":"exporters/structure-descriptions/#exqueryoutputfilelistrec","title":"exQueryOutputFileListRec","text":"<p>Selector: exSelQueryOutputFileList</p> <p>Provides access to the privateData for the indicated filetype, and provides a pointer to a array of <code>exOutputFileRecs</code> for the exporter to fill in with the file paths.</p> <pre><code>typedef struct {\n  csSDK_uint32     exporterPluginID;\n  void*            privateData;\n  csSDK_uint32     fileType;\n  csSDK_uint32     numOutputFiles;\n  PrSDKString      path;\n  exOutputFileRec  *outputFileRecs;\n} exQueryOutputFileListRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter. Do not modify. <code>privateData</code> Data allocated and managed by the exporter. <code>fileType</code> The file format four character code set by the exporter during exSelStartup. <code>numOutputFiles</code> On the first call to <code>exSelQueryOutputFileList</code>, provide the number of file paths here. <code>path</code> New in CS5. Contains the primary intended destination path provided by the host. <code>outputFileRecs</code> An array of <code>exOutputFileRecs</code>.On the second call to <code>exSelQueryOutputFileList</code>, the path length (including trailing null) for each path.On the third call, fill in the path of each exOutputFileRec.<pre>typedef struct {  int           pathLength;  prUTF16Char*  path;} exOutputFileRec;</pre>"},{"location":"exporters/structure-descriptions/#exqueryoutputsettingsrec","title":"exQueryOutputSettingsRec","text":"<p>Selector: exSelQueryOutputSettings</p> <p>Provides access to the privateData for the indicated filetype, and provides a set of members for the exporter to fill in with the current export settings.</p> <pre><code>typedef struct {\n  csSDK_uint32        exporterPluginID;\n  void*               privateData;\n  csSDK_uint32        fileType;\n  csSDK_int32         inMultiGroupIndex;\n  csSDK_int32         inExportVideo;\n  csSDK_int32         inExportAudio;\n  csSDK_int32         outVideoWidth;\n  csSDK_int32         outVideoHeight;\n  PrTime              outVideoFrameRate;\n  csSDK_int32         outVideoAspectNum;\n  csSDK_int32         outVideoAspectDen;\n  csSDK_int32         outVideoFieldType;\n  double              outAudioSampleRate;\n  PrAudioSampleType   outAudioSampleType;\n  PrAudioChannelType  outAudioChannelType;\n  csSDK_uint32        outBitratePerSecond;\n  csSDK_int32         outUseMaximumRenderPrecision;\n} exQueryOutputSettingsRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter. Do not modify. <code>privateData</code> Data allocated and managed by the exporter. <code>fileType</code> The file format four character code set by the exporter during exSelStartup. <code>inMultiGroupIndex</code> Return the parameter settings of the multi-group with this index. <code>inExportVideo</code> If non-zero, the current settings are set to export video. <code>inExportAudio</code> If non-zero, the current settings are set to export audio. <code>outVideoWidth</code><code>outVideoHeight</code> Return each parameter setting, by getting the current value of the parameter using the Export Param Suite.Some settings, such as <code>outVideoFieldType</code>, may be implicit, for example if the format only supports progressive frames. <code>outUseMaximumRenderPrecision</code> New in CS6. If non-zero, renders will always be made at maximum bit-depth."},{"location":"exporters/structure-descriptions/#exquerystillsequencerec","title":"exQueryStillSequenceRec","text":"<p>Selector: exSelQueryStillSequence</p> <p>Provides access to the privateData for the indicated filetype, and provides a set of members for the exporter to provide information on how it would export the sequence of stills.</p> <pre><code>typedef struct {\n  csSDK_uint32  exporterPluginID;\n  void*         privateData;\n  csSDK_uint32  fileType;\n  csSDK_int32   exportAsStillSequence;\n  PrTime        exportFrameRate;\n} exQueryStillSequenceRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter. Do not modify. <code>privateData</code> Data allocated and managed by the exporter. <code>fileType</code> The file format four character code set by the exporter during exSelStartup. <code>exportAsStillSequence</code> Set this to non-zero to tell the host that the exporter can export the stills as a sequence. <code>exportFrameRate</code> Set this to the frame rate of the still sequence."},{"location":"exporters/structure-descriptions/#exvalidateoutputsettingsrec","title":"exValidateOutputSettingsRec","text":"<p>Selector: exSelValidateOutputSettings</p> <p>Provides access to the privateData for the indicated filetype, so that the exporter can validate the current parameter settings.</p> <pre><code>typedef struct {\n  csSDK_uint32  exporterPluginID;\n  void*         privateData;\n  csSDK_uint32  fileType;\n} exExporterInstanceRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter. Do not modify. <code>privateData</code> Data allocated and managed by the exporter. <code>fileType</code> The file format four character code set by the exporter during exSelStartup."},{"location":"exporters/structure-descriptions/#exqueryexportcolorspacerec","title":"exQueryExportColorSpaceRec","text":"<p>Selector: exSelQueryExportColorSpace</p> <p>Provides access to the privateData for the indicated filetype, so that the exporter can validate the current parameter settings.</p> <pre><code>typedef struct\n{\n  csSDK_uint32        exporterPluginID;\n  void*                           privateData;\n  ColorSpaceRec       outExportColorSpace;\n} exQueryExportColorSpaceRec;\n</code></pre> Member Description <code>exporterPluginID</code> The host's internal identifier for this exporter. Do not modify. <code>privateData</code> Data allocated and managed by the exporter. <code>outExportColorSpace</code> Structure describing the colorspace to be used during export. Check <code>ColorSpaceRec</code> for details."},{"location":"exporters/structures/","title":"Structures","text":"Structure Sent with selector exDoExportRec exSelExport exExporterInfoRec exSelStartup exExporterInstanceRec exSelBeginInstance and exSelEndInstance exGenerateDefaultParamRec exSelGenerateDefaultParams exParamButtonRec exSelParamButton exParamChangedRec exSelValidateParamChanged exParamSummaryRec exSelGetParamSummary exPostProcessParamsRec exSelPostProcessParams exQueryExportFileExtensionRec exSelQueryExportFileExtension exQueryOutputFileListRec exSelQueryOutputFileList exQueryOutputSettingsRec exSelQueryOutputSettings exQueryStillSequenceRec exSelQueryStillSequence exValidateOutputSettingsRec exSelValidateOutputSettings"},{"location":"exporters/suites/","title":"Suites","text":"<p>For information on how to acquire and manage suites, see SweetPea Suites.</p>"},{"location":"exporters/suites/#export-file-suite","title":"Export File Suite","text":"<p>A cross-platform suite for writing to files on disk. Also provides a call to get the file path, given the file object.</p> <p>Version 2 resolves a mismatch in seek modes in version 1, where <code>fileSeekMode_End</code> was handled as <code>fileSeekMode_Current</code> and visa versa.</p> <p>See PrSDKExportFileSuite.h.</p>"},{"location":"exporters/suites/#export-info-suite","title":"Export Info Suite","text":""},{"location":"exporters/suites/#getexportsourceinfo","title":"GetExportSourceInfo","text":"<p>Get information on the source currently being exported.</p> <pre><code>prSuiteError (*GetExportSourceInfo)(\n  csSDK_uint32                inExporterPluginID,\n  PrExportSourceInfoSelector  inSelector,\n  PrParam                     *outSourceInfo);\n</code></pre> Value Type Description <code>kExportInfo_VideoWidth</code> Int32 Width of source video <code>kExportInfo_VideoHeight</code> Int32 Height of source video <code>kExportInfo_VideoFrameRate</code> PrTime Frame rate <code>kExportInfo_VideoFieldType</code> Int32 One of the prFieldType values <code>kExportInfo_VideoDuration</code> Int64 A PrTime value <code>kExportInfo_PixelAspectNumerator</code> Int32 Pixel aspect ratio (PAR) numerator <code>kExportInfo_PixelAspectDenominator</code> Int32 Pixel aspect ratio denominator <code>kExportInfo_AudioDuration</code> Int64 A PrTime value <code>kExportInfo_AudioChannelsType</code> Int32 One of the <code>PrAudioChannelType</code> values.Returns 0 (which is undefined) if there's no audio. <code>kExportInfo_AudioSampleRate</code> Float64 <code>kExportInfo_SourceHasAudio</code> Bool Non-zero if source has audio <code>kExportInfo_SourceHasVideo</code> Bool Non-zero if source has video <code>kExportInfo_RenderAsPreview</code> Bool Returns a non-zero value if currently rendering preview files. <code>kExportInfo_SequenceGUID</code> Guid A <code>PrPluginID</code>, which is a unique GUID for the sequence. <code>kExportInfo_SessionFilePath</code> PrMemoryPtr A <code>prUTF16Char</code> array. The exporter should release the pointer using the Memory Manager Suite. <code>kExportInfo_VideoPosterFrameTickTime</code> Int64 New in CS5. A PrTime value. <code>kExportInfo_SourceTimecode</code> PrMemoryPtr New in CS5.0.2. The timecode of the source clip or sequence.The sequence timecode is set by the Start Time of a sequence using the sequence wing-menu. A pointer to a ExporterTimecodeRec structure.The exporter should release the pointer using the Memory Manager Suite. <code>kExportInfo_UsePreviewFiles</code> Bool New in CC. Use this to check if the user has checked \"Use Previews\" in the Export Settings dialog.If so, if possible, reuse any preview files already rendered, which can be retrieved using <code>AcquireVideoSegmentsWithPreviewsID</code> in the Video Segment Suite. <code>kExportInfo_NumAudioChannels</code> Int32 New in CC. Get the number of audio channels in a given source.This can be used to automatically initialize the audio channel parameter in the Audio tab of the Export Settings to match the source. <pre><code>typedef struct {\n  csSDK_int64  mTimecodeTicks;\n  csSDK_int64  mTicksPerFrame;\n  bool         mTimecodeStartPrefersDropFrame;\n} ExporterTimecodeRec;\n</code></pre>"},{"location":"exporters/suites/#export-param-suite","title":"Export Param Suite","text":"<p>Specify all parameters for your exporter UI. See PrSDKExportParamSuite.h.</p> <p>Also, see the SDK Export sample for a demonstration of how to use this suite.</p> <p>To provide either a set of radio buttons or a drop-down list of choices, use AddConstrainedValuePair().</p> <p>Adding two choices will result in a pair of radio buttons side-by-side.</p> <p>Three or more choices will be displayed as a drop-down box.</p> <p>Adding only one value will result in a hard-coded string.</p> <p>In CS5, and later fixed in 5.0.2, there is an issue where width and height ranges aren't correctly set.</p> <p>You may notice this when adjusting the width and height in the Export Settings UI.</p> <p>By unclicking the chain that constrains width and height ratio, you will be able to modify the width and height.</p> <p>As a side-effect of this bug, if the exporter is used to render preview files in an Editing Mode, the user will be able to choose any preview frame size between 24x24 and 10240x8192.</p> <p>CS6 adds SetParamDescription(), to set tooltip strings for parameters.</p> <p>CC adds MoveParam(), to move an existing parameter to a new location. This can be used for both standard parameters and group parameters.</p>"},{"location":"exporters/suites/#export-progress-suite","title":"Export Progress Suite","text":"<p>For pull-model exporters. Report progress during the export. Also, handle the case where the user pauses or cancels an export. See PrSDKExportProgressSuite.h.</p>"},{"location":"exporters/suites/#export-standard-param-suite","title":"Export Standard Param Suite","text":"<p>New in CS6. A suite for registering one of several common parameter sets, reducing parameter management code on the plugin side.</p>"},{"location":"exporters/suites/#addstandardparams","title":"AddStandardParams","text":"<p>Register a set of standard parameters to be used by the exporter.</p> <p>Call during <code>exSelGenerateDefaultParams</code>.</p> <pre><code>prSuiteError (*AddStandardParams)(\n  csSDK_uint32       inExporterID,\n  PrSDKStdParamType  inSDKStdParamType);\n</code></pre> Parameter Description <code>inExporterID</code> Pass in <code>exporterPluginID</code> from <code>exDoExportRec</code>. <code>inSDKStdParamType</code> Use one of the following:<pre>enum PrSDKStdParamType {  SDKStdParams_Video,  SDKStdParams_Audio,  SDKStdParams_Still,  SDKStdParams_VideoBitrateGroup,  SDKStdParams_Video_NoRenderMax,  SDKStdParams_Video_AddRenderMax,  SDKStdParams_AudioTabOnly,  SDKStdParams_AudioBitrateGroup,  SDKStdParams_VideoWithSizePopup};</pre>"},{"location":"exporters/suites/#postprocessparamnames","title":"PostProcessParamNames","text":"<p>Call during <code>exSelPostProcessParams</code>.</p> <pre><code>prSuiteError (*PostProcessParamNames)(\n  csSDK_uint32        inExporterID,\n  PrAudioChannelType  inSourceAudioChannelType);\n</code></pre> Parameter Description <code>inExporterID</code> Pass in <code>exporterPluginID</code> from <code>exDoExportRec</code>. <code>inSourceAudioChannelType</code> Pass in the source audio channel type, which can be queried from GetExportSourceInfo in the Export Info Suite."},{"location":"exporters/suites/#queryoutputsettings","title":"QueryOutputSettings","text":"<p>Call during <code>exSelQueryOutputSettings</code>.</p> <pre><code>prSuiteError (*QueryOutputSettings)(\n  csSDK_uint32               inExporterID,\n  exQueryOutputSettingsRec*  outOutputSettings);\n</code></pre> Parameter Description <code>inExporterID</code> Pass in exporterPluginID from exDoExportRec. <code>outOutputSettings</code> This structure will be filled out based on the standard parameter settings."},{"location":"exporters/suites/#makeparamsummary","title":"MakeParamSummary","text":"<p>Call during <code>exSelGetParamSummary</code>.</p> <pre><code>prSuiteError (*MakeParamSummary)(\n  csSDK_uint32  inExporterID,\n  csSDK_int32   inDoVideo,\n  csSDK_int32   inDoAudio,\n  prUTF16Char*  outVideoDescription,\n  prUTF16Char*  outAudioDescription);\n</code></pre> Parameter Description <code>inExporterID</code> Pass in <code>exporterPluginID</code> from <code>exDoExportRec</code>. <code>inDoVideo</code> Pass in <code>exParamSummaryRec.exportVideo</code> / <code>exportAudio</code> so that the summary will be set based on whether video / audio are being exported. <code>inDoAudio</code> <code>outVideoDescription</code> These will be filled out based on the standard parameter settings. <code>outAudioDescription</code>"},{"location":"exporters/suites/#exporter-utility-suite","title":"Exporter Utility Suite","text":"<p>New in CS6. Provides functions for push-model exporters, and also provides a way to register an export event (error, warning, or info) to be displayed by the host and written to the log.</p>"},{"location":"exporters/suites/#domultipassexportloop","title":"DoMultiPassExportLoop","text":"<p>Register the callback to be made to push video frames to the exporter. This function assumes that your exporter supports <code>exSelQueryOutputSettings</code>, which will be called.</p> <pre><code>prSuiteError (*DoMultiPassExportLoop)(\n  csSDK_uint32                                     inExporterID,\n  const ExportLoopRenderParams*                    inRenderParams,\n  csSDK_uint32                                     inNumberOfPasses,\n  PrSDKMultipassExportLoopFrameCompletionFunction  inCompletionFunction,\n  void*                                            inCompletionParam);\n</code></pre> Parameter Description <code>inExporterID</code> Pass in <code>exporterPluginID</code> from <code>exDoExportRec</code>. <code>inRenderParams</code> Pass in the parameters that will be used for the render loop that will push rendered frames via the provided callback <code>inCompletionFunction</code>.<code>inReservedProgressPreRender</code> and <code>inReservedProgressPostRender</code> should be set to the amount of progress to be shown in any progress bar before starting the render loop, and how much is remaining after finishing the render loop.These values default to zero.<pre>typedef struct {  csSDK_int32    inRenderParamsSize;  csSDK_int32    inRenderParamsVersion;  PrPixelFormat  inFinalPixelFormat;  PrTime         inStartTime;  PrTime         inEndTime;  float          inReservedProgressPreRender;  float          inReservedProgressPostRender;  bool           inHardwareResidentFrameOutputSupported;  // new in 14.x} ExportLoopRenderParams;</pre> <code>inNumberOfPasses</code> Set to 1, unless you need multipass encoding such as two-pass or three-pass encoding. <code>inCompletionFunction</code> Provide your own callback here, which will be called when the host pushes rendered frames. Use the following function signature:<pre>typedef prSuiteError (*PrSDKMultipassExportLoop FrameCompletionFunction)(  csSDK_uint32  inWhichPass,  csSDK_uint32  inFrameNumber,  csSDK_uint32  inFrameRepeatCount,  PPixHand      inRenderedFrame,  void*         inCallbackData);</pre>Currently, there is no simple way to ensure that pushed frames survive longer than the life of the function call.If you are interested in this capability, please contact us and explain your need. <code>inCompletionParam</code> Pass in a void * to the data you wish to send to your <code>inCompletionFunction</code> above in <code>inCallbackData</code>."},{"location":"exporters/suites/#reportintermediateprogressforrepeatedvideoframe","title":"ReportIntermediateProgressForRepeatedVideoFrame","text":"<p>Register the callback to be made to push video frames to the exporter.</p> <p>This function assumes that your exporter supports <code>exSelQueryOutputSettings</code>, which will be called.</p> <pre><code>prSuiteError (*ReportIntermediateProgressForRepeatedVideoFrame)(\n  csSDK_uint32  inExporterID,\n  csSDK_uint32  inRepetitionsProcessedSinceLastUpdate);\n</code></pre> Parameter Description <code>inExporterID</code> Pass in <code>exporterPluginID</code> from <code>exDoExportRec</code>. <code>inRepetitionsProcessedSinceLastUpdate</code> Pass in the number of repeated frames processed since the last call was made, if any."},{"location":"exporters/suites/#reportevent","title":"ReportEvent","text":"<p>Report an event to the host, for a specific encode in progress in the Adobe Media Encoder render queue or Premiere Pro.</p> <p>These events are displayed in the application UI, and are also added to the AME encoding log.</p> <pre><code>prSuiteError (*ReportEvent)(\n  csSDK_uint32        inExporterID,\n  csSDK_uint32        inEventType,\n  const prUTF16Char*  inEventTitle,\n  const prUTF16Char*  inEventDescription);\n</code></pre> Parameter Description <code>inExporterID</code> Pass in <code>exporterPluginID</code> from <code>exDoExportRec</code>. <code>inEventType</code> Use one of the types from the Error Suite:<ul><li><code>kEventTypeInformational</code></li><li><code>kEventTypeWarning</code></li><li><code>kEventTypeError</code></li></ul> <code>inEventTitle</code> Provide information about the event for the user. <code>inEventDescription</code>"},{"location":"exporters/suites/#palette-suite","title":"Palette Suite","text":"<p>A seldom-used suite for palettizing an image, for example, for GIFs. See PrSDKPaletteSuite.h.</p>"},{"location":"exporters/suites/#sequence-audio-suite","title":"Sequence Audio Suite","text":"<p>Get audio from the host.</p>"},{"location":"exporters/suites/#makeaudiorenderer","title":"MakeAudioRenderer","text":"<p>Create an audio renderer, in preparation to get rendered audio from the host.</p> <pre><code>prSuiteError (*MakeAudioRenderer)(\n  csSDK_uint32        inPluginID,\n  PrTime              inStartTime,\n  PrAudioChannelType  inChannelType,\n  PrAudioSampleType   inSampleType,\n  float               inSampleRate,\n  csSDK_uint32*       outAudioRenderID);\n</code></pre> Parameter Description <code>inPluginID</code> Pass in <code>exporterPluginID</code> from <code>exDoExportRec</code>. <code>inStartTime</code> Start time for the audio requests. <code>inChannelType</code> <code>PrAudioChannelType</code> enum value for the channel type needed. <code>inSampleType</code> This should always be <code>kPrAudioSampleType_32BitFloat</code>. Other types are unsupported. <code>inSampleRate</code> Samples per second. <code>outAudioRenderID</code> This ID passed back is needed for subsequent calls to this suite."},{"location":"exporters/suites/#releaseaudiorenderer","title":"ReleaseAudioRenderer","text":"<p>Release the audio renderer when the exporter is done requesting audio.</p> <pre><code>prSuiteError (*ReleaseAudioRenderer)(\n  csSDK_uint32  inPluginID,\n  csSDK_uint32  inAudioRenderID);\n</code></pre> Parameter Description <code>inPluginID</code> Pass in <code>exporterPluginID</code> from <code>exDoExportRec</code>. <code>inAudioRenderID</code> The call will release the audio renderer with this ID."},{"location":"exporters/suites/#getaudio","title":"GetAudio","text":"<p>Returns from the host the next contiguous requested number of audio sample frames, specified in inFrameCount, in inBuffer as arrays of uninterleaved floating point values.</p> <p>Returns <code>suiteError_NoError</code> if no error.</p> <p>The plugin must manage the memory allocation of inBuffer, which must point to n buffers of floating point values of length inFrameCount, where n is the number of channels.</p> <p>When inClipAudio is non-zero, this parameter makes GetAudio clip the audio samples at +/- 1.0.</p> <pre><code>prSuiteError (*GetAudio)(\n  csSDK_uint32  inAudioRenderID,\n  csSDK_uint32  inFrameCount,\n  float**       inBuffer,\n  char          inClipAudio);\n</code></pre> Parameter Description <code>inAudioRenderID</code> Pass in the <code>outAudioRenderID</code> returned from <code>MakeAudioRenderer()</code>.This gives the host the context of the audio render. <code>inFrameCount</code> The number of audio frames to return in inBuffer.The next contiguous audio frames will always be returned, unless <code>ResetAudioToBeginning</code> has just been called. <code>inBuffer</code> An array of float arrays, allocated by the exporter.The host returns the samples for each audio channel in a separate array. <code>inClipAudio</code> When true, <code>GetAudio</code> will return audio clipped at +/- 1.0. Otherwise, it will return unclipped audio."},{"location":"exporters/suites/#resetaudiotobeginning","title":"ResetAudioToBeginning","text":"<p>This call will reset the position on the audio generation to time zero. This can be used for multipass encoding.</p> <pre><code>prSuiteError (*ResetAudioToBeginning)(\n  csSDK_uint32  inAudioRenderID);\n</code></pre>"},{"location":"exporters/suites/#getmaxblip","title":"GetMaxBlip","text":"<p>Returns the maximum number of audio sample frames that can be requested from one call to <code>GetAudio</code> in <code>maxBlipSize</code>.</p> <pre><code>prSuiteError (*GetMaxBlip)(\n  csSDK_uint32  inAudioRenderID,\n  PrTime        inTicksPerFrame,\n  csSDK_uint32*  maxBlipSize);\n</code></pre>"},{"location":"exporters/suites/#sequence-render-suite","title":"Sequence Render Suite","text":"<p>Get rendered video from one of the renderers available to the host. This may use one of the host's built-in renderers, or a plugin renderer, if available For best performance, use the asynchronous render requests with the source media prefetching calls, although synchronous rendering is available too.</p> <p>Version 4, new in CS5.5, adds <code>RenderVideoFrameAndConformToPixelFormat()</code>.</p>"},{"location":"exporters/suites/#makevideorenderer","title":"MakeVideoRenderer()","text":"<p>Create a video renderer, in preparation to get rendered video.</p> <pre><code>prSuiteError (*MakeVideoRenderer)(\n  csSDK_uint32   pluginID,\n  csSDK_uint32*  outVideoRenderID\n  PrTime         inFrameRate);\n</code></pre> Parameter Description <code>pluginID</code> Pass in <code>exporterPluginID</code> from <code>exDoExportRec</code>. <code>outVideoRenderID</code> This ID passed back is needed for subsequent calls to this suite. <code>inFrameRate</code> Frame rate, in ticks."},{"location":"exporters/suites/#releasevideorenderer","title":"ReleaseVideoRenderer()","text":"<p>Release the video renderer when the exporter is done requesting video.</p> <pre><code>prSuiteError (*ReleaseVideoRenderer)(\n  csSDK_uint32  pluginID,\n  csSDK_uint32  inVideoRenderID);\n</code></pre> Parameter Description <code>pluginID</code> Pass in <code>exporterPluginID</code> from <code>exDoExportRec</code>. <code>inVideoRenderID</code> The call will release the video renderer with this ID."},{"location":"exporters/suites/#struct-sequencerender_paramsrec","title":"struct SequenceRender_ParamsRec","text":"<p>Fill this structure in before calling <code>RenderVideoFrame()</code>, <code>QueueAsyncVideoFrameRender()</code>, or <code>PrefetchMediaWithRenderParameters()</code>.</p> <p>Note</p> <p>If the frame aspect ratio of the request does not match that of the sequence, the frame will be letterboxed or pillarboxed, rather than stretched to fit the frame.</p> <pre><code>typedef struct {\n  const PrPixelFormat*  inRequestedPixelFormatArray;\n  csSDK_int32           inRequestedPixelFormatArrayCount;\n  csSDK_int32           inWidth;\n  csSDK_int32           inHeight;\n  csSDK_int32           inPixelAspectRatioNumerator;\n  csSDK_int32           inPixelAspectRatioDenominator;\n  PrRenderQuality       inRenderQuality;\n  prFieldType           inFieldType;\n  csSDK_int32           inDeinterlace;\n  PrRenderQuality       inDeinterlaceQuality;\n  csSDK_int32           inCompositeOnBlack;\n} SequenceRender_ParamsRec;\n</code></pre> Member Description <code>inRequestedPixelFormatArray</code> An array of PrPixelFormats that list your format preferences in order. <code>inRequestedPixelFormatArrayCount</code> Size of the pixel format array. <code>inWidth</code> Width to render at. <code>inHeight</code> Height to render at. <code>inPixelAspectRatioNumerator</code> Numerator of the pixel aspect ratio. <code>inPixelAspectRatioDenominator</code> Denominator of the pixel aspect ratio. <code>inRenderQuality</code> Use one of the PrRenderQuality enumerated values. <code>inFieldType</code> Use one of the prFieldType constants. <code>inDeinterlace</code> Set to non-zero, to force an explicit deinterlace. Otherwise, the renderer will use the output field setting to determine whether to automatically deinterlace any interlaced sources. <code>inDeinterlaceQuality</code> Use one of the PrRenderQuality enumerated values. <code>inCompositeOnBlack</code> Set to non-zero, to composite the render on black."},{"location":"exporters/suites/#struct-sequencerender_paramsrecext","title":"struct SequenceRender_ParamsRecExt","text":"<p>Fill this structure in before calling <code>RenderVideoFrame()</code>, <code>QueueAsyncVideoFrameRender()</code>, or <code>PrefetchMediaWithRenderParameters()</code>.</p> <p>Note</p> <p>If the frame aspect ratio of the request does not match that of the sequence, the frame will be letterboxed or pillarboxed, rather than stretched to fit the frame.</p> <pre><code>typedef struct {\n  const PrPixelFormat*  inRequestedPixelFormatArray;\n  csSDK_int32           inRequestedPixelFormatArrayCount;\n  csSDK_int32           inWidth;\n  csSDK_int32           inHeight;\n  csSDK_int32           inPixelAspectRatioNumerator;\n  csSDK_int32           inPixelAspectRatioDenominator;\n  PrRenderQuality       inRenderQuality;\n  prFieldType           inFieldType;\n  csSDK_int32           inDeinterlace;\n  PrRenderQuality       inDeinterlaceQuality;\n  csSDK_int32           inCompositeOnBlack;\n  PrSDKColorSpaceID       inPrSDKColorSpaceID;\n} SequenceRender_ParamsRecExt;\n</code></pre> Member Description <code>inRequestedPixelFormatArray</code> An array of PrPixelFormats that list your format preferences in order. <code>inRequestedPixelFormatArrayCount</code> Size of the pixel format array. <code>inWidth</code> Width to render at. <code>inHeight</code> Height to render at. <code>inPixelAspectRatioNumerator</code> Numerator of the pixel aspect ratio. <code>inPixelAspectRatioDenominator</code> Denominator of the pixel aspect ratio. <code>inRenderQuality</code> Use one of the PrRenderQuality enumerated values. <code>inFieldType</code> Use one of the prFieldType constants. <code>inDeinterlace</code> Set to non-zero, to force an explicit deinterlace. Otherwise, the renderer will use the output field setting to determine whether to automatically deinterlace any interlaced sources. <code>inDeinterlaceQuality</code> Use one of the PrRenderQuality enumerated values. <code>inCompositeOnBlack</code> Set to non-zero, to composite the render on black. <code>inPrSDKColorSpaceID</code> Identifies the color space being used."},{"location":"exporters/suites/#struct-sequencerender_paramsrecext2","title":"struct SequenceRender_ParamsRecExt2","text":"<p>Fill this structure in before calling <code>RenderVideoFrame()</code>, <code>QueueAsyncVideoFrameRender()</code>, or <code>PrefetchMediaWithRenderParameters()</code>.</p> <p>Note</p> <p>If the frame aspect ratio of the request does not match that of the sequence, the frame will be letterboxed or pillarboxed, rather than stretched to fit the frame.</p> <pre><code>typedef struct {\n  const PrPixelFormat*  inRequestedPixelFormatArray;\n  csSDK_int32           inRequestedPixelFormatArrayCount;\n  csSDK_int32           inWidth;\n  csSDK_int32           inHeight;\n  csSDK_int32           inPixelAspectRatioNumerator;\n  csSDK_int32           inPixelAspectRatioDenominator;\n  PrRenderQuality       inRenderQuality;\n  prFieldType           inFieldType;\n  csSDK_int32           inDeinterlace;\n  PrRenderQuality       inDeinterlaceQuality;\n  csSDK_int32           inCompositeOnBlack;\n  PrSDKColorSpaceID       inPrSDKColorSpaceID;\n      PrSDKLUTID                      inPrSDKLUTID;                   // Added to support export LUT\n} SequenceRender_ParamsRecExt2;\n</code></pre> Member Description <code>inRequestedPixelFormatArray</code> An array of PrPixelFormats that list your format preferences in order. <code>inRequestedPixelFormatArrayCount</code> Size of the pixel format array. <code>inWidth</code> Width to render at. <code>inHeight</code> Height to render at. <code>inPixelAspectRatioNumerator</code> Numerator of the pixel aspect ratio. <code>inPixelAspectRatioDenominator</code> Denominator of the pixel aspect ratio. <code>inRenderQuality</code> Use one of the PrRenderQuality enumerated values. <code>inFieldType</code> Use one of the prFieldType constants. <code>inDeinterlace</code> Set to non-zero, to force an explicit deinterlace. Otherwise, the renderer will use the output field setting to determine whether to automatically deinterlace any interlaced sources. <code>inDeinterlaceQuality</code> Use one of the PrRenderQuality enumerated values. <code>inCompositeOnBlack</code> Set to non-zero, to composite the render on black. <code>inPrSDKColorSpaceID</code> New in 13.0. Identifies the color space being used. <code>inPrSDKLUTID</code> New in 14.4. Identifies the color space being used."},{"location":"exporters/suites/#struct-sequencerender_getframereturnrec","title":"struct SequenceRender_GetFrameReturnRec","text":"<p>Returned from <code>RenderVideoFrame()</code> and passed by <code>PrSDKSequenceAsyncRenderCompletionProc()</code>.</p> <pre><code>typedef struct {\n  void*        asyncCompletionData;\n  csSDK_int32  returnVal;\n  csSDK_int32  repeatCount;\n  csSDK_int32  onMarker;\n  PPixHand     outFrame;\n} SequenceRender_GetFrameReturnRec;\n</code></pre> Member Description <code>asyncCompletionData</code> Passed to <code>PrSDKSequenceAsyncRenderCompletionProc()</code> from <code>QueueAsyncVideoFrameRender()</code>.Not used by <code>RenderVideoFrame()</code>. <code>returnVal</code> <code>ErrNone</code>, <code>Abort</code>, <code>Done</code>, or an error code. <code>repeatCount</code> The number of repeated frames from this frame forward.In the output file, this could be writing NULL frames, changing the current frame's duration, or whatever is appropriate according to the codec. <code>onMarker</code> If non-zero, there is a marker on this frame. <code>outFrame</code> Returned from <code>RenderVideoFrame()</code>. Not returned from <code>PrSDKSequenceAsyncRenderCompletionProc()</code>"},{"location":"exporters/suites/#rendervideoframe","title":"RenderVideoFrame()","text":"<p>The basic, synchronous call to get a rendered frame from the host.</p> <p>Returns:</p> <ul> <li><code>suiteError_NoError</code> if you can continue exporting,</li> <li><code>exportReturn_Abort</code> if the user aborted the export,</li> <li><code>exportReturn_Done</code> if the export has finished, or</li> <li>an error code.</li> </ul> <pre><code>prSuiteError (*RenderVideoFrame)(\n  csSDK_uint32                       inVideoRenderID,\n  PrTime                             inTime,\n  SequenceRender_ParamsRec*          inRenderParams,\n  PrRenderCacheType                  inCacheFlags,\n  SequenceRender_GetFrameReturnRec*  getFrameReturn);\n</code></pre> Parameter Description <code>inVideoRenderID</code> Pass in the <code>outVideoRenderID</code> returned from <code>MakeVideoRenderer()</code>.This gives the host the context of the video render. <code>inTime</code> The frame time requested. <code>inRenderParams</code> The details of the render. <code>inCacheFlags</code> One or more cache flags. <code>getFrameReturn</code> Passes back a structure that contains info about the frame returned, and the rendered frame itself."},{"location":"exporters/suites/#getframeinfo","title":"GetFrameInfo()","text":"<p>Gets information about a given frame.</p> <p>Currently, <code>SequenceRender_FrameInfoRec</code> only contains <code>repeatCount</code>, which is the number of repeated frames from this frame forward.</p> <pre><code>prSuiteError (*GetFrameInfo)(\n  csSDK_uint32                 inVideoRenderID,\n  PrTime                       inTime,\n  SequenceRender_FrameInfoRec*  outFrameInfo);\n</code></pre>"},{"location":"exporters/suites/#setasyncrendercompletionproc","title":"SetAsyncRenderCompletionProc()","text":"<p>Register a notification callback for getting asynchronously rendered frames when the render completes.</p> <p><code>asyncGetFrameCallback</code> should have the signature described in <code>PrSDKSequenceAsyncRenderCompletionProc</code> below.</p> <pre><code>prSuiteError (*SetAsyncRenderCompletionProc)(\n  csSDK_uint32                            inVideoRenderID,\n  PrSDKSequenceAsyncRenderCompletionProc  asyncGetFrameCallback,\n  long                                    callbackRef);\n</code></pre> Parameter Description <code>inVideoRenderID</code> Pass in the <code>outVideoRenderID</code> returned from <code>MakeVideoRenderer()</code>.This will be passed to <code>PrSDKSequenceAsyncRenderCompletionProc</code>. <code>asyncGetFrameCallback</code> The notification callback. <code>inCallbackRef</code> A pointer holding data private to the exporter.This could be, for example, a pointer to an exporter instance. This will also be passed to <code>PrSDKSequenceAsyncRenderCompletionProc</code>."},{"location":"exporters/suites/#prsdksequenceasyncrendercompletionproc","title":"PrSDKSequenceAsyncRenderCompletionProc()","text":"<p>Use this function signature for your callback used for async frame notification, passed to <code>SetAsyncRenderCompletionProc</code>.</p> <p>Error status (error or abort) is returned in <code>inGetFrameReturn</code>.</p> <pre><code>void (*PrSDKSequenceAsyncRenderCompletionProc)(\n  csSDK_uint32                      inVideoRenderID,\n  void*                              inCallbackRef,\n  PrTime                            inTime,\n  PPixHand                          inRenderedFrame,\n  SequenceRender_GetFrameReturnRec  *inGetFrameReturn);\n</code></pre> Parameter Description <code>inVideoRenderID</code> The outVideoRenderID that the exporter passed to <code>SetAsyncRenderCompletionProc</code> earlier. <code>inCallbackRef</code> A pointer that the exporter sets using <code>SetAsyncRenderCompletionProc()</code>.This could be, for example, a pointer to an exporter instance. <code>inTime</code> The frame time requested. <code>inRenderedFrame</code> The rendered frame. The exporter is reponsible for <code>disposing</code> of this PPixHand using the <code>Dispose()</code> call in the PPix Suite. <code>inGetFrameReturn</code> A structure that contains info about the frame returned, and it includes the <code>inAsyncCompletionData</code> originally passed to <code>QueueAsyncVideoFrameRender()</code>."},{"location":"exporters/suites/#queueasyncvideoframerender","title":"QueueAsyncVideoFrameRender()","text":"<p>Use this call rather than <code>RenderVideoFrame()</code> to queue up a request to render a specific frame asynchronously.</p> <p>The rendering can happen on a separate thread or processor.</p> <p>When the render is completed, the <code>PrSDKSequenceAsyncRenderCompletionProc</code> that was set using <code>SetAsyncRenderCompletionProc</code> will be called.</p> <pre><code>prSuiteError (*QueueAsyncVideoFrameRender)(\n  csSDK_uint32               inVideoRenderID,\n  PrTime                     inTime,\n  csSDK_uint32*              outRequestID,\n  SequenceRender_ParamsRec*  inRenderParams,\n  PrRenderCacheType          inCacheFlags,\n  void*                      inAsyncCompletionData);\n</code></pre> Parameter Description <code>inVideoRenderID</code> Pass in the <code>outVideoRenderID</code> returned from <code>MakeVideoRenderer()</code>.This gives the host the context of the video render. <code>inTime</code> The frame time requested. <code>outRequestID</code> Passes back a request ID, which\u2026 doesn't seem to have any use. <code>inRenderParams</code> The details of the render. <code>inCacheFlags</code> One or more cache flags. <code>inAsyncCompletionData</code> This data will be passed to the <code>PrSDKSequenceAsyncRenderCompletionProc</code> in <code>inGetFrameReturn.asyncCompletionData</code>."},{"location":"exporters/suites/#prefetchmedia","title":"PrefetchMedia()","text":"<p>Prefetch the media needed to render this frame. This is a hint to the importers to begin reading media needed to render this video frame.</p> <pre><code>prSuiteError (*PrefetchMedia)(\n  csSDK_uint32  inVideoRenderID,\n  PrTime        inFrame);\n</code></pre>"},{"location":"exporters/suites/#prefetchmediawithrenderparameters","title":"PrefetchMediaWithRenderParameters()","text":"<p>Prefetch the media needed to render this frame, using all of the parameters used to render the frame.</p> <p>This is a hint to the importers to begin reading media needed to render this video frame.</p> <pre><code>prSuiteError (*PrefetchMediaWithRenderParameters)(\n  csSDK_uint32               inVideoRenderID,\n  PrTime                     inTime,\n  SequenceRender_ParamsRec*  inRenderParams);\n</code></pre>"},{"location":"exporters/suites/#cancelalloutstandingmediaprefetches","title":"CancelAllOutstandingMediaPrefetches()","text":"<p>Cancel all media prefetches that are still outstanding.</p> <pre><code>prSuiteError (*PrefetchMedia)(\n  csSDK_uint32  inVideoRenderID);\n</code></pre>"},{"location":"exporters/suites/#isprefetchedmediaready","title":"IsPrefetchedMediaReady()","text":"<p>Check on the status of a prefetch request.</p> <pre><code>prSuiteError (*IsPrefetchedMediaReady)(\n  csSDK_uint32  inVideoRenderID,\n  PrTime        inTime,\n  prBool*       outMediaReady);\n</code></pre>"},{"location":"exporters/suites/#makevideorendererfortimeline","title":"MakeVideoRendererForTimeline()","text":"<p>Similar to MakeVideoRenderer, but for use by renderer plugins.</p> <p>Creates a video renderer, in preparation to get rendered video from the host.</p> <p>The <code>TimelineID</code> in question must refer to a top-level sequence.</p> <pre><code>prSuiteError (*MakeVideoRendererForTimeline)(\n  PrTimelineID   inTimeline,\n  csSDK_uint32*  outVideoRendererID);\n</code></pre>"},{"location":"exporters/suites/#makevideorendererfortimelinewithframerate","title":"MakeVideoRendererForTimelineWithFrameRate()","text":"<p>Similar to MakeVideoRendererForTimeline, with an additional frame rate parameter.</p> <p>This is useful for the case of a nested multicam sequence.</p> <pre><code>prSuiteError (*MakeVideoRendererForTimelineWithFrameRate)(\n  PrTimelineID   inTimeline,\n  PrTime         inFrameRate,\n  csSDK_uint32*  outVideoRendererID);\n</code></pre>"},{"location":"exporters/suites/#releasevideorendererfortimeline","title":"ReleaseVideoRendererForTimeline()","text":"<p>Similar to ReleaseVideoRenderer, but for use by renderer plugins. Release the video renderer when the renderer plugin is done requesting video.</p> <pre><code>prSuiteError (*ReleaseVideoRendererForTimeline)(\n  csSDK_uint32  inVideoRendererID);\n</code></pre>"},{"location":"exporters/suites/#rendervideoframeandconformtopixelformat","title":"RenderVideoFrameAndConformToPixelFormat()","text":"<p>New in CS5.5. Similar to RenderVideoFrame., but conforms the resulting frame to a specific pixel format.</p> <p>Allows an exporter to request a frame in a specific pixel format.</p> <pre><code>prSuiteError (*RenderVideoFrameAndConformToPixelFormat)(\n  csSDK_uint32                       inVideoRenderID,\n  PrTime                             inTime,\n  SequenceRender_ParamsRec*          inRenderParams,\n  PrRenderCacheType                  inCacheFlags,\n  PrPixelFormat                      inConformToFormat,\n  SequenceRender_GetFrameReturnRec*  getFrameReturn);\n</code></pre>"},{"location":"exporters/suites/#makevideorendererfortimelinewithstreamlabel","title":"MakeVideoRendererForTimelineWithStreamLabel()","text":"<p>New in CS6. Similar to <code>MakeVideoRenderer</code>, but is stream label-aware.</p> <p>Allows an exporter to request rendered frames from multiple video streams.</p> <pre><code>prSuiteError (*MakeVideoRendererForTimelineWithStreamLabel)(\n  PrTimelineID      inTimeline,\n  PrSDKStreamLabel  inStreamLabel,\n  csSDK_uint32*     outVideoRendererID);\n</code></pre>"},{"location":"exporters/suites/#rendercolormanagedvideoframe","title":"RenderColorManagedVideoFrame()","text":"<p>Renders a frame of video, using the specified color management.</p> <pre><code>prSuiteError (*RenderColorManagedVideoFrame)(\n        csSDK_uint32                                    inVideoRenderID,\n        PrTime                                                  inTime,\n        SequenceRender_ParamsRecExt*    inRenderParamsExt,\n        PrRenderCacheType                               inCacheFlags,\n        SequenceRender_GetFrameReturnRec*       getFrameReturn);\n</code></pre>"},{"location":"exporters/suites/#queueasynccolormanagedvideoframerender","title":"QueueAsyncColorManagedVideoFrameRender()","text":"<p>Queues a render for a frame of video, using the specified color management.</p> <pre><code>prSuiteError (*QueueAsyncColorManagedVideoFrameRender)(\n        csSDK_uint32                                    inVideoRenderID,\n        PrTime                                                  inTime,\n        csSDK_uint32*                                   outRequestID,\n        SequenceRender_ParamsRecExt*    inRenderParamsExt,\n        PrRenderCacheType                               inCacheFlags,\n        void*                                                   inAsyncCompletionData);\n</code></pre>"},{"location":"exporters/suites/#prefetchcolormanagedmedia","title":"PrefetchColorManagedMedia()","text":"<p>Pre-fetches a frame of color-managed media.</p> <pre><code>prSuiteError (*PrefetchColorManagedMedia)(\n        csSDK_uint32            inVideoRenderID,\n        PrTime                          inFrame,\n        PrSDKColorSpaceID inPrSDKColorSpaceID);\n</code></pre>"},{"location":"exporters/suites/#prefetchcolormanagedmediawithrenderparameters","title":"PrefetchColorManagedMediaWithRenderParameters()","text":"<p>Pre-fetches a frame of color-managed media, using the specified render parameters.</p> <pre><code>prSuiteError (*PrefetchColorManagedMediaWithRenderParameters)(\n        csSDK_uint32                                    inVideoRenderID,\n        PrTime                                                  inTime,\n        SequenceRender_ParamsRecExt*    inRenderParamsExt);\n</code></pre>"},{"location":"exporters/suites/#rendercolormanagedvideoframeandconformtopixelformat","title":"RenderColorManagedVideoFrameAndConformToPixelFormat()","text":"<p>Renders a frame of color-managed media, to the specified pixel format.</p> <pre><code>prSuiteError (*RenderColorManagedVideoFrameAndConformToPixelFormat)(\n        csSDK_uint32                                    inVideoRenderID,\n        PrTime                                                  inTime,\n        SequenceRender_ParamsRecExt*    inRenderParamsExt,\n        PrRenderCacheType                               inCacheFlags,\n        PrPixelFormat                                   inConformToFormat,\n        SequenceRender_GetFrameReturnRec*       getFrameReturn);\n</code></pre>"},{"location":"exporters/suites/#rendercolormanagedvideoframe2","title":"RenderColorManagedVideoFrame2()","text":"<p>Renders a frame of color-managed media, to the specified pixel format, using settings specified in SequenceRender_ParamsRecExt2.</p> <pre><code>prSuiteError (*RenderColorManagedVideoFrame2)(\n        csSDK_uint32                    inVideoRenderID,\n        PrTime                          inTime,\n        SequenceRender_ParamsRecExt2*   inRenderParamsExt2,\n        PrRenderCacheType               inCacheFlags,\n        SequenceRender_GetFrameReturnRec*   outGetFrameReturn);\n</code></pre>"},{"location":"exporters/suites/#queueasynccolormanagedvideoframerender2","title":"QueueAsyncColorManagedVideoFrameRender2()","text":"<p>Queues a request for a frame of color-managed media, to the specified pixel format, using settings specified in SequenceRender_ParamsRecExt2.</p> <pre><code>prSuiteError (*QueueAsyncColorManagedVideoFrameRender2)(\n        csSDK_uint32                    inVideoRenderID,\n        PrTime                          inTime,\n        csSDK_uint32*                   outRequestID,\n        SequenceRender_ParamsRecExt2*   inRenderParamsExt2,\n        PrRenderCacheType               inCacheFlags,\n        void*                           inAsyncCompletionData);\n</code></pre>"},{"location":"exporters/suites/#prefetchcolormanagedmediawithrenderparameters2","title":"PrefetchColorManagedMediaWithRenderParameters2()","text":"<p>Pre-fetches a request for a frame of color-managed media, to the specified pixel format, using settings specified in SequenceRender_ParamsRecExt2.</p> <pre><code>prSuiteError(*PrefetchColorManagedMediaWithRenderParameters2)(\n        csSDK_uint32                    inVideoRenderID,\n        PrTime                          inTime,\n        SequenceRender_ParamsRecExt2*   inRenderParamsExt2);\n</code></pre>"},{"location":"exporters/suites/#rendercolormanagedvideoframeandconformtopixelformat2","title":"RenderColorManagedVideoFrameAndConformToPixelFormat2()","text":"<p>Renders a frame of color-managed media, to the specified pixel format, using settings specified in SequenceRender_ParamsRecExt2.</p> <pre><code>prSuiteError (*RenderColorManagedVideoFrameAndConformToPixelFormat2)(\n        csSDK_uint32                    inVideoRenderID,\n        PrTime                          inTime,\n        SequenceRender_ParamsRecExt2*   inRenderParamsExt2,\n        PrRenderCacheType               inCacheFlags,\n        PrPixelFormat                   inConformToFormat,\n        SequenceRender_GetFrameReturnRec*   outGetFrameReturn);\n</code></pre>"},{"location":"exporters/suites/#pf-utility-suite","title":"PF Utility Suite","text":"<p>Utility functions for use by AE style effect plugins, running in Premiere Pro.</p> <p>Version 11, new in 15.0, adds GetVideoResolutionString.</p>"},{"location":"exporters/suites/#getfilterinstanceid","title":"GetFilterInstanceID()","text":"<p>Gets the filter ID for the current effect reference.</p> <pre><code>prSuiteError(*GetFilterInstanceID)(\n  PF_ProgPtr    effect_ref,\n  A_long*       outFilterInstanceID);\n</code></pre>"},{"location":"exporters/suites/#getmediatimecode","title":"GetMediaTimecode()","text":"<p>Retrieves formatted timecode, as well as the currently active video frame.</p> <pre><code>prSuiteError(*GetMediaTimecode)(\n  PF_ProgPtr      effect_ref,\n  A_long*         outCurrentFrame,\n  PF_TimeDisplay* outTimeDisplay);\n</code></pre>"},{"location":"exporters/suites/#getclipspeed","title":"GetClipSpeed()","text":"<p>Retrieves the speed multiplier of the clip.</p> <pre><code>prSuiteError(*GetClipSpeed)(\n              PF_ProgPtr effect_ref,\n              double* speed);\n</code></pre>"},{"location":"exporters/suites/#getclipduration","title":"GetClipDuration()","text":"<p>Retrieves the duration of the clip.</p> <pre><code>prSuiteError(*GetClipDuration)(\n              PF_ProgPtr effect_ref,\n              A_long* frameDuration);\n</code></pre>"},{"location":"exporters/suites/#getclipstart","title":"GetClipStart()","text":"<p>Retrieves the start time of the clip.</p> <pre><code>prSuiteError(*GetClipStart)(\n        PF_ProgPtr effect_ref,\n        A_long* frameDuration);\n</code></pre>"},{"location":"exporters/suites/#getunscaledclipduration","title":"GetUnscaledClipDuration()","text":"<p>Retrieves the duration of the clip, unaffected by any speed or retiming changes.</p> <pre><code>prSuiteError(*GetUnscaledClipDuration)(\n              PF_ProgPtr effect_ref,\n              A_long* frameDuration);\n</code></pre>"},{"location":"exporters/suites/#getunscaledclipstart","title":"GetUnscaledClipStart()","text":"<p>Retrives the start time of the clip, unaffected by any speed or retiming changes.</p> <pre><code>prSuiteError(*GetUnscaledClipStart)(\n              PF_ProgPtr effect_ref,\n              A_long* frameDuration);\n</code></pre>"},{"location":"exporters/suites/#gettrackitemstart","title":"GetTrackItemStart()","text":"<p>Gets the start time of the track item.</p> <pre><code>prSuiteError(*GetTrackItemStart)(\n              PF_ProgPtr    effect_ref,\n              A_long*       frameDuration);\n</code></pre>"},{"location":"exporters/suites/#getmediafieldtype","title":"GetMediaFieldType()","text":"<p>Retrieves the filed type in use with the media.</p> <pre><code>prSuiteError(*GetMediaFieldType)(\n              PF_ProgPtr    effect_ref,\n              prFieldType*  outFieldType); // prFieldsNone, prFieldsUpperFirst, prFieldsLowerFirst, prFieldsUnknown\n</code></pre>"},{"location":"exporters/suites/#getmediaframerate","title":"GetMediaFrameRate()","text":"<p>Gets the number of ticks per frame, for the media.</p> <pre><code>prSuiteError(*GetMediaFrameRate)(\n  PF_ProgPtr  effect_ref,\n  PrTime*     outTicksPerFrame);\n</code></pre>"},{"location":"exporters/suites/#getcontainingtimelineid","title":"GetContainingTimelineID()","text":"<p>Gets the ID of the timeline containing the clip to which the effect is applied.</p> <pre><code>prSuiteError(*GetContainingTimelineID)(\n              PF_ProgPtr    effect_ref,\n              PrTimelineID* outTimelineID);\n</code></pre>"},{"location":"exporters/suites/#getclipname","title":"GetClipName()","text":"<p>Gets the name of the clip to which the effect is applied (or the master clip).</p> <pre><code>prSuiteError(*GetClipName)(\n              PF_ProgPtr    effect_ref,\n              A_Boolean     inGetMasterClipName,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#effectwantscheckedoutframestomatchrenderpixelformat","title":"EffectWantsCheckedOutFramesToMatchRenderPixelFormat()","text":"<p>Indicates that the effect wants to received checked out frames, in the same format used for destination rendering.</p> <pre><code>prSuiteError(*EffectWantsCheckedOutFramesToMatchRenderPixelFormat)(\n        PF_ProgPtr  effect_ref);\n</code></pre>"},{"location":"exporters/suites/#effectdependsonclipname","title":"EffectDependsOnClipName()","text":"<p>Indicates (based on second parameter) whether the effect depends on the name of the clip to which it is applied.</p> <pre><code>prSuiteError(*EffectDependsOnClipName)(\n              PF_ProgPtr    effect_ref,\n              A_Boolean     inDependsOnClipName);\n</code></pre>"},{"location":"exporters/suites/#seteffectinstancename","title":"SetEffectInstanceName()","text":"<pre><code>prSuiteError(*SetEffectInstanceName)(\n              PF_ProgPtr effect_ref,\n              const PrSDKString* inSDKString);\n</code></pre>"},{"location":"exporters/suites/#getfilename","title":"GetFileName()","text":"<p>Retrieves the name of the media file to which the effect instance is applied.</p> <pre><code>prSuiteError(*GetFileName)(\n              PF_ProgPtr      effect_ref,\n              PrSDKString*    outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getoriginalclipframerate","title":"GetOriginalClipFrameRate()","text":"<p>Retrieves the original (non-interpreted, un-re-timed) frame rate, of the media to which the effect instance is applied.</p> <pre><code>prSuiteError(*GetOriginalClipFrameRate)(\n              PF_ProgPtr    effect_ref,\n              PrTime*       outTicksPerFrame);\n</code></pre>"},{"location":"exporters/suites/#getsourcetrackmediatimecode","title":"GetSourceTrackMediaTimecode()","text":"<p>Retrieves the source media timecode for the specified frame within the specified layer, with or without transforms and start time offsets applied.</p> <pre><code>prSuiteError(*GetSourceTrackMediaTimecode)(\n              PF_ProgPtr      effect_ref,\n              csSDK_uint32    inLayerParamIndex,\n              bool            inApplyTransform,\n              bool            inAddStartTimeOffset,\n              A_long*         outCurrentFrame);\n</code></pre>"},{"location":"exporters/suites/#getsourcetrackclipname","title":"GetSourceTrackClipName()","text":"<p>Retrieves the name of the layer in use by the effect instance.</p> <pre><code>prSuiteError(*GetSourceTrackClipName)(\n              PF_ProgPtr      effect_ref,\n              csSDK_uint32    inLayerParamIndex,\n              A_Boolean       inGetMasterClipName,\n              PrSDKString*    outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getsourcetrackfilename","title":"GetSourceTrackFileName()","text":"<p>Retrieves the file name of the source track item for the specified layer parameter.</p> <pre><code>prSuiteError(*GetSourceTrackFileName)(\n              PF_ProgPtr      effect_ref,\n              csSDK_uint32    inLayerParamIndex,\n              PrSDKString*    outSDKString);\n</code></pre>"},{"location":"exporters/suites/#effectdependsonclipname2","title":"EffectDependsOnClipName2()","text":"<p>Specifies whether the effect instance depends on the specified layer parameter.</p> <pre><code>prSuiteError(*EffectDependsOnClipName2)(\n              PF_ProgPtr    effect_ref,\n              A_Boolean     inDependsOnClipName,\n              csSDK_uint32  inLayerParamIndex);\n</code></pre>"},{"location":"exporters/suites/#getmediatimecode2","title":"GetMediaTimecode2()","text":"<p>Retrieves formatted timecode and current frame number, with or without trims applied.</p> <pre><code>prSuiteError(*GetMediaTimecode2)(\n              PF_ProgPtr      effect_ref,\n              bool            inApplyTrim,\n              A_long*         outCurrentFrame,\n              PF_TimeDisplay* outTimeDisplay);\n</code></pre>"},{"location":"exporters/suites/#getsourcetrackmediatimecode2","title":"GetSourceTrackMediaTimecode2()","text":"<p>Given a specific sequence time, retrieves the source track media timecode for the specified layer parameter.</p> <pre><code>prSuiteError(*GetSourceTrackMediaTimecode2)(\n              PF_ProgPtr      effect_ref,\n              csSDK_uint32    inLayerParamIndex,\n              bool            inApplyTransform,\n              bool            inAddStartTimeOffset,\n              PrTime          inSequenceTime,\n              A_long*         outCurrentFrame);\n</code></pre>"},{"location":"exporters/suites/#getsourcetrackclipname2","title":"GetSourceTrackClipName2()","text":"<p>Retrieves the clip name used by the specific layer parameter.</p> <pre><code>prSuiteError(*GetSourceTrackClipName2)(\n              PF_ProgPtr      effect_ref,\n              csSDK_uint32    inLayerParamIndex,\n              A_Boolean       inGetMasterClipName,\n              PrSDKString*    outSDKString,\n              PrTime          inSequenceTime);\n</code></pre>"},{"location":"exporters/suites/#getsourcetrackfilename2","title":"GetSourceTrackFileName2()","text":"<p>Retreives the clip name in use by the specified layer parameter.</p> <pre><code>prSuiteError(*GetSourceTrackFileName2)(\n              PF_ProgPtr    effect_ref,\n              csSDK_uint32  inLayerParamIndex,\n              PrSDKString*  outSDKString,\n              PrTime        inSequenceTime);\n</code></pre>"},{"location":"exporters/suites/#getcommentstring","title":"GetCommentString()","text":"<p>Retrieves the comment string associated with the specified source track item, at the specified time.</p> <pre><code>prSuiteError(*GetCommentString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getlognotestring","title":"GetLogNoteString()","text":"<p>Retrieves the log note associated with the source track, at the specified time.</p> <pre><code>prSuiteError(*GetLogNoteString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getcamerarollstring","title":"GetCameraRollString()","text":"<p>Retrieves the log note associated with the source track, at the specified time.</p> <pre><code>prSuiteError(*GetCameraRollString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getclientmetadatastring","title":"GetClientMetadataString()","text":"<p>Retrieves the metadata string associated with the source track, at the specified time.</p> <pre><code>prSuiteError(*GetClientMetadataString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getdailyrollstring","title":"GetDailyRollString()","text":"<p>Retrieves the daily roll string associated with the source track, at the specified time.</p> <pre><code>prSuiteError(*GetDailyRollString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getdescriptionstring","title":"GetDescriptionString()","text":"<p>Retrieves the daily roll string associated with the source track, at the specified time.</p> <pre><code>prSuiteError(*GetDescriptionString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getlabrollstring","title":"GetLabRollString()","text":"<p>Retrieves the lab roll string associated with the source track, at the specified time.</p> <pre><code>prSuiteError(*GetLabRollString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getscenestring","title":"GetSceneString()","text":"<p>Retrieves the scene string associated with the source track, at the specified time.</p> <pre><code>prSuiteError(*GetSceneString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getshotstring","title":"GetShotString()","text":"<p>Retrieves the shot string associated with the source track item, at the specified time.</p> <pre><code>prSuiteError(*GetShotString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#gettapenamestring","title":"GetTapeNameString()","text":"<p>Retrieves the tape name string associated with the source track item, at the specified time.</p> <pre><code>prSuiteError(*GetTapeNameString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getvideocodecstring","title":"GetVideoCodecString()","text":"<p>Retrieves a string representing the video codec associated with the source track item, at the specified time.</p> <pre><code>prSuiteError(*GetVideoCodecString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getgoodmetadatastring","title":"GetGoodMetadataString()","text":"<p>Retrieves a string representing the \"good\" state of the source track item, at the specified time.</p> <pre><code>prSuiteError(*GetGoodMetadataString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getsoundrollstring","title":"GetSoundRollString()","text":"<p>Retrieves a string representing the \"sound roll\" state of the source track item, at the specified time.</p> <pre><code>prSuiteError(*GetSoundRollString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/suites/#getsequencetime","title":"GetSequenceTime()","text":"<p>Retrieves the timebase of the sequence in which the effect is applied.</p> <pre><code>prSuiteError(*GetSequenceTime)(\n              PF_ProgPtr  inEffectRef,\n              PrTime*     outSequenceTime);\n</code></pre>"},{"location":"exporters/suites/#getsoundtimecode","title":"GetSoundTimecode()","text":"<p>Retrieves the frame of the specified source time.</p> <pre><code>prSuiteError(*GetSoundTimecode)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              A_long*       outCurrentFrame);\n</code></pre>"},{"location":"exporters/suites/#getoriginalclipframerateforsourcetrack","title":"GetOriginalClipFrameRateForSourceTrack()","text":"<p>Retrieves the original \"ticks per frame\" for the specified source track.</p> <pre><code>prSuiteError(*GetOriginalClipFrameRateForSourceTrack)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime*       outTicksPerFrame);\n</code></pre>"},{"location":"exporters/suites/#getmediaframerateforsourcetrack","title":"GetMediaFrameRateForSourceTrack()","text":"<p>Retrieves the media frame rate for the specified source track.</p> <pre><code>prSuiteError(*GetMediaFrameRateForSourceTrack)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrTime*       outTicksPerFrame);\n</code></pre>"},{"location":"exporters/suites/#getsourcetrackmediaactualstarttime","title":"GetSourceTrackMediaActualStartTime()","text":"<p>Retrieves the start time of the specified layer parameter.</p> <pre><code>prSuiteError(*GetSourceTrackMediaActualStartTime)(\n              PF_ProgPtr      inEffectRef,\n              csSDK_uint32    inLayerParamIndex,\n              PrTime          inSequenceTime,\n              PrTime*         outClipActualStartTime);\n</code></pre>"},{"location":"exporters/suites/#issourcetrackmediatrimmed","title":"IsSourceTrackMediaTrimmed()","text":"<p>Retrieves whether the source track item has been trimmed.</p> <pre><code>prSuiteError(*IsSourceTrackMediaTrimmed)(\n              PF_ProgPtr      inEffectRef,\n              csSDK_uint32    inLayerParamIndex,\n              PrTime          inSequenceTime,\n              bool*           outTrimApplied);\n</code></pre>"},{"location":"exporters/suites/#ismediatrimmed","title":"IsMediaTrimmed()","text":"<p>Retrieves whether the track item has been trimmed.</p> <pre><code>prSuiteError(*IsMediaTrimmed)(\n              PF_ProgPtr    inEffectRef,\n              PrTime        inSequenceTime,\n              bool*         outTrimApplied);\n</code></pre>"},{"location":"exporters/suites/#istrackempty","title":"IsTrackEmpty()","text":"<p>Retrieves whether, for the specified layer parameter, the track is empty.</p> <pre><code>prSuiteError(*IsTrackEmpty)(\n              PF_ProgPtr      inEffectRef,\n              csSDK_uint32    inLayerParamIndex,\n              PrTime          inSequenceTime,\n              bool*           outIsTrackEmpty);\n</code></pre>"},{"location":"exporters/suites/#istrackitemeffectappliedtosynthetic","title":"IsTrackItemEffectAppliedToSynthetic()","text":"<p>Retrieves whether the effect is applied to a track item backed by a synthetic importer.</p> <pre><code>prSuiteError(*IsTrackItemEffectAppliedToSynthetic)(\n              PF_ProgPtr    inEffectRef,\n              bool*         outIsTrackItemEffectAppliedToSynthetic);\n</code></pre>"},{"location":"exporters/suites/#getsourcetrackcurrentmediatimeinfo","title":"GetSourceTrackCurrentMediaTimeInfo()","text":"<p>Retrieves the current media time, including ticks per frame and a formatted string representing that time.</p> <pre><code>prSuiteError(*GetSourceTrackCurrentMediaTimeInfo)(\n              PF_ProgPtr      effect_ref,\n              csSDK_uint32    inLayerParamIndex,\n              bool            inUseSoundTimecodeAsStartTime,\n              PrTime          inSequenceTime,\n              PrTime*         outCurrentMediaTime,\n              PrTime*         outMediaTicksPerFrame,\n              PF_TimeDisplay* outMediaTimeDisplay);\n</code></pre>"},{"location":"exporters/suites/#getsequencezeropoint","title":"GetSequenceZeroPoint()","text":"<p>Retrieves the zero point (start time) of the sequence in which the effect is applied.</p> <pre><code>prSuiteError(*GetSequenceZeroPoint)(\n              PF_ProgPtr    inEffectRef,\n              PrTime*       outZeroPointTime);\n</code></pre>"},{"location":"exporters/suites/#getsourcetrackcurrentclipduration","title":"GetSourceTrackCurrentClipDuration()","text":"<p>Retrieves the duration of the clip, at the specified layer index, at inSequenceTime.</p> <pre><code>prSuiteError(*GetSourceTrackCurrentClipDuration)(\n              PF_ProgPtr        inEffectRef,\n              csSDK_uint32      inLayerParamIndex,\n              PrTime            inSequenceTime,\n              PrTime*           outClipDuration);\n</code></pre>"},{"location":"exporters/suites/#getsequenceduration","title":"GetSequenceDuration()","text":"<p>Retrieves the duration of the sequence in which the effect is applied.</p> <pre><code>prSuiteError(*GetSequenceDuration)(\n              PF_ProgPtr    inEffectRef,\n              PrTime*       outSequenceDuration);\n\n      /*\n      ** Get the video resolution string, formatted as a 'width x height',\n      ** of the clip (ie, track item) at inSequenceTime on inSourceTrack.\n      ** Set inSourceTrack to -1 to query the top-most clip at inSequenceTime\n      ** (only if effect is on an adjustment layer)\n      */\n</code></pre>"},{"location":"exporters/suites/#getvideoresolutionstring","title":"GetVideoResolutionString()","text":"<p>Retrieve a string representing the dimensions of the track item to which the effect is applied.</p> <pre><code>prSuiteError(*GetVideoResolutionString)(\n              PF_ProgPtr    inEffectRef,\n              int32_t       inSourceTrack,\n              PrTime        inSequenceTime,\n              PrSDKString*  outSDKString);\n</code></pre>"},{"location":"exporters/whats-new/","title":"Whats New","text":""},{"location":"exporters/whats-new/#whats-new-in-cc","title":"What's New in CC","text":"<p>A new Captions tab has been added to the Export Settings, for Closed Captioning export. For all formats, a sidecar file containing the captions can be exported.</p> <p>To learn how exporters can optionally embed Closed Captioning directly in the output file, see Closed Captioning.</p> <p>Two new selectors have been added to GetExportSourceInfo in the Export Info Suite. You can use <code>kExportInfo_UsePreviewFiles</code> to check if the user has checked \"Use Previews\" in the Export Settings dialog. If so, if possible, reuse any preview files already rendered. You can use <code>kExportInfo_NumAudioChannels</code> to get the number of audio channels in a given source.</p> <p>This can be used to automatically initialize the audio channel parameter in the Audio tab of the Export Settings to match the source.</p> <p>In the Export Param Suite, a new function, <code>MoveParam()</code>, can be used to move an existing parameter to a new location.</p>"},{"location":"exporters/whats-new/#whats-new-in-cs6","title":"What's New in CS6","text":"<p>Exporters can now use the Exporter Utility Suite for \"push\" model compression. The exporter host can simply push frames to a thread-safe exporter-specified callback. This will cut down on the code previously required for render loop management. It should also yield substantial performance increases for exporters that haven't finely tuned their multithreaded rendering. The \"pull\" model is still supported, and required for Encore and legacy versions of Premiere Pro and Media Encoder.</p> <p>The new Export Standard Param Suite provides the standard parameters used in many built-in exporters. This can greatly reduce the amount of code needed to manage standard parameters for a typical exporter, and guarantee consistency with built-in exporters.</p> <p>Stereoscopic video is now supported when exporting directly from Premiere Pro. In other words, when exports are queued to run in Adobe Media Encoder, they can not get stereoscopic video.</p> <p>Note</p> <p>Currently, stereoscopic exporters must use the \"pull\" model and the new <code>MakeVideoRendererForTimelineWithStreamLabel()</code> to get rendered frames from multiple video streams.</p> <p>Export Param Suite now adds SetParamDescription(), to set tooltip strings for parameters. For the three line Export Summary description in the Export Settings dialog, we've swapped the 2nd and 3rd lines so that the bitrate summary comes after the audio summary. We've renamed the structure to make developers aware of this during a recompile.</p> <p>Adobe Media Encoder now includes a Preset Browser that provides more organization for presets. Make sure your presets take advantage of this organization, and are shown in your desired proper location in the Preset Browser.</p> <p>Exporters can now set events (error, warning, or info) for a specific encode in progress in the Adobe Media Encoder render queue. The existing call in the Error Suite is not sufficient for AME to relate the event to a specific encode. So the new Exporter Utility Suite provides a way for exporters running either in Premiere Pro or Adobe Media Encoder to log events. These events are displayed in the application UI, and are also added to the AME encoding log.</p> <p>Multiple exporters are now supported in a single plugin. To support this, <code>exExporterInfoRec</code> is now set to exporters on exShutdown.</p> <p><code>exQueryOutputSettingsRec</code> has a new member, <code>outUseMaximumRenderPrecision</code>, moving knowledge of this render parameter to the exporter.</p>"},{"location":"exporters/whats-new/#whats-new-in-cs55","title":"What's New in CS5.5","text":"<p>A new call, <code>RenderVideoFrameAndConformToPixelFormat</code>, has been added to the Sequence Render Suite. This allows an exporter to request a rendered frame and then conform it to a specific pixel format.</p> <p>A new return value, <code>exportReturn_ParamButtonCancel</code>, has been added to signify that an exporter is returning from <code>exSelParamButton</code> without modifying anything.</p>"},{"location":"exporters/whats-new/#export-controller-api","title":"Export Controller API","text":"<p>We have opened up a new export controller API that can drive any exporter to generate a file in any format and perform custom post-processing operations. Developers wanting to integrate Premiere Pro with an asset management system will want to use this API instead.</p>"},{"location":"exporters/whats-new/#whats-new-in-cs5","title":"What's New in CS5","text":"<p><code>exQueryOutputFileListAfterExportRec</code> is now <code>exQueryOutputFileListRec</code>, with a slight change to the structure order.</p> <p>We've also fixed a few bugs, such as bug 1925419, where all sliders would be given a checkbox to disable the control, as if exParamFlag_optional had been set.</p> <p>We've made a couple new attributes available to exporters via the <code>GetExportSourceInfo()</code> call - the video poster frame time, and the source timecode.</p> <p>3rd-party exporters can now be used to transcode assets to MPEG-2 or Blu-ray compliant files.</p>"},{"location":"exporters/whats-new/#porting-from-the-compiler-api","title":"Porting From the Compiler API","text":"<p>The export API replaces the old compiler API from CS3 and earlier versions. The export API combines the processing speed and quality of the old compiler API, with the UI flexibility of Media Encoder. Although the selectors and structures have been renamed and reorganized, much of the code that deals with rendering and writing frames is mostly the same.</p> <p>The parameter UI is what has changed the most. Rather than having a standard set of parameters as standard compilers had, or having a completely custom UI as custom compilers had, in</p> <p>the new exporter API, all parameters must be explicitly added using the Export Param Suite. First register the parameters during <code>exSelGenerateDefaultParams</code>, and then provide the localized strings and constrained parameter values during <code>exSelPostProcessParams</code>. When the exporter is sent <code>exSelExport</code> to export, get the parameter values, again using the Export Param Suite.</p>"},{"location":"gpu-effects-transitions/PrGPU-SDK-macros/","title":"PrGPU SDK Macros","text":"<p>The PrGPU SDK macros and device functions allow you to write kernels that will compile on multiple GPU compute languages - CUDA, OpenCL, and Metal. These languages have an enormous overlap - a C98 language subset, and by using the porting macros and functions to abstract out the differences, you can write portable code. You can still access API specific features not covered by the porting set but you'll need to include an alternate code path for the other APIs.</p> <p>Currently the SDK does not provide host side code to compile or launch arbitrary kernels, but there are SDK examples that show how to do this for the different APIs.</p> <p>The macros are not part of the plugin API - they are provided as a utility if you would like to used them. This gives you broad latitude to fork them and make any changes you see fit without breaking plugin compatibility. On the Adobe end, we may expand and modify the SDK kernel porting set in future releases to cover other compute APIs or other enhancements.</p>"},{"location":"gpu-effects-transitions/PrGPU-SDK-macros/#external-dependencies","title":"External Dependencies","text":"<p>The macros do add one external source dependency - Boost (boost.org). We use the Boost preprocessor package to manipulate kernel definitions.</p> <p>Depending on how you choose to compile and deploy your kernels, we also provide a small python script that may be useful (See \"Preprocessing as a Separate Step\")</p>"},{"location":"gpu-effects-transitions/PrGPU-SDK-macros/#include-paths","title":"Include Paths","text":"<p>You need to add some include paths to your kernel compilation environment:</p> <ul> <li>the path to PrGPU/KernelSupport/ (found in the SDK at Examples/Projects/GPUVideoFilter/ Utils/)</li> <li>the path to the Boost library</li> </ul>"},{"location":"gpu-effects-transitions/PrGPU-SDK-macros/#defines","title":"Defines","text":"<p>You will also need to define a symbol to tell the header file what API to process when compiling the kernel:</p> <ul> <li>Metal:<ul> <li><code>DGF_DEVICE_TARGET_METAL=1</code></li> </ul> </li> <li>OpenCL:<ul> <li><code>DGF_DEVICE_TARGET_OPENCL=1</code></li> <li><code>DGF_OPENCL_SUPPORTS_16F=1</code> or <code>0</code>, depending on whether you will support half (16-bit float) access for this device. Some older cards are quite slow at half support, or just don't support it.</li> </ul> </li> <li>CUDA:<ul> <li>the KernelCore.h header will automatically sense the cuda compiler and will <code>#define GF_DEVICE_TARGET_CUDA 1</code> for you.</li> </ul> </li> </ul> <p>Only one device target flag will be active in any given compilation. The header the define the device target macros to 0 for the inactive APIs. Feel free to use these macros in your code for any API specializations. Outside of the header, we don't need to do this much.</p>"},{"location":"gpu-effects-transitions/PrGPU-SDK-macros/#header-files","title":"Header Files","text":"<ul> <li>KernelCore.h - basic header macros. You'll certainly want these</li> <li>KernelMemory.h - global device memory access abstractions for float and half</li> <li>FloatingPoint.h - common floating point routines. These mostly hide naming differences across APIs.</li> </ul> <p>You'll want to include them like this in your kernel:</p> <pre><code>#include \"PrGPU/KernelSupport/KernelCore.h\"\n</code></pre> <p>The folder contains additional files used by the above files.</p> <p>One thing to watch out for is whether your projects are tracking header dependencies properly. If not, you'll need to manually recompile kernels when include files change. This is true whether or not you use the SDK porting set, so you've likely already sorted this out.</p>"},{"location":"gpu-effects-transitions/PrGPU-SDK-macros/#top-level-kernel-files","title":"Top Level Kernel Files","text":"<p>You can organize your code and projects as you like, but we find it convenient to have separate top level kernel files for each API (.cl, .cu, and .metal) that just include shared code and are otherwise nearly empty. This makes build rules much easier.</p>"},{"location":"gpu-effects-transitions/PrGPU-SDK-macros/#preprocessing-as-a-separate-step","title":"Preprocessing as a Separate Step","text":"<p>If you compile the kernel source on the customer machine, you may wish to preprocess the kernel at plugin compile time, and store the kernel source in your plugin. A python script (Python version 3 or greater required) is provided that will convert preprocessed source to a character array. The script is in Examples/Projects/GPUVideoFilter/Utils/CreateCString.py. See the ProcAmp example for usage.</p> <p>You can also compile kernels (which is always the case for CUDA) at plugin compile time, in which case you don't need the python script, or a separate preprocessing run. You will need to package the compiled kernel in your plugin if you go this route.</p> <p>The ProcAmp example uses a preprocessing step for OpenCL.</p>"},{"location":"gpu-effects-transitions/PrGPU-SDK-macros/#declaring-kernels","title":"Declaring Kernels","text":"<p>Metal kernels require syntax that is quite different than CUDA, and the PrGPU macros use the Boost preprocessing package to express parameters. This is by far the most complicated part of the package, so grab a fresh cup of coffee and sit back for a read.</p> <p>The GF_KERNEL_FUNCTION macro is used to pass values as parameters (CUDA) or in a struct (metal). The macro will create an API-specific kernel entry point which will call a</p> <p>function that it defines, leaving you to fill in the body. The macro uses Boost preprocessor sequences to express a type/name pair:</p> <pre><code>(float)(inValue)\n</code></pre> <p>These pairs are then nested into a sequence of parameters:</p> <pre><code>((float)(inAge))((int)(inMarbles))\n</code></pre> <p>There are different categories of parameters, such as buffers, values, and kernel position. Each category sequence is a separate macro parameter. Example usage:</p> <pre><code>GF_KERNEL_FUNCTION(RemoveFlicker,\n\n//kernel name, then comma, ((GF_PTR(float4))(inSrc))\n\n//all buffers and textures go after the first comma\n((GF_PTR(float4))(outDest)),\n((int)(inDestPitch))\n\n//After the second comma, all values to be passed ((DevicePixelFormat)(inDeviceFormat))\n((int)(inWidth))\n((int)(inHeight)),\n((uint2)(inXY)(KERNEL_XY))\n\n//After the third comma, the position arguments.\n((uint2)(inBlockID)(BLOCK_ID)))\n{\n  // &lt;do something interesting here&gt;\n}\n</code></pre> <p>In the example above, the host does not pass the position values when invoking the kernel.</p> <p>Position values are filled in automatically by the unmarshalling code generated by the GF_KERNEL_FUNCTION macro. The code you write will actually end up in a device function that the unmarshalling code will call. See the ProcAmp example plugin for usage.</p> <p>Kernels that use statically sized shared memory use a different macro, <code>GF_KERNEL_FUNCTION_SHARED</code>. Please see the header for details.</p>"},{"location":"gpu-effects-transitions/PrGPU-SDK-macros/#declaring-device-functions","title":"Declaring Device Functions","text":"<p>By comparison, device functions are a snap to write:</p> <pre><code>GF_DEVICE_FUNCTION float Average(float a, float b) {...\n</code></pre>"},{"location":"gpu-effects-transitions/PrGPU-SDK-macros/#other-macros-and-functions","title":"Other Macros and Functions","text":"<p>There's a variety of other macros and functions in the KernelSupport headers. Please see the Headers and examples for details.</p>"},{"location":"gpu-effects-transitions/PrGPUFilter-function-table/","title":"PrGPUFilter Function Table","text":"<p>PrGPUFilter is a structure consisting of the following functions that a effect/transition can implement.</p> Selector Optional Description CreateInstance No Allocate and initialize any GPU resources. DisposeInstance No Release GPU resources. GetFrameDependencies Yes If the rendered result of the effect/transition depends on frames other than the input frame, specify these here. PreCompute Yes Precompute. Render No Render."},{"location":"gpu-effects-transitions/cuda-opencl-metal-opengl/","title":"CUDA, OpenCL, Metal, or OpenGL?","text":"<p>As of Summer 2021, Premiere Pro will no longer support OpenCL. The GPU architecture of Premiere Pro is entirely CUDA/Metal, and this is what is exposed through the GPU extensions to the effect/transition APIs.</p> <p>Premiere Pro plugins have the ability to transfer frames from CUDA to OpenGL (though not always efficiently). Read more about that here.</p>"},{"location":"gpu-effects-transitions/function-descriptions/","title":"Function Descriptions","text":""},{"location":"gpu-effects-transitions/function-descriptions/#createinstance","title":"CreateInstance","text":"<pre><code>prSuiteError (*CreateInstance)(\n  PrGPUFilterInstance*  ioInstanceData);\n</code></pre> <p>Creates a GPU filter instance representing an effect or transition on a track item.</p> <p>Returning an error from CreateInstance will cause this node to be rendered in software for the current set of parameters.</p> <p>Unlike software instances of effects and transitions, GPU instances are created and disposed whenever an effect parameter changes.</p> <p>This allows an effect have more flexibility about opting-in for GPU rendering, depending on the parameters. Separate instances may be called concurrently.</p>"},{"location":"gpu-effects-transitions/function-descriptions/#disposeinstance","title":"DisposeInstance","text":"<pre><code>prSuiteError (*DisposeInstance)(\n  PrGPUFilterInstance*  ioInstanceData);\n</code></pre> <p>Cleanup any resources allocated during CreateInstance.</p>"},{"location":"gpu-effects-transitions/function-descriptions/#getframedependencies","title":"GetFrameDependencies","text":"<pre><code>prSuiteError (*GetFrameDependencies)(\n  PrGPUFilterInstance*            inInstanceData,\n  const PrGPUFilterRenderParams*  inRenderParams,\n  csSDK_int32*                    ioQueryIndex,\n  PrGPUFilterFrameDependency*     outFrameDependencies);\n</code></pre> <p>Return dependency information about a render, or nothing if only the current frame is required.</p> <p>Increment <code>ioQueryIndex</code> for additional dependencies.</p>"},{"location":"gpu-effects-transitions/function-descriptions/#precompute","title":"PreCompute","text":"<pre><code>prSuiteError (*Precompute)(\n  PrGPUFilterInstance*            inInstanceData,\n  const PrGPUFilterRenderParams*  inRenderParams,\n  csSDK_int32                     inIndex,\n  PPixHand                        inFrame);\n</code></pre> <p>Precompute a result into preallocated uninitialized host (pinned) memory.</p> <p>Will only be called if <code>PrGPUDependency_Precompute</code> was returned from <code>GetFrameDependencies</code>.</p> <p>Precomputation may be called ahead of render time.</p> <p>Results will be uploaded to the GPU by the host.</p> <p>If <code>outPrecomputePixelFormat</code> is not custom, frames will be converted to the GPU pixel format.</p>"},{"location":"gpu-effects-transitions/function-descriptions/#render","title":"Render","text":"<pre><code>prSuiteError (*Render)(\n  PrGPUFilterInstance*            inInstanceData,\n  const PrGPUFilterRenderParams*  inRenderParams,\n  const PPixHand*                 inFrames,\n  csSDK_size_t                    inFrameCount,\n  PPixHand*                       outFrame);\n</code></pre> <p>Render into an allocated outFrame allocated with <code>PrSDKGPUDeviceSuite</code> or operate in place.</p> <p>Result must be in the same pixel format as the input. If the effect grows or shrinks the output area (e.g. rendering a drop shadow), it is allowable for the effect to allocate and return a different sized outFrame.</p> <p>For effects, <code>inFrames[0]</code> will always be the frame at the current time, other input frames will be in the same order as returned from <code>GetFrameDependencies</code>. For transitions <code>inFrames[0]</code> will be the incoming frame and <code>inFrames[1]</code> the outgoing frame. Transitions may not have other frame dependencies.</p> <p>Use the utility function <code>GetParam</code> to retrieve the parameter values at the current time.</p>"},{"location":"gpu-effects-transitions/getting-started/","title":"Getting Started","text":""},{"location":"gpu-effects-transitions/getting-started/#setting-up-the-sample-projects","title":"Setting up the Sample Projects","text":"<p>If you are developing an effect, begin with one of the two GPU effect sample projects, progressively replacing its functionality with your own. Refer to Introduction for general instructions on how to build the SDK projects.</p> <p>In addition to those general instructions, the sample project is also dependent on the After Effects plugin SDK. On Windows, create an environment variable pointing to it named AE_SDK_BASE_PATH, so that the compiler will find the AE headers that the project includes. On macOS, in Xcode &gt; Preferences &gt; Locations &gt; Custom Paths, specify AE_SDK_BASE_PATH to be the root folder of the AE plugin SDK you have downloaded and unzipped.</p> <p>The samples also use Boost, which may be downloaded at boost.org. Download that, and create a variable named BOOST_BASE_PATH just as you did with AE_SDK_BASE_PATH above.</p> <p>Finally, install Python (version 3.6 or greater), if you do not have it already. It may be downloaded at python.org. The sample projects use this as part of the custom build steps.</p> <p>Depending on whether your effect will use CUDA, you'll need to download the CUDA SDK. On Windows, create an environment variable pointing to it named CUDA_SDK_BASE_PATH, so that the linker will find the right libraries.</p>"},{"location":"gpu-effects-transitions/getting-started/#querying-for-parameters-and-other-attributes-of-a-effect-or-transition","title":"Querying for Parameters and other Attributes of a Effect or Transition","text":"<p>You'll notice that PrGPUFilterRenderParams has some attributes about an effect or transition, but many things, such as the parameters or duration of the clip to which the plugin is applied, are not found in that structure. These attributes will need to be queried using the GetParam() and GetProperty() helper functions in PrGPUFilterModule.h. For example:</p> <pre><code>GetProperty(kVideoSegmentProperty_Effect_EffectDuration, duration);\nGetProperty(kVideoSegmentProperty_Transition_TransitionDuration, duration);\n</code></pre>"},{"location":"gpu-effects-transitions/getting-started/#lifetime-of-a-gpu-effect-transition","title":"Lifetime of a GPU Effect / Transition","text":"<p>A new GPU effect instance is created when an effect/transition is applied in the timeline, or when an effect parameter is changed. When rendering a series of frames it won't needlessly be recreated. The Opaque Effect Data Suite should be used to share unflattened sequence data between instances of the same effect on a track item.</p>"},{"location":"gpu-effects-transitions/getting-started/#fallback-to-software-rendering","title":"Fallback to Software Rendering","text":"<p>When a new GPU effect instance is created, the instance has the option of opting-in or out of providing GPU rendering. The GPU effect should be reasonably sure it has sufficient resources to complete the render if it opts-in, because there is no API support to fall back to software rendering in the middle of a render.</p> <p>Calling GetDeviceInfo() in the GPU Device Suite, and checking <code>outDeviceInfo.outMeetsMinimumRequirementsForAcceleration</code>, you can see if supports the minimum system requirements for acceleration. Do not proceed with</p> <p>AcquireExclusiveDeviceAccess(), if the minimum requirements are not met.</p> <p>In emergency situations, when there is not enough GPU memory available to complete a render, an effect may call PurgeDeviceMemory in the GPU Device Suite to free up memory not initially available. This will impact performance, and should be used only if absolutely necessary.</p>"},{"location":"gpu-effects-transitions/getting-started/#opengl-interoperability","title":"OpenGL Interoperability","text":"<p>If you want, you have the ability to transfer frames from CUDA to OpenGL (though not always efficiently).</p> <p>For CUDA interoperability with OpenGL:</p>"},{"location":"gpu-effects-transitions/getting-started/#cuda-opengl","title":"CUDA -&gt; OpenGL","text":"<ul> <li>Create an OpenGL buffer</li> <li>map it into CUDA with <code>cuGraphicsMapResources</code></li> <li>get the mapped address with <code>cuGraphicsResourceGetMappedPointer</code></li> <li>copy from the CUDA address to the mapped address with <code>cuMemcpyDtoDAsync</code></li> <li>unmap with <code>cuGraphicsUnmapResources</code></li> </ul>"},{"location":"gpu-effects-transitions/getting-started/#opengl-cuda","title":"OpenGL -&gt; CUDA","text":"<ul> <li>Map the OpenGL buffer into CUDA with <code>cuGraphicsMapResources</code></li> <li>get the mapped address with <code>cuGraphicsResourceGetMappedPointer</code></li> <li>copy from the mapped address to CUDA with <code>cuMemcpyDtoDAsync</code></li> <li>unmap with <code>cuGraphicsUnmapResources</code></li> </ul> <p>Note</p> <p>On the Mac there is no real OpenGL/CUDA interoperability, and these calls will go through system memory.</p>"},{"location":"gpu-effects-transitions/getting-started/#entry-point","title":"Entry Point","text":"<p>The GPU entry point function will only be called if the current project is using GPU acceleration. Otherwise, the normal entry point function will be called as described in the After Effects SDK, or GPU Effects &amp; Transitions or Video Filters in this SDK Guide.</p> <p>Make sure GPU acceleration is activated in File &gt; Project Settings &gt; General &gt; Video Rendering and Playback &gt; Renderer. If a GPU option is not available, then you will need to install a suitable video card in your system.</p> <pre><code>prSuiteError xGPUFilterEntry (\n  csSDK_uint32      inHostInterfaceVersion,\n  csSDK_int32*      ioIndex,\n  prBool            inStartup,\n  piSuitesPtr       piSuites,\n  PrGPUFilter*      outFilter,\n  PrGPUFilterInfo*  outFilterInfo)\n</code></pre> <p>If <code>inStartup</code> is non-zero, the effect/transition should startup and initialize the functions needed to implement PrGPUFilter, as well as the info in PrGPUFilterInfo.</p> <p>If <code>inStartup</code> is false, then the effect/transition should shutdown, unloading any resources it loaded on startup.</p> <p>As of CC, inHostInterfaceVersion is <code>PrSDKGPUFilterInterfaceVersion1 == 1</code></p> <p>If a single plugin supports multiple effects, increment ioIndex to the next value before returning, in order to be called again to describe the next effect.</p>"},{"location":"gpu-effects-transitions/gpu-effects-transitions/","title":"GPU Effects &amp; Transitions","text":"<p>This chapter describes the additional capabilities available to effects and transitions for GPU interoperability with Premiere Pro. The GPU extensions allow these plugins to have full access to GPU-resident frames without readback to system memory, when using the Mercury Playback Engine in a GPU-accelerated mode. Effects and transitions can also optionally tell the host that they support real-time processing, so that they will not be flagged as non-realtime.</p> <p>The GPU extensions work on top of effects and transitions built using the After Effects SDK. The extensions are designed to supplement a regular software effect or transition, which defines the software rendering path, parameters, custom UI drawing, and other standard interaction. The GPU effect exists as a new entry point for rendering using the GPU if possible. The software render path will be used otherwise.</p>"},{"location":"gpu-effects-transitions/gpu-effects-transitions/#system-requirements","title":"System Requirements","text":"<p>The system requirements for developing GPU effects &amp; transitions are higher than developing other plugins. You'll need a video card that supports Mercury Playback Engine GPU acceleration. Make sure your video card supports the type of video acceleration you are developing, on the platform you are developing on. See this page for the latest supported video cards: https://helpx.adobe.com/premiere-pro/system-requirements.html</p> <p>The CUDA SDK is also needed for CUDA rendering development.</p>"},{"location":"gpu-effects-transitions/gpu-effects-transitions/#compilation-notes","title":"Compilation notes","text":""},{"location":"gpu-effects-transitions/gpu-effects-transitions/#cuda","title":"CUDA","text":"<p>To compile GPU effects in Premiere SDK, we highly recommend using CUDA SDK 11.8.</p> <p>Caution: GPU Effects built using CUDA SDK 11.8 will not work with NVIDIA Kepler generation cards. The minimum CUDA Compute Capability has been increased to sm_50.</p>"},{"location":"gpu-effects-transitions/gpu-effects-transitions/#cuda-runtime-api-vs-driver-api","title":"CUDA Runtime API vs. Driver API","text":"<ol> <li>Utilize CUDA Driver API</li> <li>For best compatibility, we highly recommend utilizing CUDA Driver API only. Unlike the runtime API, the driver API is directly backwards compatible with future drivers. Please note that the CUDA Runtime API is built to handle/automate some of the housekeeping that is exposed and needs to be handled in the Driver APIs, so there might be some new steps/code you would need to learn and implement for migrating from Runtime API to Driver API.</li> <li>Statically Link to CUDA Runtime</li> <li>If you must stick to CUDA Runtime API, we recommend you statically link to the CUDA Runtime. That's an alternative way for leveraging the backwards compatibility of the driver into the future. This can be done by linking cudart_static.lib.</li> <li>Dynamically Link to CUDA Runtime</li> <li>This also works but would be prone to compatibility issues. A compatible CUDA Runtime DLL needs to be available on users' systems so that driver can understand and be backward compatible. Currently Premiere Pro ships a copy of CUDA Runtime DLL of our recommended CUDA SDK version. This may change in future. If you must dynamically link to CUDA Runtime, we recommend you ship a copy of the CUDA Runtime DLL with your plugin and leverage dlopen/LoadLibrary to explicitly load the desired runtimes. For more details, see the CUDA Compatibility section of NVIDIA's GPU Management and Deployment guide: https://docs.nvidia.com/deploy/cuda-compatibility/</li> </ol>"},{"location":"gpu-effects-transitions/gpu-effects-transitions/#directx","title":"DirectX","text":"<p>We would like to announce that we have been working on introducing support for DirectX 12 in our rendering pipeline. We will soon be sharing unlock instructions to enable DirectX in your application.</p>"},{"location":"gpu-effects-transitions/gpu-effects-transitions/#why","title":"Why?","text":"<ul> <li>Performance - DirectX 12 is a thin wrapper over the hardware which would provide us with more control than OpenCL/CUDA over the execution of our shaders. This translates to a higher ceiling for performance</li> <li>Stability/Error Handling - DirectX 12 supports TDR detection and recovery which can help us recover from hardware problems. It is actively supported by Microsoft i.e., proactive fixes for bugs in drivers</li> <li>Interoperability - Seamless interoperability with our display module which already uses DirectX12</li> </ul>"},{"location":"gpu-effects-transitions/gpu-effects-transitions/#direction","title":"Direction","text":"<p>Adding a new rendering engine to Premiere is a massive undertaking. Although we have made significant progress, it is still under development and will have an update for you soon.</p>"},{"location":"gpu-effects-transitions/gpu-effects-transitions/#feedback-support","title":"Feedback &amp; Support","text":"<p>We will be happy to receive any thoughts regarding DirectX or answer any questions. I am reachable at, pusingha@adobe.com or you can post them on ae_api_nda@adobe.com</p>"},{"location":"gpu-effects-transitions/return-codes/","title":"Return Codes","text":"Return Code Reason <code>malNoError</code> No error. <code>malUnknownError</code> Error."},{"location":"gpu-effects-transitions/structure-descriptions/","title":"Structure Descriptions","text":""},{"location":"gpu-effects-transitions/structure-descriptions/#prgpufilterinfo","title":"PrGPUFilterInfo","text":"<p>This structure contains some basic info about a GPU filter. It provides access to various suites, and access to private data where the instance can allocate memory and store data which will be passed to subsequent functions.</p> <pre><code>typedef struct {\n  csSDK_uint32  outInterfaceVersion;\n  PrSDKString   outMatchName;\n} PrGPUFilterInfo;\n</code></pre> Member Description <code>outInterfaceVersion</code> Set to the GPU API version corresponding to the version defined in the SDK you are using. <code>outMatchName</code> outMatchName must be equal to a registered software filter, if NULL will default to the module's PiPL."},{"location":"gpu-effects-transitions/structure-descriptions/#prgpufilterinstance","title":"PrGPUFilterInstance","text":"<p>This structure contains some basic info about a GPU filter. It provides access to various suites, and access to private data where the instance can allocate memory and store data which will be passed to subsequent functions.</p> <pre><code>typedef struct {\n  piSuitesPtr   piSuites;\n  csSDK_uint32  inDeviceIndex;\n  PrTimelineID  inTimelineID;\n  csSDK_int32   inNodeID;\n  void*         ioPrivatePluginData;\n  prBool        outIsRealtime;\n} PrGPUFilterInstance;\n</code></pre> Member Description <code>piSuites</code> Standard suites. <code>inDeviceIndex</code> For use with <code>PrSDKGPUDeviceSuite</code>. <code>inTimelineID</code> For use with <code>PrSDKVideoSegmentSuite</code>. <code>inNodeID</code> For use with <code>PrSDKVideoSegmentSuite</code>. <code>ioPrivatePluginData</code> Used by a plugin to store instance data, never touched by the host. <code>outIsRealtime</code> Specify if the plugin is likely to play in real-time, used to determine whether the segment is red, yellow, or unmarked in the timeline."},{"location":"gpu-effects-transitions/structure-descriptions/#prgpufilterrenderparams","title":"PrGPUFilterRenderParams","text":"<p>This structure describes the current render request.</p> <pre><code>typedef struct {\n  PrTime  inClipTime;\n  PrTime  inSequenceTime;\n\n  // Render properties\n  PrRenderQuality  inQuality;\n  float            inDownsampleFactorX;\n  float            inDownsampleFactorY;\n\n  // Frame properties\n  csSDK_uint32    inRenderWidth;\n  csSDK_uint32    inRenderHeight;\n  csSDK_uint32    inRenderPARNum;\n  csSDK_uint32    inRenderPARDen;\n  prFieldType     inRenderFieldType;\n  PrTime          inRenderTicksPerFrame;\n  pmFieldDisplay  inRenderField;\n} PrGPUFilterRenderParams;\n</code></pre> Member Description <code>inClipTime</code> The time of the current render, relative to clip start <code>inSequenceTime</code> The time of the current render, relative to sequence start <code>inQuality</code> Render quality; one of the PrRenderQuality enum values <code>inDownsampleFactorX</code> Horizontal downsample factor <code>inDownsampleFactorY</code> Vertical downsample factor <code>inRenderWidth</code> Video resolution <code>inRenderHeight</code> <code>inRenderPARNum</code> Video pixel aspect ratio, described as a fractional number with separate values for numerator and denominator. <code>inRenderPARDen</code> <code>inRenderFieldType</code> Render field type <code>inRenderTicksPerFrame</code> Video frame rate <code>inRenderField</code> GPU rendering is always done on full-height progressive frames unless <code>PrGPUFilterFrameDependency.outNeedsFieldSeparation</code> is false.<code>inRenderField</code> indicates which field is being rendered."},{"location":"gpu-effects-transitions/structure-descriptions/#prgpufilterframedependency","title":"PrGPUFilterFrameDependency","text":"<p>This structure describes any dependencies for a rendered frame.</p> <pre><code>typedef struct {\n  PrGPUFilterFrameDependencyType  outDependencyType;\n\n  // Dependence on other frame times\n  csSDK_int32  outTrackID;\n  PrTime       outSequenceTime;\n\n  // Dependence on precomputation phase\n  PrPixelFormat  outPrecomputePixelFormat;\n  csSDK_uint32   outPrecomputeFrameWidth;\n  csSDK_uint32   outPrecomputeFrameHeight;\n  csSDK_uint32   outPrecomputeFramePARNumerator;\n  csSDK_uint32   outPrecomputeFramePARDenominator;\n  prFieldType    outPrecomputeFrameFieldType;\n  csSDK_size_t   outPrecomputeCustomDataSize;\n  prBool         outNeedsFieldSeparation;\n} PrGPUFilterFrameDependency;\n</code></pre> Member Description <code>outDependencyType</code> The dependency type.Could be either:<ul><li><code>PrGPUDependency_InputFrame</code></li><li><code>PrGPUDependency_Precompute</code></li><li><code>PrGPUDependency_FieldSeparation</code></li></ul> <code>outTrackID</code> Specify which track is a dependency. Set to 0 for the current track <code>outSequenceTime</code> Set the sequence time which is a dependency. <code>outPrecomputePixelFormat</code> Dependence on precomputation phase <code>outPrecomputeFrameWidth</code> <code>outPrecomputeFrameHeight</code> <code>outPrecomputeFramePARNumerator</code> <code>outPrecomputeFramePARDenominator</code> <code>outPrecomputeFrameFieldType</code> <code>outPrecomputeCustomDataSize</code> Only needed if <code>outPrecomputePixelFormat</code> is custom <code>outNeedsFieldSeparation</code> Indicates the plugin may operate on both fields simultaneously (eg non-spatial and non-time varying)"},{"location":"gpu-effects-transitions/suites/","title":"Suites","text":"<p>For information on how to acquire and manage suites, see SweetPea Suites.</p>"},{"location":"gpu-effects-transitions/suites/#gpu-device-suite","title":"GPU Device Suite","text":"<p>This suite provides info on any GPU devices available. For example, GetDeviceInfo() allows an effect/transition to see if the device supports OpenCL or CUDA.</p> <p>Use this suite to get exclusive access to a device using AcquireExclusiveDeviceAccess and ReleaseExclusiveDeviceAccess. If needed, you can reconcile devices using the outDeviceHandle passed back from GetDeviceInfo().</p> <p>Device memory should ideally be allocated through this suite. In some cases you may find it more efficient to use a texture / image object as the source. With CUDA, you can bind a texture reference to an existing linear buffer. With OpenCL, you can create an image object from an existing 2D buffer object using image_2d_from_buffer. Temporary allocations are also fine but may be rather slow.</p>"},{"location":"gpu-effects-transitions/suites/#opaque-effect-data-suite","title":"Opaque Effect Data Suite","text":"<p>This suite provides effects a way to share unflattened sequence data between instances of the same effect on a track item. The data is opaque to the host and effects are responsible for maintaining thread safety of the shared data. The host provides reference-counting that the effect can use to manage the lifetime of the shared data. Here's an overview of how this suite should be used:</p> <p>When the effect is applied, in <code>PF_Cmd_SEQUENCE_SETUP</code>, the effect plugin allocates and initializes the sequence data in PF_OutData-&gt;out_data. Then it calls</p> <p>AcquireOpaqueEffectData(). The opaque effect data does not yet exist, so the plugin allocates it, and calls RegisterOpaqueEffectData, and then copies over the data from the sequence data. So both sequence data and opaque effect data are allocated.</p> <p>Then <code>PF_Cmd_SEQUENCE_RESETUP</code> is called (multiple times) for clones of the effect used for rendering. The effect instance knows it's a clone because the PF_InData-&gt;sequence_data is NULL (there is a special case if the effect has Opaque Effect Data - in that case, its render clones will receive <code>PF_Cmd_SEQUENCE_RESETUP</code> with a NULL sequence_data pointer). It then calls AcquireOpaqueEffectData(). As a render clone, it relies on this opaque effect data, rather than sequence data, and does not try to copy the sequence data to opaque effect data.</p> <p>When, on the other hand, <code>SEQUENCE_RESETUP</code> is called with valid sequence_data in PF_InData, this is not a render clone. The plugin unflattens this sequence data. It then calls AcquireOpaqueEffectData(), and if the opaque effect data does not yet exist (i.e. when reopening a saved project), the plugin allocates it, and calls RegisterOpaqueEffectData. It then copies the sequence data to opaque effect data.</p> <p>On <code>SEQUENCE_FLATTEN</code>, the plugin takes the unflattened data, flattens it, and disposes of the un-flat data.</p> <p>When <code>SEQUENCE_SETDOWN</code> is called (it may be called multiple times to dispose of render clones), ReleaseOpaqueEffectData() is called.</p>"},{"location":"gpu-effects-transitions/suites/#instanceid","title":"instanceID","text":"<p>The Opaque Effect Data Suite functions need the instanceID of the effect. For the software entry point, you can obtain this using GetFilterInstanceID() in PF_UtilitySuite, defined in PrSDKAESupport.h. For the GPU Render entry point, you can use the following code: csSDK_uint32 instanceID;</p> <pre><code>GetProperty( kVideoSegmentProperty_Effect_RuntimeInstanceID, instanceID);\n</code></pre> <p>\u2026where GetProperty() is defined in PrGPUFilterModule.h, and the <code>kVideoSegmentProperty_</code> IDs are defined in PrSDKVideoSegmentProperties.h.</p>"},{"location":"gpu-effects-transitions/whats-new-in-ppro-12/","title":"What's New in Premiere Pro 12.0?","text":"<p>GPU effects and transitions built using this SDK can now be compatible with After Effects 15.0 and later. The sample GPU effect projects have been updated so that they load in both Premiere Pro and After Effects.</p> <p>The newly provided PrGPU SDK macros and device functions allow you to write kernels that will compile on multiple GPU compute languages - OpenCL, CUDA, and Metal.</p>"},{"location":"gpu-effects-transitions/whats-new-in-ppro-cc2014/","title":"What's New in Premiere Pro CC 2014?","text":"<p>OpenCL rendering now also uses the half-precision 16-bit floating point pixel format for rendering. GPU-accelerated effects and transitions should implement both 16f and 32f rendering.</p>"},{"location":"gpu-effects-transitions/whats-new-in-ppro-cc2015/","title":"What's New in Premiere Pro CC 2015.4?","text":"<p>GPU-accelerated rendering using Metal is now supported for third-party effects and transitions. <code>PrGPUDeviceFramework_Metal</code> has been added as one of the enum values in <code>PrGPUDeviceFramework</code>.</p>"},{"location":"hardware/classdata-functions/","title":"ClassData Functions","text":"<p>All plugin types that support media can use these callbacks to share information associated with their classID.</p> <p>For example, these plugins can confirm their hardware is present and operational using the ClassData functions.</p> <p>They all call <code>getClassData</code> during initialization. If <code>getClassData</code> returns 0, the module checks for and initialize the hardware.</p> <p>It then calls setClassData to store information about the current context. Use handles, not pointers, for storing info.</p> <pre><code>typedef struct {\n  SetClassDataFunc  setClassData;\n  GetClassDataFunc  getClassData;\n} ClassDataFuncs, *ClassDataFuncsPtr;\n</code></pre> Function Description <code>setClassData</code> Writes class data, destroys previous data.<pre>int setClassData (  unsigned int  theClass,  void          *info);</pre><ul><li><code>theClass</code> - the class being set. Use a unique 4-byte code.</li><li><code>info</code> - the class data to be set. It can be used as a pointer or a handle.</li></ul>Note that all plugins that share the data must use the same data structure. <code>getClassData</code> Retrieves the class data for the given class.<pre>int getClassData (  unsigned int  theClass);</pre><ul><li><code>theClass</code> - the class for which to retrieve data.</li></ul>"},{"location":"hardware/classid-filetype-subtype/","title":"ClassID, Filetype and Subtype","text":"<p>All plugin types that support media must identify unique classID, filetype, and subtype.</p> <p>These are all four character codes, or 'fourCCs'.</p> Identifier Purpose <code>filetype</code> Identifies the plugin's associated file type(s). Plugins create lists of filetypes they support. <code>subtype</code> Differentiates between files of the same filetype. Identifies the codec or compression to be used. <code>classID</code> With the new editing mode system starting in CS4, the classID is far less important.It is used as part of the identification for exporters in the Editing Mode XML.And plugins may share information with most other plugins running in the same process using the ClassData Functions."},{"location":"hardware/hardware-integration-components/","title":"Hardware Integration Components","text":""},{"location":"hardware/hardware-integration-components/#importers","title":"Importers","text":"<p>Importers are used whenever frames of video or audio from a clip are needed. To give Premiere Pro the ability to read media that uses a new format or codec, develop an importer. See Importers for more information.</p>"},{"location":"hardware/hardware-integration-components/#recorders","title":"Recorders","text":"<p>Users may choose a recorder in Project &gt; Project Settings &gt; General &gt; Capture Format. Recorders are used to grab frames from a hardware source and write them to a file, to be imported for editing.</p>"},{"location":"hardware/hardware-integration-components/#exporters","title":"Exporters","text":"<p>Exporters are used whenever Premiere Pro renders preview files, or performs an export on a clip or sequence. To give Premiere Pro the ability to write media that uses a new format or codec, develop an exporter. The exporter used to render preview files in the timeline is set in Sequence &gt; Sequence Settings &gt; Preview File Format. The exporter used for exports is chosen when the user selects File &gt; Export &gt; Media &gt; File Type. See Exporters for more information.</p>"},{"location":"hardware/hardware-integration-components/#transmitters","title":"Transmitters","text":"<p>A transmitter handles the display of video on any external A/V hardware and secondary output. To give Premiere Pro the ability to play video out to hardware for preview and final playout, write a transmitter. See Transmitters for more information.</p>"},{"location":"hardware/hardware/","title":"Hardware","text":"<p>To integrate hardware with Premiere Pro, you may consider developing up to five types of plugins:</p> <ul> <li>importers,</li> <li>recorders,</li> <li>exporters,</li> <li>transmitters, and</li> <li>device controllers</li> </ul> <p>Premiere Pro provides the user interface for the capture, timeline, monitor, and export panels; the plugins provide the functionality behind the interface.</p>"},{"location":"importers/getting-started/","title":"Getting Started","text":""},{"location":"importers/getting-started/#the-basics-of-import","title":"The Basics of Import","text":"<p>For each clip, importers can tell Premiere the resolutions and pixel formats they can decode video frames to.</p> <p>Premiere will request video frames as needed during scrubbing, playback, or export.</p> <p>Audio will be requested right when the clip is imported, if audio conforming or peak file generation is necessary.</p> <p>If audio conforming is not necessary, audio frames will be requested as needed during scrubbing, playback, or export.</p> <p>Premiere requests audio in arrays of 32-bit float, uninterleaved format.</p>"},{"location":"importers/getting-started/#try-the-sample-importer-plug-ins","title":"Try the Sample Importer Plug-ins","text":"<p>Choose which one of the three sample importers matches closest with your desired functionality.</p> <p>Build that one, or if you are still not sure, build all three! Step through the code in your debugger to learn order of events.</p> <p>Start your importer by modifying one of the SDK samples.</p>"},{"location":"importers/getting-started/#imgetsourcevideo-versus-imimportimage","title":"<code>imGetSourceVideo</code> versus <code>imImportImage</code>","text":"<p>For synchronous import, there are two different selectors an importer can use to provide frames to the host.</p> <p>Why? imGetSourceVideo is best for media that has specific resolutions.</p> <p>Importers that support imGetSourceVideo can import frames at their native resolution or specify preferred resolutions, rather than having to scale the frames to an arbitrary size.</p> <p>imImportImage is only useful for resolution-independent video, such as vector-based graphics.</p> <p>Choose the one that fits the media your importer will support.</p> <p>The SDK importer demonstrates imGetSourceVideo because resolution dependent video is much more common.</p> <p>The synthetic importer sample demonstrates imImportImage because it generates video on-the-fly and doesn't have a preference as to video resolution.</p> <p><code>imImageInfoRec.supportsGetSourceVideo</code> should be set to true if the importer wants to support imGetSourceVideo.</p>"},{"location":"importers/getting-started/#asynchronous-import","title":"Asynchronous Import","text":"<p>Importers can optionally support asynchronous calls to read frames for better performance. imImageInfoRec.supportsAsyncIO should be set to true if the importer wants to support asynchronous import. The importer can implement imCreateAsyncImporter, which tells the importer to create an asynchronous importer object using the data provided, and store it in <code>imAsyncImporterCreationRec</code>.</p> <p>This async importer object must implement a separate entry point from a standard importer because it does not follow the same rules as a standard importer.</p> <p>All calls to AsyncImporterEntry are reentrant, except for the aiClose selector. aiClose will only be called once, but may be called while other calls are still executing. No calls will be made after aiClose is called.</p> <p>Here is an overview of the lifetime of an async importer:</p> <ol> <li>The host calls imOpenFile and imGetInfo on the standard importer.</li> <li>The host calls imCreateAsyncImporter on the standard importer. At this time, the standard importer creates the private data for the async importer. The async importer MUST NOT contain a link to the standard importer, as their lifetimes are now decoupled. The async importer, therefore, must contain copies of all relevant private data from the creator importer. The importer preferences are also guaranteed to not change during the lifetime of the async importer.</li> <li>The host uses the async importer to perform i/o.</li> <li>The host closes the async importer, forgetting about it. This will happen whenever the app loses focus, or when the async importer is no longer needed.</li> </ol>"},{"location":"importers/getting-started/#privatedata","title":"privateData","text":"<p>Don't use global variables to store data. Use privateData instead. Each clip can have its own privateData. The host application will automatically pass the correct privateData to the appropriate importer instance.</p> <p>For privateData, create a handle to the custom structure you wish to store (during <code>imGetInfo8</code> or <code>imGetPrefs8</code>.) and save the handle to the privateData member of the structure passed in.</p> <p>The importer is responsible for allocating and deallocating the memory for privateData using Premiere's memory functions.</p> <p>Free the allocated privateData during imCloseFile or imShutdown, as appropriate.</p>"},{"location":"importers/getting-started/#clip-source-settings","title":"Clip Source Settings","text":"<p>This data is unique to each clip instance, and can be used to store clip-wide data that affects the appearance of video and/or audio in the clip, usually user-modifiable.</p> <p>For example, Clip Source Settings for a titler/graphics importer could contain all the data describing the text and shapes for that clip.</p> <p>For a raw video clip, it could contain metadata that affects how the video is developed prior to import.</p> <p>Starting in Premiere Pro CC 2014, importers can now choose the format they are rendering in, which allows importers to change pixel formats and quality based on criteria like enabled hardware and other Clip Source Settings, such as HDR.</p> <p>To handle the negotiation, implement <code>imSelectClipFrameDescriptor</code>.</p> <p>Clip Source Settings can be shown on file creation (for synthetic or custom importers) or when a clip is double-clicked.</p> <p>Settings data should be stored in a disk-safe prefs structure, which is defined by the importer.</p> <p>Premiere will allocate the prefs based on the prefsLength re turned from the first call to imGetPrefs8.</p> <p>Premiere will deallocate the prefs when it is no longer needed.</p> <p>Once prefs has been allocated, the importer should show its setup dialog during all subsequent calls to imGetPrefs8, and store any setup dialog settings in prefs.</p> <p>Like privateData, each clip has its own prefs, and the host application automatically passes the correct prefs to the appropriate importer instance.</p> <p>If the user changes the Clip Source Settings in a way such that the frames should be reimported, then the importer should use the Importer File Manager Suite to call RefreshFileAsync() on the main file.</p> <p>This is demonstrated in the SDK Custom Importer sample code.</p>"},{"location":"importers/getting-started/#showing-a-video-preview-in-the-settings-dialog","title":"Showing a Video Preview in the Settings Dialog","text":"<p>If a clip is placed in the timeline, and its settings dialog is opened by double-clicking in the timeline, then the import can get frames from the timeline of the settings dialog. Only the rendered frames on layers beneath the current clip or timeline location are available. Use the <code>getPreviewFrameEx</code> callback with the time given by tdbTimelocation in imGetPrefsRec. timelineData is also valid during imGetPrefs8.</p>"},{"location":"importers/getting-started/#file-handling","title":"File Handling","text":"<p>Basic importers that bring in media from a single file can rely on the host to provide basic file handling. If a clip has child files or a custom file system, an importer can provide its own file handling. Set canOpen, canSave, and canDelete to true during <code>imInit</code>, and respond to <code>imOpenFile8</code>, imQuietFile, imCloseFile, imSaveFile8, imDeleteFile8.</p> <p>Use the Async File Reader Suite for cross-platform file operations.</p>"},{"location":"importers/getting-started/#quieting-versus-closing-a-file","title":"Quieting versus Closing a File","text":"<p>When the application loses focus, importers receive imQuietFile for each file it has been asked to open. Update any PrivateData and close the file. If the project is closed, imCloseFile is sent, telling the importer to free any PrivateData. If the importer didn't store any PrivateData, it will not receive imCloseFile.</p>"},{"location":"importers/getting-started/#growing-files","title":"Growing Files","text":"<p>When Premiere Pro attempts to refresh a growing file (after N seconds, as determined by the preferences value), it quiets the existing importer instance, and opens a new one pointing to the same file. In response, the Importer should report the current (new) duration and, once it's determined whether the file is still growing, set  <code>imFileInfoRec.mayBeGrowing</code> appropriately.</p>"},{"location":"importers/getting-started/#importing-from-streaming-sources","title":"Importing from Streaming Sources","text":"<p>For importing video from a streaming source, in order to pretend that the file is a local file or available on the network, create a placeholder file like video_proxy.abc.</p> <p>Inside this file, include info that lets your importer know it is your own type, and the http path, like this:</p> <p>\"MyCompany ABC streaming format placeholder file https://myurl.com/video.abc\"</p> <p>Your importer would open the local video_proxy.abc file, check the header and find it is your own placeholder file, and then access the real contents at the http location included. To create the local</p> <p>.abc files, you could use a custom importer that presents a OS dialog to choose the remote file, or a Premiere panel to do so. The Panel SDK can be found here:</p> <p>https://github.com/Adobe-CEP/Samples/tree/master/PProPanel</p> <p>If the filetype is an existing filetype supported by Premiere Pro, then set a high value in <code>imImportInfoRec.priority</code> to give your importer the first opportunity to handle the file.</p> <p>For your filetype to be visible in the Proxy &gt; Attach Proxies window, set imIndFormatRec. flags |= xfIsMovie (this flag is labeled obsolete, but still needed for this case)</p> <p>If your importer supports different fractional resolutions and decode qualities, the fractional resolutions can be enumerated in response to the selector imGetPreferredFrameSize, and the decode quality hint is sent on import requests to your importer (for example in imSourceVideoRec.inQuality).</p>"},{"location":"importers/getting-started/#audio-conforming-and-peak-file-generation","title":"Audio Conforming and Peak File Generation","text":"<p>When a clip that contains audio is imported into Premiere, one or two types of files may be generated:</p> <p>First, a separate .pek file is always created. This contains peak audio samples for quick access when Premiere needs to draw the audio waveform, for example in the Source Monitor or Timeline panel.</p> <p>Second, the audio may be conformed into a separate .cfa file. The conformed audio is in an interleaved 32-bit floating point format that matches the sequence audio sample rate, to maximize the speed at which Premiere can render audio effects and mix it without sacrificing quality.</p> <p>Both of these files can be generated through sequential calls for audio using imImportAudio7. Audio conforming cannot be disabled through the Premiere menus or API. However, if an importer can provide random-access, uncompressed audio of the clip, Premiere will not conform the audio. All compressed audio data must be conformed.</p> <p>Specifically, it is important to set these flags to avoid conforming: imImportInfoRec.avoidAudioConform = kPrTrue; imFileInfoRec8.accessModes |= kRandomAccessImport;</p> <p>Starting in CS5.5, peak audio data can also optionally be provided by the importer, if the importer implements a faster way to read the peak audio data from the clip. By setting imImportInfoRec. canProvidePeakAudio to non-zero, the importer will be sent imGetPeakAudio whenever this data is requested. Starting in CS6, if an importer wants to provide peak audio data on a clip-by-clip basis, it can set imFileInfoRec8.canProvidePeakData accordingly.</p> <p>The location of the .cfa and .pek files is determined by the user-specified path in Edit &gt; Preferences &gt; Media &gt; Media Cache Files. When the project is closed, the files will be cleaned up. If the source clip is not saved in the project, the associated conformed audio files will be deleted.</p> <p>Importers can get audio for scrubbing, playing and other timeline operations before conforming has completed, resulting in responsive audio feedback during conforming. To do this, they must support both random access and sequential access audio importing. The <code>kSeparateSequentialAudio</code> access mode should be set in imFileInfoRec8.accessModes.</p>"},{"location":"importers/getting-started/#quality-levels","title":"Quality Levels","text":"<p>Importers can optionally support two different quality modes, with the imDraftMode flag that is used in imImportImageRec.</p>"},{"location":"importers/getting-started/#closed-captioning","title":"Closed Captioning","text":"<p>Starting in CC, importers can support closed captioning that is embedded in the source media. The built-in QuickTime importer provides this capability.</p> <p>Note</p> <p>Premiere Pro can also import and export captions in a sidecar file (e.g. .mcc, .scc, or .xml) alongside any media file, regardless of the media file format. This does not require any specific work on the importer side.</p> <p>To support embedded closed captioning, set <code>imImportInfoRec.canSupportClosedCaptions</code> to true. The importer should handle the following selectors: <code>imInitiateAsyncClosedCaptionScan</code>, <code>imGetNextClosedCaption</code>, and imCompleteAsyncClosedCaptionScan.</p> <p>imInitiateAsyncClosedCaptionScan will be called for every file that is imported through an importer that sets canSupportClosedCaptions to true. The plugin should at this point determine whether or not there is closed captioning data for this file. If not, then the plugin should simply return imNoCaptions, and everything is done. If the plugin didn't report an error for that call, then imGetNextClosedCaption will be called until the plugin returns imNoCaptions. After which, imCompleteAsyncClosedCaptionScan will be called informing the importer that the host is done requesting captions.</p> <p>Both imGetNextClosedCaption and imCompleteAsyncClosedCaptionScan may be called from a different thread from which <code>imInitiateAsyncClosedCaptionScan</code> was originally called. To help facilitate this, <code>outAsyncCaptionScanPrivateData</code> during <code>imInitiateAsyncClosedCaptionScan</code> can be allocated by the importer to be used for the upcoming calls, which can be deallocated</p> <p>in imCompleteAsyncClosedCaptionScan.</p>"},{"location":"importers/getting-started/#n-channel-audio","title":"N-Channel Audio","text":"<p>Starting in CC, for audio configurations beyond mono, stereo, and 5.1, an importer can specify a channel layout by implementing the new imGetAudioChannelLayout selector. Otherwise the channel layout will be assumed to be discrete. For support prior to CC, the importer needs to import them as multiple streams.</p>"},{"location":"importers/getting-started/#multiple-streams","title":"Multiple Streams","text":"<p>Importers can support multiple streams of audio and/or video. For most filetypes with a single video and a simple audio configuration (mono, stereo, or 5.1), only a single stream is necessary. Multiple streams can be useful for stereoscopic footage, layered file types (like Photoshop PSD files), or clips with complex audio configuration (such as 4 mono audio channels). The following describes the general case of multiple streams. For stereoscopic importers, please refer to the description further down.</p> <p>An importer describes each stream one-by-one during iterative calls to imGetInfo8. In response to each call, the importer describes one stream, and returns imIterateStreams, until it reaches the last stream, and then it returns imBadStreamIndex. Set imFileInfoRec8-&gt;streamsAsComp = kPrFalse, so that the set of streams appear as a single clip within Premiere Pro.</p> <p>In imGetInfo8, save streamIdx in privateData, to have access to it later. That way, when called in imImportAudio7, the importer will know which stream of audio to pass back.</p> <p>See the sample code in the SDK File Importer, which can be turned on by uncommenting back in the MULTISTREAM_AUDIO_TESTING define in SDK_File_Import.h.</p>"},{"location":"importers/getting-started/#stereoscopic-video","title":"Stereoscopic Video","text":"<p>First, an importer must advertise multiple video streams. During imGetInfo8, the host passes in the stream index in imFileInfoRec8.streamIdx. If the clip has a second stream, then on index 0 the importer should return imIterateStreams and it will be called again for the second stream. On the second one you return imNoErr, as before. The nice thing is that this works in Premiere Pro CS5.5 and earlier - when two video streams are present, on import, they will just appear as two different project items.</p> <p>Prior to CS6, an importer would need to have a prefs structure and on imGetInfo8 it would need to store the stream index in that structure. With CS6 this is a lot simpler. Now, in the <code>imSourceVideoRec</code> (passed in imGetSourceVideo, and part of the aiFrameRequest for async importers), the host application passes in the currentStreamIndex (in the value formerly</p> <p>known as unused1). This makes it much easier to just check when providing a PPix and differentiate the two streams.</p> <p>Now, obviously, it is not desirable to have two project items. In order to get them merged, an importer needs to label the streams (the logic here is pretty simple, if there are multiple labeled video streams, it will appear as a single project item, and all views on that item will show the first stream). For this there is a new selector: imQueryStreamLabel. The struct passed to the importer has its privateData, prefs data, and the stream index, and the label needs to be passed back in a PrSDKString. If you're not familiar with PrSDKStringSuite, it's fairly obvious how to use. In this case you'll be allocating a string, passing either UTF-8 data, or UTF-16 data.</p> <p>In PrSDKStreamLabel.h we define two labels: kPrSDK_StreamLabelStereoscopicLeft and kPrSDKStreamLabel_Stereoscopic_Right. By convention, we expect Left to be stream 0 and Right to be stream 1. This is purely for consistency - if we have multiple stereo clips from multiple importers, we would want the thumbnails to all be consistent. If we stick to this convention, then the thumbnails will all be Left.</p> <p>To integrate well with other third-parties, we strongly encourage using these labels for stereoscopic importers. However, the entire StreamLabel mechanism is intentionally left quite general. You could use whatever labels you want in your importers and effects, and when you request the video segments you can pass whatever label you would like. If you have other uses for this, we would be interested to hear about them, and we would welcome any bug reports.</p>"},{"location":"importers/getting-started/#project-manager-support","title":"Project Manager Support","text":"<p>The Project Manager in Premiere Pro allows users to archive projects, trim out unused media, or collect all source files to a single location. Importers are the most knowledgable about the sources they work with. So Premiere Pro doesn't make any assumptions about the source media, but instead relies on the importers to handle the trimming and file size estimates. Only importers that specifically support trimming will trim and not copy when the Project Manager trims projects.</p> <p>To support trimming, importers will want to set the canCalcSizes and canTrim flags during imInit, and support imCalcSize8, imCheckTrim8, and imTrimFile8.</p> <p>If the each clip has more than one source file (such as audio channels in separate files), the importer should also set canCopy and support imCopyFile. Otherwise, the Project Manager will not know about the other source files.</p> <p>External files, such as textures, logos, etc. that are used by an importer instance but do not appear as footage in Project panel, should be registered with Premiere Pro using the File Registration Suite during imGetInfo8 or imGetPrefs8. Registered files will be taken into account when trimming or copying a project using the Project Manager.</p>"},{"location":"importers/getting-started/#creating-a-custom-importer","title":"Creating a Custom Importer","text":"<p>This variant of the importer API allows importers to dynamically create disk-based media while working within Premiere. A titler plugin or similar should use this API. Once your clip is created, it is treated like any other standard file and will receive all standard missing file handling.</p> <p>A Custom Importer must do the following:</p> <ul> <li>Set the following flags true in imImportInfoRec; canCreate, canOpen, addToMenu, noFile. This tells Premiere your plugin will create a clip on disk at imGetPrefs8 time.</li> <li>To determine when you need to create a new clip vs. modify an existing clip, check the <code>imFileAccessRec</code> filename. If it's identical to the plugin display name (as set in the PiPL), create a new clip; otherwise modify the clip.</li> <li>If the user cancels from your dialog when creating a new clip, return imCancel.</li> <li>If the clip is modified, the importer needs to do a few things for Premiere to pick up the changes. Put your file access information in the supplied <code>imFileAccessRec</code>. Premiere will use this data to reference your clip from now on. Close the file handle after you create it. Return imSetFile after creating a file handle in imGetPrefs8., and call RefreshFileAsync() in the Importer</li> </ul> <p>File Manager Suite to notify Premiere that the clip has been modified. Premiere will immediately call you to open the file and return a valid imFileRef. Respond to imOpenFile8, imQuietFile, imCloseFile at a minimum.</p>"},{"location":"importers/getting-started/#real-time-rolling-and-crawling-titles","title":"Real-Time Rolling and Crawling Titles","text":"<p>For RT rolls and crawls, a player and importer must be specially designed to work together. An importer can implement the appropriate functionality, but it is up to the player to take advantage of it.</p> <p>Importers can make image data available for rolling and crawling titles, using <code>imImageInfoRec.isRollCrawl</code>. If the importer sets it to non-zero, this declares that the image is a title or other image that does roll/crawl, and that the importer supports the imGetRollCrawlInfo and imRollCrawlRenderPage selectors. imGetRollCrawlInfo is used to get info on the roll/crawl from the importer, and imRollCrawlRenderPage is used to get a rendered page of the roll/crawl.</p>"},{"location":"importers/getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"importers/getting-started/#how-to-get-first-crack-at-a-file","title":"How to Get First Crack at a File","text":"<p>To get the first opportunity to import a filetype also supported by a built-in importer (e.g. MPEG, AVI, QuickTime, etc), provide a different subtype and classID in order for your importer to be called for the types of files you support. imImportInfoRec.priority must be higher than any of the other importers for that filetype. Set this value to 100 or higher to override all built-in importers. Premiere Pro has more than one type of AVI importer and MPEG importer, which use this same prioritization mechanism. So your importer can override all of them and get the first shot at a filetype.</p> <p>Just because you want to take over handling some files of a given filetype, it doesn't mean you have to handle all of them. To defer an unsupported subtype to a lower priority importer, return imBadFile during imOpenFile8 or imGetInfo8. See the Media Abstraction chapter for more information on filetypes, subtypes, and classIDs.</p>"},{"location":"importers/getting-started/#format-repeated-in-menu","title":"Format repeated in menu?","text":"<p>To avoid having your importer appear multiple times in the file formats supported pop-up list, fill out the formatName, formatShortName and platform extension once and only once during your imGetIndFormat.</p>"},{"location":"importers/getting-started/#resources","title":"Resources","text":"<p>Importers must contain a IMPT resource. Premiere uses this to identify the plugin as an importer. Also, depending on the type of importer (standard, synthetic, or custom), a PiPL may be required.</p>"},{"location":"importers/getting-started/#entry-point","title":"Entry Point","text":"<pre><code>csSDK_int32 xImportEntry (\n  csSDK_int32  selector,\n  imStdParms   *stdParms,\n  void         *param1,\n  void         *param2)\n</code></pre> <p>selector is the action Premiere wants the importer to perform. stdParms provides callbacks to obtain additional information from Premiere or to have Premiere perform tasks.</p> <p><code>param1</code> and <code>param2</code> vary with the selector; they may contain a specific value or a pointer to a structure. Return imNoErr if successful, or an appropriate return code.</p>"},{"location":"importers/getting-started/#standard-parameters","title":"Standard Parameters","text":"<p>A pointer to this structure is sent from the host application to the plugin with every selector.</p> <pre><code>typedef struct {\n  csSDK_int32      imInterfaceVer;\n  imCallbackFuncs  *funcs;\n  piSuitesPtr      piSuites;\n} imStdParms;\n</code></pre> Member Description <code>imInterfaceVer</code> Importer API version<ul><li>Premiere Pro CC 2014 - <code>IMPORTMOD_VERSION_15</code></li><li>Premiere Pro CC - <code>IMPORTMOD_VERSION_14</code></li><li>Premiere Pro CS6.0.2 - <code>IMPORTMOD_VERSION_13</code></li><li>Premiere Pro CS6 - <code>IMPORTMOD_VERSION_12</code></li><li>Premiere Pro CS5.5 - <code>IMPORTMOD_VERSION_11</code></li><li>Premiere Pro CS5 - <code>IMPORTMOD_VERSION_10</code></li><li>Premiere Pro CS4 - <code>IMPORTMOD_VERSION_9</code></li></ul> <code>funcs</code> Pointers to callbacks for importers <code>piSuites</code> Pointer to universal callback suites"},{"location":"importers/getting-started/#importer-specific-callbacks","title":"Importer-Specific Callbacks","text":"<pre><code>typedef struct {\n  ClassDataFuncsPtr  classFuncs;\n  csSDK_int32        unused1;\n  csSDK_int32        unused2;\n} imCallbackFuncs;\n\ntypedef csSDK_int32 (*importProgressFunc){\n  csSDK_int32  partDone;\n  csSDK_int32  totalToDo;\nvoid *trimCallbackID};\n</code></pre> Function Description <code>classFuncs</code> See ClassData functions. <code>importProgressFunc</code> Available in <code>imSaveFileRec</code> and <code>imTrimFileRec</code> during imSaveFile8 and imTrimFile8.Callback function pointer for use during project archiving or trimming to call into Premiere and update the progress bar and check for cancellation.Either <code>imProgressAbort</code> or <code>imProgressCon</code> tinue will be returned.The trimCallbackID parameter is passed in the same structures."},{"location":"importers/importers/","title":"Importers","text":"<p>Importers provide video, audio and/or closed captioning from the media source. This source can be a single file, a set of files, a communication link between another application, etc.</p> <p>Standard importers appear as choices in the File &gt; Import dialog, in the Files of type drop-down menu. Importers can support movies, still images, series of still images, and/or audio. If your importer provides enhanced support for a format already supported by another importer that ships with Premiere, set a high value in imImportInfoRec.priority to give your importer the first opportunity to handle the file.</p> <p>Synthetic importers synthesize source material, rather than reading from disk. They appear in the File &gt; New menu.</p> <p>Custom importers are a special type of synthetic importer, implemented to better support titlers. Custom importers can create files on disk; synthetic importers don't. Custom importers either create new media or import existing media handled by the importer. After the file is created, the media is treated like a standard file by the host application. Additionally, the media can be modified by the importer when the user double-clicks on it in the Project Panel.</p> Importer Type Reads from disk Creates clips Menu Location Standard Yes No File &gt; Import Synthetic No Yes File &gt; New Custom Yes Yes File &gt; New File &gt; Import <p>If you've never developed an importer before, you can skip What's New, and go directly to Getting Started.</p>"},{"location":"importers/return-codes/","title":"Return Codes","text":"Return Code Reason <code>imNoErr</code> Operation has completed without error. <code>imTooWide</code> File dimensions too large. <code>imBadFile</code> Bad file format.To defer an unsupported subtype to a lower priority importer, return this during <code>imOpenFile8</code> or <code>imGetInfo8</code>. <code>imUnsupported</code> Unsupported selector. <code>imMemErr</code> Memory error. <code>imOtherErr</code> Unknown error. <code>imNoContent</code> No audio or video. <code>imBadRate</code> Bad audio rate. <code>imBadCompression</code> Bad compression. <code>imBadCodec</code> Codec not found. <code>imNotFlat</code> Unflattened QuickTime movie. <code>imBadSndComp</code> Bad sound compression. <code>imNoTimecode</code> Timecode supported, but not found. <code>imMissingComponent</code> Missing component needed to open the file. <code>imSaveErr</code> Error saving file. <code>imDeleteErr</code> Error deleting file. <code>imNotFoundErr</code> The requested metadata chunk was not found. <code>imSetFile</code> Return this from <code>imGetPrefs8</code> only if you are a custom importer and you need Premiere to alter it's file access information (e.g. a new path or filename is created). <code>imIterateStreams</code> Return from <code>imGetInfo8</code> to indicate that there are more streams to describe.Premiere will send <code>imGetInfo8</code> for the next stream. <code>imBadStreamIndex</code> Return from <code>imGetInfo8</code> after interating through streams to indicate that there are no more streams to describe. <code>imCantTrim</code> Return from <code>imCheckTrim</code> if the file cannot be trimmed by the importer. <code>imDiskFull</code> Return from <code>imTrimFile8</code> if there is not enough space to complete the trim operation. <code>imDiskErr</code> Return from <code>imTrimFile8</code> if there is a general disk or I/O error during the trim operation. <code>imFileShareViolation</code> Return from <code>imOpenFile8</code> if file cannot be opened due to another process having exclusive read access <code>imIterateFrameSizes</code> Return from <code>imGetPreferredFrameSize</code>, to be called again to describe more frame sizes for a particular pixel format. <code>imMediaPending</code> Return from <code>imGetSourceVideo</code> or <code>imCreateAsyncImporter</code> if the importer is still processing the file and cannot return video frames yet. <code>imDRMControlled</code> Return from <code>imOpenFile8</code> if the file cannot be opened because it is under rights management. <code>imActivationFailed</code> Activation of a component failed (usually due to user cancellation).This is used by Premiere Elements. <code>imFrameNotFound</code> New in CS4. Return if an importer could not find the requested frame (typically used with async importers) <code>imBadHeader</code> New in CS5. The file cannot be opened because of a header error <code>imUnsupportedCompression</code> New in CS5. The file has a compression type that the importer does not support <code>imFileOpenFailed</code> New in CS5. The importer was unable to open the file on disk <code>imFileHasNoImportableStreams</code> New in CS5. The file has no audio or video stream <code>imFileReadFailed</code> New in CS5. A read from an open file failed <code>imUnsupportedAudioFormat</code> New in CS5. The importer cannot import something in the audio format <code>imUnsupportedVideoBitDepth</code> New in CS5. The video bit depth of this file is unsupported by the importer <code>imDecompressionError</code> New in CS5. The importer hit an error decompressing the audio or video <code>imInvalidPreferences</code> New in CS5. Invalid prefs data was passed to the importer <code>inFileNotAvailable</code> New in CS5. Return from <code>imQueryContentState</code> if the file/stream is no longer available because it is offline or deleted <code>imRequiresProtectedContent</code> New in CS5.5. Return from <code>imInit</code> if the importer depends on a library that has not been activated yet. <code>imNoCaptions</code> New in CC. Return from <code>imInitiateAsyncClosedCaptionScan</code> if the clip has no closed captions, or return from <code>imGetNextClosedCaption</code> when there are no more captions. <code>imCancel</code> Return from <code>imGetPrefs8</code> if user cancels or the plugin cannot open the file (custom/synthetic importer). <code>imBadFormatIndex</code> Return this when given an out of range format index, and from <code>imGetIndFormat</code> when plugin has no more formats to enumerate. <code>imIsCacheable</code> Return from <code>imInit</code> if a plugin does not need to be called to initialize every time Premiere is launched.This will help reduce the time to launch the application."},{"location":"importers/selector-descriptions/","title":"Selector Descriptions","text":"<p>This section provides a brief overview of each selector and highlights implementation issues.</p> <p>Additional implementation details are at the end of the chapter.</p>"},{"location":"importers/selector-descriptions/#iminit","title":"imInit","text":"<ul> <li>param1 - imImportInfoRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Sent during application startup.</p> <p>Describe the importer's capabilities in the imImportInfoRec; all options are false by default.</p> <p>The similarly named flags in imIndFormatRec.flags are obsolete and should not be used.</p> <p>Set hasSetup to kPrTrue if the importer has a setup dialog, and setupOnDblClk to kPrTrue to have that dialog display when the user double-clicks a file in the Project Panel; Premiere throws away any preview files generated for a file imported with this setting, even if no setup dialog is displayed.</p> <p>Return imIsCacheable from imInit if a plugin does not need to be called to initialize every time Premiere launched.</p> <p>This will help reduce the time to launch the application.</p>"},{"location":"importers/selector-descriptions/#synthetic-importers","title":"Synthetic Importers","text":"<p>Setting <code>noFile</code> to <code>kPrTrue</code> indicates that the importer is synthetic.</p> <p>Set <code>addToMenu</code> to <code>kPrTrue</code> to add the importer to the File &gt; New menu.</p>"},{"location":"importers/selector-descriptions/#custom-importers","title":"Custom Importers","text":"<p>To create a custom importer, the following capabilities must be set.</p> <p>See Additional Details for more info on custom importers.</p> <pre><code>noFile    = kPrTrue;\nhasSetup  = kPrTrue;\ncanOpen   = kPrTrue;\ncanCreate = kPrTrue;\naddToMenu = imMenuNew;\n</code></pre>"},{"location":"importers/selector-descriptions/#imshutdown","title":"imShutdown","text":"<ul> <li>param1 - <code>unused</code></li> <li>param2 - <code>unused</code></li> </ul> <p>Release all resources and perform any other necessary clean-up; sent when Premiere quits.</p>"},{"location":"importers/selector-descriptions/#imgetindformat","title":"imGetIndFormat","text":"<ul> <li>param1 - <code>(int) index</code></li> <li>param2 - imIndFormatRec*</li> </ul> <p>Sent repeatedly, immediately after imInit; enumerate the filetypes the plugin supports by populating the imIndFormatRec.</p> <p>When finished, return imBadFormatIndex.</p> <p>imIndFormatRec.flags are obsolete and should not be used.</p>"},{"location":"importers/selector-descriptions/#synthetic-importer-selectors","title":"Synthetic Importer selectors","text":"<p>Because they have no file, synthetic importers only need to respond with the filetype established in their resource.</p> <p>Create a separate plugin for each synthetic file type.</p>"},{"location":"importers/selector-descriptions/#imgetsupports8","title":"imGetSupports8","text":"<ul> <li>param1 - <code>unused</code></li> <li>param2 - <code>unused</code></li> </ul> <p>A plugin that supports the Premiere Pro 2.0 API (and beyond) must return <code>malSupports8</code>.</p>"},{"location":"importers/selector-descriptions/#imgetsupports7","title":"imGetSupports7","text":"<ul> <li>param1 - <code>unused</code></li> <li>param2 - <code>unused</code></li> </ul> <p>A plugin that supports the Premiere Pro 1.0 API (and beyond) must return <code>malSupports7</code>.</p>"},{"location":"importers/selector-descriptions/#imgetinfo8","title":"imGetInfo8","text":"<ul> <li>param1 - imFileAccessRec8*</li> <li>param2 - imFileInfoRec8*</li> </ul> <p>Describe a clip, or a single stream of a clip if the clip has multiple streams.</p> <p>Called when a specific file is instantiated.</p> <p>Importer checks file validity, optionally allocates file instance data, and describes the properties of the file being imported by populating the imFileInfoRec8.</p>"},{"location":"importers/selector-descriptions/#synthetic-importers_1","title":"Synthetic Importers","text":"<p>You can create a still frame, a movie of a set duration, or an 'infinite' length movie, but cannot change the properties of a synthetic file once imported.</p>"},{"location":"importers/selector-descriptions/#imclosefile","title":"imCloseFile","text":"<ul> <li>param1 - imFileRef*</li> <li>param2 - <code>(void*) PrivateData**</code></li> </ul> <p>The specified file is no longer required; dispose of <code>privateData</code>.</p> <p>Only sent if privateData was allocated during <code>imGetInfo8</code>.</p>"},{"location":"importers/selector-descriptions/#imgetindpixelformat","title":"imGetIndPixelFormat","text":"<ul> <li>param1 - <code>(int) index</code></li> <li>param2 - imIndPixelFormatRec*</li> </ul> <p>New optional selector called to enumerate the pixel formats available for a specific file.</p> <p>This message will be sent repeatedly until all formats have been returned.</p> <p>Pixel formats should be returned in the preferred order that the importer supports.</p> <p>The Importer should return imBadFormatIndex after all formats have been enumerated.</p> <p>imUnsupported should be returned on the first call if only yawn BGRA_4444_8u is supported.</p> <p>What pixel formats should you support? Keep it real.</p> <p>Just return the pixel format that most closely matches the data stored in your file.</p> <p>If decoding to two or more formats can be done at about the same speed, declare support for both, but favor any pixel formats that are more compact, to save on memory and bandwidth.</p>"},{"location":"importers/selector-descriptions/#imgetpreferredframesize","title":"imGetPreferredFrameSize","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imPreferredFrameSizeRec*</li> </ul> <p>Provide the frame sizes preferred by the importer.</p>"},{"location":"importers/selector-descriptions/#imselectclipframedescriptor","title":"imSelectClipFrameDescriptor","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imClipFrameDescriptorRec*</li> </ul> <p>New in Premiere Pro CC 2014.</p> <p>If the importer can provide multiple formats, describe the format it will provide here.</p> <p>This allows importers to change pixel formats based on criteria like enabled hardware and other source settings, such as HDR.</p>"},{"location":"importers/selector-descriptions/#imgetsourcevideo","title":"imGetSourceVideo","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imSourceVideoRec*</li> </ul> <p>Get the host an unscaled frame of video.</p> <p>This selector will be sent instead of <code>imImportImage</code> if supportsGetSourceVideo is set to true during <code>imGetInfo8</code>.</p>"},{"location":"importers/selector-descriptions/#imcreateasyncimporter","title":"imCreateAsyncImporter","text":"<ul> <li>param1 - imAsyncImporterCreationRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Create an asynchronous importer object using the data provided, and store it in <code>imAsyncImporterCreationRec</code>.</p>"},{"location":"importers/selector-descriptions/#imimportimage","title":"imImportImage","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imImportImageRec*</li> </ul> <p>Note</p> <p>In most cases, <code>imGetSourceVideo</code> is the better choice.</p> <p>Before going down this route, read the discussion here.</p> <p>Give the host a frame of video; populate the imImportImageRec buffer with pixel data, or (if you've set canDraw to true during <code>imInit</code>) draw to the screen in the provided window using platform-specific calls to do so.</p> <p>You must scale the image data to fit the window; Premiere relies on the import module for properly scaled frames.</p>"},{"location":"importers/selector-descriptions/#imimportaudio7","title":"imImportAudio7","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imImportAudioRec7*</li> </ul> <p>Replacement for <code>imImportAudio</code> that uses new <code>imAudioInfoRec7</code>.</p> <p>Called to import audio using the new 32-bit float, uninterleaved audio format.</p> <p>Fill <code>imImportAudioRec7-&gt;buffer</code> with the number of sample frames specified in <code>imImportAudioRec7-&gt;size</code>, starting from <code>imImportAudioRec7-&gt;position</code>.</p> <p>Always return 32-bit float, uninterleaved samples as described in Universals.</p> <p>You may use the calls in the Audio Suite to do some common conversions.</p>"},{"location":"importers/selector-descriptions/#imgetprefs8","title":"imGetPrefs8","text":"<ul> <li>param1 - imFileAccessRec8*</li> <li>param2 - imGetPrefsRec*</li> </ul> <p>Only sent if clip filetype uses a setup dialog within Premiere.</p> <p>Premiere sends this selector when the user imports (or creates, if synthetic) a file of your type, or when double-clicking on an existing clip.</p> <p>You must have set <code>hasSetup = true</code> during <code>imInit</code> to receive this selector.</p> <p>Storing preferences is a two step process.</p> <p>If the pointer in <code>imGetPrefsRec.prefs</code> is <code>NULL</code>, set prefsLength to the size of your preferences structure and return <code>imNoErr</code>.</p> <p>Premiere sends <code>imGetPrefs</code> again; display your dialog, and pass the preferences pointer back in <code>imGetPrefsRec.prefs</code>.</p> <p>Starting in Premiere Pro 1.5, the importer can get a frame from the timeline beneath the current clip or timeline location.</p> <p>This is useful for titler plugins.</p> <p>Use the <code>getPreviewFrameEx</code> callback with the time given by <code>TDB_TimeRecord</code> <code>tdbTimelocation</code> in <code>imGetPrefsRec</code>.</p>"},{"location":"importers/selector-descriptions/#synthetic-importers_2","title":"Synthetic Importers","text":"<p>Synthetic importers can specify the displayable name by changing the <code>newfilename</code> member of <code>imFileAccessRec8</code>.</p> <p>The first time this selector is sent, the <code>imGetPrefsRec.timelineData</code>, though non-null, contains garbage and should not be used.</p> <p>It will only contain valid information once the user has put the clip into the timeline, and is double-clicking on it.</p>"},{"location":"importers/selector-descriptions/#custom-importers_1","title":"Custom Importers","text":"<p>Custom importers should return imSetFile after successfully creating a new file, storing the file access information in imFileAccessRec8.</p> <p>Premiere will use this data to then ask the importer to open the file it created.</p> <p>See Additional Details for more information on custom importers.</p>"},{"location":"importers/selector-descriptions/#imopenfile8","title":"imOpenFile8","text":"<ul> <li>param1 - imFileRef*</li> <li>param2 - imFileOpenRec8*</li> </ul> <p>Open a file and give Premiere its handle.</p> <p>This selector is sent only if canOpen was set to true during <code>imInit</code>; do so if you generate child files, you need to have read and write access during the Premiere session, or use a custom file system.</p> <p>If you respond to this selector, you must also respond to <code>imQuietFile</code> and <code>imCloseFile</code>.</p> <p>You may additionally need to respond to <code>imDeleteFile</code> and <code>imSaveFile</code>; see Additional Details.</p> <p>Close any child files during <code>imCloseFile</code>.</p> <p>Importers that open their own files should specify how many files they keep open between <code>imOpenFile8</code> and <code>imQuietFile</code> using the new Importer File Manager Suite, if the number is not equal to one.</p> <p>Importers that don't open their own files, or importers that only open a single file should not use this suite.</p> <p>Premiere's File Manager now keeps track of the number of files held open by importers, and limits the number open at a time by closing the least recently used files when too many are open.</p> <p>On Windows, this helps memory usage, but on Mac OS this addresses a whole class of bugs that may occur when too many files are open.</p>"},{"location":"importers/selector-descriptions/#imquietfile","title":"imQuietFile","text":"<ul> <li>param1 - imFileRef*</li> <li>param2 - <code>(void*) PrivateData**</code></li> </ul> <p>Close the file in <code>imFileRef</code>, and release any hardware resources associated with it.</p> <p>Respond to this selector only if <code>canOpen</code> was set to true during imInit.</p> <p>A quieted file is closed (at the OS level), but associated privateData is maintained by Premiere.</p> <p>Do not deallocate <code>privateData</code> in response to <code>imQuietFile</code>; do so during <code>imCloseFile</code>.</p>"},{"location":"importers/selector-descriptions/#imsavefile8","title":"imSaveFile8","text":"<ul> <li>param1 - imSaveFileRec8*</li> <li>param2 - <code>unused</code></li> </ul> <p>Save the file specified in <code>imSaveFileRec8</code>.</p> <p>Only sent if canOpen was set to true during <code>imInit</code>.</p>"},{"location":"importers/selector-descriptions/#imdeletefile","title":"imDeleteFile","text":"<ul> <li>param1 - imDeleteFileRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Request this selector (by setting canDelete to true during <code>imInit</code>) only if you have child files or related files associated with your file.</p> <p>If you have only a single file per clip you do not need to delete your own files.</p> <p>Numbered still file importers do not need to respond to this selector; each file is handled individually.</p>"},{"location":"importers/selector-descriptions/#imcalcsize8","title":"imCalcSize8","text":"<ul> <li>param1 - imCalcSizeRec*</li> <li>param2 - imFileAccessRec8*</li> </ul> <p>Called before Premiere trims a clip, to get the disk size used by a clip.</p> <p>This selector is called if the importer sets imImportInfoRec.canCalcSizes to non-zero.</p> <p>An importer should support this call if it uses a tree of files represented as one top-level file to Premiere.</p> <p>The importer should calculate either the trimmed or current size of the file and return it.</p> <p>If the <code>trimIn</code> and <code>duration</code> are set to zero, Premiere is asking for the current size of the file.</p> <p>If the <code>trimIn</code> and <code>duration</code> are valid values, Premiere is asking for the trimmed size.</p>"},{"location":"importers/selector-descriptions/#imchecktrim8","title":"imCheckTrim8","text":"<ul> <li>param1 - imCheckTrimRec*</li> <li>param2 - imFileAccessRec8*</li> </ul> <p>Called before Premiere trims a clip, to check if a clip can be trimmed at the specified boundaries.</p> <p><code>imCheckTrimRec</code> and <code>imFileAccessRec</code> are passed in.</p> <p>The importer examines the proposed trimmed size of the file, and can change the requested in point and duration to new values if the file can only be trimmed at certain locations (for example, at GOP boundaries in MPEG files).</p> <p>If the importer changes the in and duration, the new values must include all the material requested in the original trim request.</p> <p>If an importer does not need to change the in and duration, it may either return imUnsupported, or imNoErr and simply not change the in/duration fields.</p> <p>If the importer does not want the file trimmed (perhaps because the audio or video would be degraded if trimmed at all) it can return imCantTrim and the trim operation will fail and the file will be copied instead.</p> <p>For a file with both audio and video, the selector will be sent several times.</p> <p>The first time, <code>imCheckTrimRec</code> will have both <code>keepAudio</code> and <code>keepVideo</code> set to a non-zero value, and the trim boundaries will represent the entire file, and Premiere is asking if the file can be trimmed at all.</p> <p>If the importer returns an error, it will not be called again.</p> <p>The second time, <code>imCheckTrimRec</code> will have keepAudio set to a non-zero value, and the trim boundaries will represent the audio in and out points in the audio timebase, and Premiere is asking if the audio can be trimmed on these boundaries.</p> <p>The third time, <code>imCheckTrimRec</code> will have keepVideo set to a non-zero value, and the trim boundaries will represent the video in and out points in the video timebase, and Premiere is asking if the video can be trimmed on these boundaries.</p> <p>If either the video or audio boundaries extend further than the other boundaries, Premiere will trim the file at the furthest boundary.</p>"},{"location":"importers/selector-descriptions/#imtrimfile8","title":"imTrimFile8","text":"<ul> <li>param1 - imFileAccessRec8*</li> <li>param2 - imTrimFileRec8*</li> </ul> <p>Called when Premiere trims a clip.</p> <p><code>imFileAccessRec8</code> and <code>imTrimFileRec8</code> are passed in.</p> <p><code>imDiskFull</code> or <code>imDiskErr</code> may be returned if there is an error while trimming.</p> <p>The current file, inPoint, and new duration are given and a destination file path.</p> <p>If a file has video and audio, the trim time is in the video's timebase.</p> <p>For audio only, the trim times are in the audio timebase.</p> <p>A simple callback and <code>callbackID</code> is passed to <code>imTrimFile8</code> and <code>imSaveFile8</code> that allows plugins to query whether or not the user has cancelled the operation.</p> <p>If non-zero (and they can be nil), the callback pointer should be called to check for cancellation.</p> <p>The callback function will return <code>imProgressAbort</code> or <code>imProgressContinue</code>.</p>"},{"location":"importers/selector-descriptions/#imcopyfile","title":"imCopyFile","text":"<ul> <li>param1 - imCopyFileRec*</li> <li>param2 - <code>unused</code></li> </ul> <p><code>imCopyFile</code> is sent rather than <code>imSaveFile</code> to importers that have set <code>imImportInfoRec</code> can Copy when doing a copy operation using the Project Manager.</p> <p>The importer should maintain data on the original file rather than the copy when it returns from the selector.</p>"},{"location":"importers/selector-descriptions/#imretargetaccelerator","title":"imRetargetAccelerator","text":"<ul> <li>param1 - imAcceleratorRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>When the Project Manager copies media and its accelerator, this selector gives an opportunity to update the accelerator to refer to the copied media.</p>"},{"location":"importers/selector-descriptions/#imquerydestinationpath","title":"imQueryDestinationPath","text":"<ul> <li>param1 - imQueryDestinationPathRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>New in CS5.</p> <p>This allows the plugin to modify the path that will be used for a trimmed clip, so the trimmed project is written with the correct path.</p>"},{"location":"importers/selector-descriptions/#iminitiateasyncclosedcaptionscan","title":"imInitiateAsyncClosedCaptionScan","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imInitiateAsyncClosedCaptionScanRec*</li> </ul> <p>New in CC.</p> <p>Gives a chance for the importer to allocate private data to be used during the scan for any closed captions embedded in the clip.</p> <p>If there are no captions, return imNoCaptions.</p>"},{"location":"importers/selector-descriptions/#imgetnextclosedcaption","title":"imGetNextClosedCaption","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imGetNextClosedCaptionRec*</li> </ul> <p>New in CC.</p> <p>Called iteratively, each time asking the importer for a single closed caption embedded in the clip.</p> <p>After returning the last caption, return imNoCaptions to signal the end of the scan.</p>"},{"location":"importers/selector-descriptions/#imcompleteasyncclosedcaptionscan","title":"imCompleteAsyncClosedCaptionScan","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imCompleteAsyncClosedCaptionScanRec*</li> </ul> <p>New in CC.</p> <p>Called to cleanup any temporary data used while getting closed captions embedded in the clip, and to see if the scan completed without error.</p>"},{"location":"importers/selector-descriptions/#imanalysis","title":"imAnalysis","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imAnalysisRec*</li> </ul> <p>Provide information about the file in the imAnalysisRec; this is sent when the user views the Properties dialog for your file.</p> <p>Premiere displays a dialog with information about the file, including the text you provide.</p>"},{"location":"importers/selector-descriptions/#imdatarateanalysis","title":"imDataRateAnalysis","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imDataRateAnalysisRec*</li> </ul> <p>Give Premiere a data rate analysis of the file.</p> <p>Sent when the user presses the Data Rate button in the Properties dialog, and is enabled only if hasDataRate was true in the imFileInfoRec returned during imGetInfo.</p> <p>Premiere generates a data rate analysis graph from the data provided.</p>"},{"location":"importers/selector-descriptions/#imgettimeinfo8","title":"imGetTimeInfo8","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imTimeInfoRec8*</li> </ul> <p>Read any embedded timecode data in the file.</p> <p>Supercedes <code>imGetTimeInfo</code>.</p>"},{"location":"importers/selector-descriptions/#imsettimeinfo8","title":"imSetTimeInfo8","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imTimeInfoRec8*</li> </ul> <p>Sent after a capture completes, where timecode was provided by the recorder or device controller.</p> <p>Use this to write timecode data and timecode rate to your file.</p> <p>See Universals for more information on time in Premiere.</p> <p>Supercedes <code>imSetTimeInfo</code>.</p> <p>Timecode rate is important for files that have timecode, but not an implicit frame rate, or where the sampling rate might differ from the timecode rate.</p> <p>For example, audio captured from a tape uses the video's frame rate for timecode, although its sampling rate is not equal to the timecode rate.</p> <p>Another example is capturing a still from tape, which could be stamped with timecode, yet not have a media frame rate.</p>"},{"location":"importers/selector-descriptions/#imgetfileattributes","title":"imGetFileAttributes","text":"<ul> <li>param1 - imFileAttributesRec*</li> </ul> <p>Optional.</p> <p><code>Pass back the creation date stamp in imFileAttributesRec.</code></p>"},{"location":"importers/selector-descriptions/#imgetmetadata","title":"imGetMetaData","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imMetaDataRec*</li> </ul> <p>Called to get a metadata chunk specified by a fourcc code.</p> <p>If imMetaDataRec-&gt;buffer is null, the plugin should set buffersize to the required buffer size and return imNoErr.</p> <p>Premiere will then call again with the appropriate buffer already allocated.</p>"},{"location":"importers/selector-descriptions/#imsetmetadata","title":"imSetMetaData","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imMetaDataRec*</li> </ul> <p>Called to add a metadata chunk specified by a fourcc code.</p>"},{"location":"importers/selector-descriptions/#imdeferredprocessing","title":"imDeferredProcessing","text":"<ul> <li>param1 - imDeferredProcessingRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>Describe the current progress of the deferred processing on the clip.</p>"},{"location":"importers/selector-descriptions/#imgetaudiochannellayout","title":"imGetAudioChannelLayout","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imGetAudioChannelLayoutRec*</li> </ul> <p>New in CC.</p> <p>Called to get the audio channel layout in the file.</p>"},{"location":"importers/selector-descriptions/#imgetpeakaudio","title":"imGetPeakAudio","text":"<ul> <li>param1 - imFileRef</li> <li>param2 - imPeakAudioRec*</li> </ul> <p>Optional selector allows Premiere to get audio peak data directly from the importer.</p> <p>This is used for synthetic clips longer than five minutes.</p> <p>Providing peak data can significantly improve waveform rendering performance when the user views audio waveform of the clip in the Source Monitor.</p> <p>The values provided are <code>floats</code>, in the range 0.0 to 1.0 in amplitude. There is an array which has an array of <code>float *</code> for each audio channel the importer reported for this stream. The <code>float *</code> point to <code>float[inNumSampleFrames]</code> which needs to be filled in by the importer. The <code>inSampleRate</code> is the sample rate of the returned data; in the case that <code>inNumSampleFrame = 1000</code> and <code>inSampleRate = 10</code>, the importer would fill in 1000 min values and 1000 max values per channel, with 10 values per second of original audio.</p>"},{"location":"importers/selector-descriptions/#imquerycontentstate","title":"imQueryContentState","text":"<ul> <li>param1 - imQueryContentStateRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>New in CS5.</p> <p>This is used by streaming importers and folder based importers (P2, XDCAM, etc) that have multiple files that comprise the content.</p> <p>If an importer doesn't support the selector then the host checks the last modification time for the main file.</p>"},{"location":"importers/selector-descriptions/#imquerystreamlabel","title":"imQueryStreamLabel","text":"<ul> <li>param1 - imQueryStreamLabelRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>New in CS6.</p> <p>This is used by stereoscopic importers to specify which stream IDs represent the left and right eyes.</p>"},{"location":"importers/selector-descriptions/#imgetsubtypenames","title":"imGetSubTypeNames","text":"<ul> <li>param1 - <code>(csSDK_int32) fileType</code></li> <li>param2 - imSubTypeDescriptionRec*</li> </ul> <p>New optional selector added for After Effects CS3.</p> <p>As of CS4, this info still isn't used in Premiere Pro, but is used in After Effects to display the codec name in the Project Panel.</p> <p>The importer should fill in the codec name for the specific subtype fourcc provided.</p> <p>This selector will be sent repeatedly until names for all subtypes have been requested.</p> <p>The <code>imSubTypeDescriptionRec</code> must be allocated by the importer, and will be released by the plugin host.</p>"},{"location":"importers/selector-descriptions/#imgetindcolorprofile","title":"imGetIndColorProfile","text":"<ul> <li>param1 - <code>(int) index</code></li> <li>param2 - imIndColorProfileRec*</li> </ul> <p>Only sent if the importer has set <code>imImageInfoRec.colorProfileSupport</code> to <code>imColorProfileSupport_Fixed</code>.</p> <p>This selector is sent iteratively for the importer to provide a description of each color profile supported by the clip.</p> <p>After all color profiles have been described, return a non-zero value.</p>"},{"location":"importers/selector-descriptions/#imgetindcolorspace","title":"imGetIndColorSpace","text":"<ul> <li>param1 - <code>(int) index</code></li> <li>param2 - imIndColorSpaceRec*</li> </ul> <p>This is new selector for enumerating color spaces of media.</p> <p>Only sent if the importer has set <code>imImageInfoRec.colorSpaceSupport</code> to <code>imColorSpaceSupport_Fixed</code>.</p> <p>This selector is sent iteratively for the importer to provide a description of each color space supported by the clip.</p> <p>After all color spaces have been described, return a non-zero value.</p>"},{"location":"importers/selector-descriptions/#imqueryinputfilelist","title":"imQueryInputFileList","text":"<ul> <li>param1 - imQueryInputFileListRec*</li> <li>param2 - <code>unused</code></li> </ul> <p>New for After Effects CS6; not used in Premiere Pro.</p> <p>If an importer supports media that uses more than a single file (i.e.</p> <p>a file structure with seperate files for metadata, or separate video and audio files), this is the way the importer can specify all of its source files, in order to support Collect Files in After Effects.</p> <p>In <code>imImportInfoRec</code>, a new member, <code>canProvideFileList</code>, specifies whether the importer can provide a list of all files for a copy operation.</p> <p>If the importer does not implement this selector, the host will assume the media just uses a single file at the original imported media path.</p>"},{"location":"importers/selector-descriptions/#imgetembeddedlut","title":"imGetEmbeddedLUT","text":"<p>This is a selector for enumerating the LUTs embedded in the media.</p> <ul> <li>param1 - <code>(int) index</code>.</li> <li>param2 - EmbeddedLUTRec*</li> </ul> <p>Sent if Importer reported that it has embedded LUT. The first time it is called, the inDestinationBuffer will be NULL. Fill in the required size for the buffer, set the correct space type, and Premiere Pro will call your importer back with enough memory.</p>"},{"location":"importers/selector-table/","title":"Selector Table","text":"<p>Before implementing a handler for a certain selector, make sure that it is really necessary for your importer. Many selectors are optional, and only useful for certain special needs.</p> <p>The Synth column indicates whether or not the selector is applicable to synthetic importers. Custom importers can respond to any of the selectors.</p> Selector param1 param2 Synth imInit imImportInfoRec* unused Yes imShutdown unused unused Yes imGetIndFormat <code>(int) index</code> imIndFormatRec* Yes imGetSupports8 unused unused Yes imGetSupports7 unused unused Yes imGetInfo8 imFileAccessRec8* imFileInfoRec8* Yes imCloseFile imFileRef* <code>(void*) PrivateData**</code> No imGetIndPixelFormat <code>(int) index</code> imIndPixelFormatRec* Yes imGetPreferredFrameSize imPreferredFrameSizeRec* unused Yes imSelectClipFrameDescriptor imFileRef imClipFrameDescriptorRec* Yes imGetSourceVideo imFileRef imSourceVideoRec* Yes imCreateAsyncImporter imAsyncImporterCreationRec* unused Yes imImportImage imFileRef imImportImageRec* Yes imImportAudio7 imFileRef imImportAudioRec7* Yes <code>imResetSequentialAudio</code> imFileRef imImportAudioRec7* Yes <code>imGetSequentialAudio</code> imFileRef imImportAudioRec7* Yes imGetPrefs8 imFileAccessRec8* imGetPrefsRec* Yes imGetEmbeddedLUT <code>(int) index</code> imIndEmbeddedLUTRec* Yes <p>The following selectors are optional, to provide custom file handling:</p> Selector param1 param2 Synth imOpenFile8 imFileRef* imFileOpenRec8* No imQuietFile imFileRef* <code>(void*) PrivateData**</code> No imSaveFile8 imSaveFileRec8* unused No imDeleteFile imDeleteFileRec* unused No <p>The following selectors are optional, for better support copying and trimming files using the Project Manager:</p> Selector param1 param2 Synth imCalcSize8 imCalcSizeRec* imFileAccessRec8* No imCheckTrim8 imCheckTrimRec* imFileAccessRec8* No imTrimFile8 imFileAccessRec8* imTrimFileRec8* No imCopyFile imCopyFileRec* unused No imRetargetAccelerator imAcceleratorRec* unused No imQueryDestinationPath imQueryDestinationPathRec* unused No <p>The following selectors are used for embedded Closed Captioning support:</p> Selector param1 param2 Synth imInitiateAsyncClosedCaptionScan imFileRef imInitiateAsyncClosedCaptionScanRec* No imGetNextClosedCaption imFileRef imGetNextClosedCaptionRec* No imCompleteAsyncClosedCaptionScan imFileRef imCompleteAsyncClosedCaptionScanRec* No <p>The following selectors are optional, useful for a subset of importers:</p> Selector param1 param2 Synth imAnalysis imFileRef imAnalysisRec* Yes imDataRateAnalysis imFileRef imDataRateAnalysisRec* No imGetTimeInfo8 imFileRef imTimeInfoRec8* No imSetTimeInfo8 imFileRef imTimeInfoRec8* No imGetFileAttributes imFileAttributesRec* unused imGetMetaData imFileRef imMetaDataRec* No imSetMetaData imFileRef imMetaDataRec* No <code>imGetRollCrawlInfo</code> <code>imRollCrawlInfoRec*</code> unused Yes <code>imRollCrawlRenderPage</code> <code>rollCrawlRenderRec*</code> unused Yes imDeferredProcessing imDeferredProcessingRec* unused No imGetAudioChannelLayout imFileRef imGetAudioChannelLayoutRec* Yes imGetPeakAudio imFileRef imPeakAudioRec* Yes imQueryContentState imQueryContentStateRec* unused No imQueryStreamLabel imQueryStreamLabelRec* unused Yes imGetIndColorSpace <code>(int) index</code> imIndColorSpaceRec* Yes <p>Used only in After Effects:</p> Selector param1 param2 Synth imGetSubTypeNames <code>(csSDK_int32) fileType</code> imSubTypeDescriptionRec* No imGetIndColorProfile <code>(int) index</code> imIndColorProfileRec* No imQueryInputFileList imQueryInputFileListRec* unused No"},{"location":"importers/structure-descriptions/","title":"Structure Descriptions","text":""},{"location":"importers/structure-descriptions/#imacceleratorrec","title":"imAcceleratorRec","text":"<p>Selector: imRetargetAccelerator</p> <p>Describes the path to the new media and new accelerator created when the Project Manager copies media and its accelerator.</p> <pre><code>typedef struct {\n  const prUTF16Char *inOriginalPath;\n  const prUTF16Char *inAcceleratorPath;\n} imAcceleratorRec;\n</code></pre> Member Description <code>inOriginalPath</code> The unicode path and name of the copied media. <code>inAcceleratorPath</code> The unicode path and name of the copied accelerator."},{"location":"importers/structure-descriptions/#imanalysisrec","title":"imAnalysisRec","text":"<p>Selector: imAnalysis</p> <p>Sending back analysis data is a two step process. First, set buffersize to the size of your character buffer and return imNoErr.</p> <p>Premiere will immediately send <code>imAnalysis</code> again; populate the buffer with text. Previously-stored preferences and privateData are returned in this structure.</p> <pre><code>typedef struct {\n  void         *privatedata;\n  void         *prefs;\n  csSDK_int32  buffersize;\n  char         *buffer;\n  csSDK_int32  *timecodeFormat;\n} imAnalysisRec;\n</code></pre> Member Description <code>privatedata</code> Instance data from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>prefs</code> Clip Source Settings data from <code>imGetPrefs8</code> (setup dialog info). <code>buffersize</code> Set to the desired size and return imNoErr to Premiere, which will re-size and call the plugin again with the <code>imGetPrefs8</code> selector. <code>buffer</code> Text buffer. Terminate lines with line endings (CR and LF). <code>timecodeFormat</code> Preferred timecode format, sent by the host."},{"location":"importers/structure-descriptions/#imasyncimportercreationrec","title":"imAsyncImporterCreationRec","text":"<p>Selector: imCreateAsyncImporter</p> <p>Create an asynchronous importer object using the data provided, and store it here.</p> <pre><code>typedef struct {\n  void                *inPrivateData;\n  void                *inPrefs;\n  AsyncImporterEntry  outAsyncEntry;\n  void                *outAsyncPrivateData;\n}\n</code></pre> Member Description <code>inPrivateData</code> Instance data from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>inPrefs</code> Clip Source Settings from <code>imGetPrefs8</code> (setup dialog info). <code>outAsyncEntry</code> Provide the entry point for async selectors sent to the asynchronous importer object. <code>outAsyncPrivateData</code> <code>PrivateData</code> for the asynchronous importer object."},{"location":"importers/structure-descriptions/#imaudioinforec7","title":"imAudioInfoRec7","text":"<p>Selector: imGetInfo8 (member of imFileInfoRec8)</p> <p>Audio data properties of the file (or of the data you will generate, if synthetic).</p> <pre><code>typedef struct {\n  csSDK_int32        numChannels;\n  float              sampleRate;\n  PrAudioSampleType  sampleType;\n}\n</code></pre> Member Description <code>numChannels</code> Number of audio channels in the audio stream.Either 1, 2, or 6. <code>sampleRate</code> In hertz. <code>sampleType</code> This is for informational use only, to disclose the format of the audio on disk, before it is converted to 32-bit float, uninterleaved, by the importer.The audio sample types are listed in Universals."},{"location":"importers/structure-descriptions/#imcalcsizerec","title":"imCalcSizeRec","text":"<p>Selector: imCalcSize8</p> <p>Asks the importer for an estimate of disk space used by the clip, given the provided trim boundaries.</p> <pre><code>typedef struct {\n  void         *privatedata;\n  void         *prefs;\n  csSDK_int32  trimIn;\n  csSDK_int32  duration;\n  prInt64      sizeInBytes;\n  csSDK_int32  scale;\n  csSDK_int32  sampleSize;\n} imCalcSizeRec;\n</code></pre> Member Description <code>privatedata</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>prefs</code> Clip Source Settings gathered from <code>imGetPrefs8</code> (setup dialog info). <code>trimIn</code> In point of the trimmed clip the importer should calculate the size for, in the timebase specified by scale over sampleSize. <code>duration</code> Duration of the trimmed clip the importer should calculate the size for.If 0, then the importer should calculate the size of the untrimmed clip. <code>sizeInBytes</code> Return the calculated size in bytes. <code>scale</code> The frame rate of the video clip, represented as scale over sampleSize. <code>sampleSize</code>"},{"location":"importers/structure-descriptions/#imchecktrimrec","title":"imCheckTrimRec","text":"<p>Selector: imCheckTrim8</p> <p>Provides the requested trim boundaries to the importer, and allows adjusted trim boundaries to be passed back to Premiere.</p> <pre><code>typedef struct {\n  void         *privatedata;\n  void         *prefs;\n  csSDK_int32  trimIn;\n  csSDK_int32  duration;\n  csSDK_int32  keepAudio;\n  csSDK_int32  keepVideo;\n  csSDK_int32  newTrimIn;\n  csSDK_int32  newDuration;\n  csSDK_int32  scale;\n  csSDK_int32  sampleSize;\n} imCheckTrimRec;\n</code></pre> Member Description <code>privatedata</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>prefs</code> Clip Source Settings gathered from <code>imGetPrefs8</code> (setup dialog info). <code>trimIn</code> Requested in point of the trimmed clip, in the timebase specified by scale over sampleSize. <code>duration</code> Requested duration. If 0, then the request is to leave the clip untrimmed, and at the current duration <code>keepAudio</code> If non-zero, the request is to keep the audio in the trimmed result. <code>keepVideo</code> If non-zero, the request is to keep the video in the trimmed result. <code>newTrimIn</code> Return the acceptable in point of the trimmed clip. It must be at or before the requested in point. <code>newDuration</code> Return the acceptable duration. newTrimIn + newDuration must be at or after the trimIn + duration. <code>scale</code> The frame rate of the video clip, represented as scale over sampleSize. <code>sampleSize</code>"},{"location":"importers/structure-descriptions/#imclipframedescriptorrec","title":"imClipFrameDescriptorRec","text":"<p>Selector: imSelectClipFrameDescriptor</p> <p>Based on the request in <code>inDesiredClipFrameDescriptor</code> and the importer's Source Settings, modify <code>outBestFrameDescriptor</code> as needed to describe what format the importer will provide.</p> <pre><code>typedef struct {\n  void*                inPrivateData;\n  void*                inPrefs;\n  ClipFrameDescriptor  inDesiredClipFrameDescriptor;\n  ClipFrameDescriptor  outBestFrameDescriptor;\n} imClipFrameDescriptorRec;\n</code></pre> Member Description <code>inPrivatedata</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>inPrefs</code> Clip Source Settings gathered from <code>imGetPrefs8</code> (setup dialog info). <code>inDesiredClipFrameDescriptor</code> Requested frame properties, as described by the host.The <code>ClipFrameDescriptor</code> struct is defined in PrSDKImporterShared.h. <code>outBestFrameDescriptor</code> Frame properties to be produced, filled in with initial guesses"},{"location":"importers/structure-descriptions/#imcompleteasyncclosedcaptionscanrec","title":"imCompleteAsyncClosedCaptionScanRec","text":"<p>Selector: imCompleteAsyncClosedCaptionScan</p> <p>This structure is passed to provide one last chance to cleanup and dispose of <code>inAsyncCaptionScanPrivateData</code>, and to mark whether the closed caption scan completed without error.</p> <pre><code>typedef struct {\n  void*        inPrivateData;\n  const void*  inPrefs;\n  void*        inAsyncCaptionScanPrivateData;\n  prBool       inScanCompletedWithoutError;\n} imCompleteAsyncClosedCaptionScanRec;\n</code></pre> Member Description <code>inPrivatedata</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>inPrefs</code> Clip Source Settings gathered from <code>imGetPrefs8</code> (setup dialog info). <code>inAsyncCaptionScanPrivateData</code> Cleanup and dispose of any data here that was allocated in <code>imInitiateAsyncClosedCaptionScan</code> or <code>imGetNextClosedCaption</code>.This data should not be accessed after returning from this call. <code>inScanCompletedWithoutError</code> Set to true if no error."},{"location":"importers/structure-descriptions/#imindcolorprofilerec","title":"imIndColorProfileRec","text":"<p>Selector: imGetIndColorProfile</p> <p>Deprecated as of 13.0. Describes a color profile supported by a clip.</p> <p>The first time <code>imGetIndColorProfile</code> is sent, <code>inDestinationBuffer</code> will be NULL, and <code>ioBufferSize</code> will be 0.</p> <p>Set <code>ioBufferSize</code> to the required size for the buffer, and the host will allocate the memory and call the importer again, with a valid <code>inDestinationBuffer</code>, and <code>ioBufferSize</code> set to the value just provided by the importer.</p> <pre><code>typedef struct {\n  void         *inPrivateData;\n  csSDK_int32  ioBufferSize;\n  void         *inDestinationBuffer;\n  PrSDKString  outName;\n} imIndColorProfileRec;\n</code></pre>"},{"location":"importers/structure-descriptions/#imcopyfilerec","title":"imCopyFileRec","text":"<p>Selector: imCopyFile</p> <p>Describes how to copy a clip. Also provides a callback to update the progress bar and check if the user has cancelled.</p> <pre><code>typedef struct {\n  void                *inPrivateData;\n  csSDK_int32         *inPrefs;\n  const prUTF16Char   *inSourcePath;\n  const prUTF16Char   *inDestPath;\n  importProgressFunc  inProgressCallback;\n  void                *inProgressCallbackID;\n} imTrimFileRec;\n</code></pre> Member Description <code>inPrivateData</code> Instance data gathered during <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>inPrefs</code> Clip Source Settings gathered during <code>imGetPrefs8</code> (setup dialog). <code>inSourcePath</code> Full unicode path of the source file. <code>inDestPath</code> Full unicode path of the destination file. <code>inProgressCallback</code> importProgressFunc callback to call repeatedly to provide progress and to check for cancel by user.May be a NULL pointer, so make sure the function pointer is valid before calling. <code>inProgressCallbackID</code> Pass to <code>progressCallback</code>."},{"location":"importers/structure-descriptions/#imdatarateanalysisrec","title":"imDataRateAnalysisRec","text":"<p>Selector: imDataRateAnalysis</p> <p>Specify the desired buffersize, return to Premiere with <code>imNoErr</code>; upon the next call fill buffer with <code>imDataSamples</code>, and specify a base data rate for audio (if any).</p> <p>This structure is used like <code>imAnalysisRec</code>.</p> <pre><code>typedef struct {\n  void         *privatedata;\n  void         *prefs;\n  csSDK_int32  buffersize;\n  char         *buffer;\n  csSDK_int32  baserate;\n} imDataRateAnalysisRec;\n</code></pre> Member Description <code>privatedata</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>prefs</code> Clip Source Settings gathered from <code>imGetPrefs8</code> (setup dialog info). <code>buffersize</code> The size of the buffer you request from Premiere prior to passing data back data in buffer. <code>buffer</code> Pointer to the analysis buffer to be filled with <code>imDataSamples</code> (see structure below). <code>baserate</code> <code>Audio</code> data rate (bytes per second) of the file. <pre><code>typedef struct {\n  csSDK_uint32  sampledur;\n  csSDK_uint32  samplesize;\n} imDataSample;\n</code></pre> Member Description <code>sampledur</code> Duration of one sample in video timebase, in samplesize increments; set the high bit if this is a keyframe. <code>samplesize</code> <code>Size</code> of this sample in bytes."},{"location":"importers/structure-descriptions/#imdeferredprocessingrec","title":"imDeferredProcessingRec","text":"<p>Selector: imDeferredProcessing</p> <p>Describes the current progress of the deferred processing on the clip referred to by inPrivateData.</p> <pre><code>typedef struct {\n  void   *inPrivateData;\n  float  outProgress;\n  char   outInvalidateFile;\n  char   outCallAgain;\n} imDeferredProcessingRec;\n</code></pre> Member Description <code>inPrivateData</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>outProgress</code> Set this to the current progress, from 0.0 to 1.0. <code>outInvalidateFile</code> The importer has updated information about the file. <code>outCallAgain</code> Set this to true to request that the importer be called again immediately."},{"location":"importers/structure-descriptions/#imdeletefilerec","title":"imDeleteFileRec","text":"<p>Selector: imDeleteFile</p> <p>Describes the file to be deleted.</p> <pre><code>typedef struct {\n  csSDK_int32        filetype;\n  const prUTF16Char  deleteFile;\n} imDeleteFileRec;\n</code></pre> Member Description <code>filetype</code> The file's unique four character code, defined in the IMPT resource <code>deleteFile</code> Specifies the name (and path) of the file to be deleted."},{"location":"importers/structure-descriptions/#imfileaccessrec8","title":"imFileAccessRec8","text":"<p>Selectors: <code>imGetInfo8</code> and <code>imGetPrefs8</code></p> <p>Describes the file being imported.</p> <pre><code>typedef struct {\n  void               *importID;\n  csSDK_int32        filetype;\n  const prUTF16Char  *filepath;\n  imFileRef          fileref;\n  PrMemoryPtr        newfilename;\n} imFileAccessRec;\n</code></pre> Member Description <code>importID</code> Unique ID provided by Premiere. Do not modify! <code>filetype</code> The file's unique four character code, defined in the IMPT resource. <code>filepath</code> The unicode file path and name. <code>fileref</code> A Windows HANDLE. Premiere does not overload this value by using it internally, although setting it to the constant kBadFileRef may cause Premiere to think the file is closed.This value is always valid. <code>newfilename</code> If the file is synthetic, the importer can specify the displayable name here as a prUTF16Char string during <code>imGetPrefs8</code>."},{"location":"importers/structure-descriptions/#imfileattributesrec","title":"imFileAttributesRec","text":"<p>Selector: imGetFileAttributes</p> <p>New in Premiere Pro 3.1. Provide the clip creation date.</p> <pre><code>typedef struct {\n  prDateStamp  creationDateStamp;\n  csSDK_int32  reserved[40];\n} imFileAttributesRec;\n</code></pre> Member Description <code>creationDateStamp</code> Structure to store when the clip was created"},{"location":"importers/structure-descriptions/#imfileinforec8","title":"imFileInfoRec8","text":"<p>Selector: imGetInfo8</p> <p>Describes the clip, or the stream with the ID streamIdx. Set the clip or stream attributes from the file header or data source. Create and store any privateData.</p> <p>When a synthetic clip is created, and the user provides the desired resolution, frame rate, pixel aspect ratio, and audio sample rate in the New Synthetic dialog, these values will be pre-initialized by Premiere.</p> <p>If importing stereoscopic footage, import the left-eye video channel for streamID 0, and the right-eye video channel for streamID 1.</p> <pre><code>typedef struct {\n  char             hasVideo;\n  char             hasAudio;\n  imImageInfoRec   vidInfo;\n  csSDK_int32      vidScale;\n  csSDK_int32      vidSampleSize;\n  csSDK_int32      vidDuration;\n  imAudioInfoRec7  audInfo;\n  PrAudioSample    audDuration;\n  csSDK_int32      accessModes;\n  void             *privatedata;\n  void             *prefs;\n  char             hasDataRate;\n  csSDK_int32      streamIdx;\n  char             streamsAsComp;\n  prUTF16Char      streamName[256];\n  csSDK_int32      sessionPluginID;\n  char             alwaysUnquiet;\n  char             unused;\n  prUTF16Char      filePath[2048];\n  char             canProvidePeakData;\n  char             mayBeGrowing;\n} imFileInfoRec8;\n</code></pre> Member Description <code>hasVideo</code> If non-zero, the file contains video. <code>hasAudio</code> If non-zero, the file contains audio. <code>vidInfo</code> If there is video in the file, fill out the imImageInfoRec structure (e.g. height, width, alpha info, etc.). <code>vidScale</code> The frame rate of the video, represented as scale over sampleSize. <code>vidSampleSize</code> <code>vidDuration</code> The total number of frames of video, in the video timebase. <code>audInfo</code> If there is audio in the file, fill out the imAudioInfoRec7 structure. <code>audDuration</code> The total number of audio sample frames. <code>accessModes</code> The access mode of this file. Use one of the following constants:<ul><li><code>kRandomAccessImport</code> - This file can be read by random access (default)</li><li><code>kSequentialAudioOnly</code> - When accessing audio, only sequential reads allowed (for variable bit rate files)</li><li><code>kSequentialVideoOnly</code> - When accessing video, only sequential reads allowed</li><li><code>kSequentialOnly</code> - Both sequential audio and video</li><li><code>kSeparateSequentialAudio</code> - Both random access and sequential access.</li></ul>This setting allows audio to be retrieved for scrubbing or playback even during audio conforming. <code>privatedata</code> Private instance data.Allocate a handle using Premiere's memory functions and store it here.Premiere will return the handle with subsequent selectors. <code>prefs</code> Clip Source Settings data gathered from <code>imGetPrefs8</code> (setup dialog info).When a synthetic clip is created using File &gt; New, <code>imGetPrefs8</code> is sent <code>beforeimGetInfo8</code> so this settings structure will already be valid. <code>hasDataRate</code> If set, the importer can read or generate data rate information for this file and will be sent <code>imDataRateAnalysis</code>. <code>streamIdx</code> The Premiere-specified stream index number.Only useful if clip uses multiple streams. <code>streamsAsComp</code> If multiple streams and this is stream zero, indicate whether to import as a composition or multiple clips. <code>streamName</code> Optional. The unicode name of this stream if there are multiple streams.New in Premiere Pro 3.1, an importer may use this to set the clip name based on metadata rather than the filename.The importer should set <code>imImportInfoRec.canSupplyMetadataClipName</code> to true, and fill out the name here. <code>sessionPluginID</code> This ID should be used in the File Registration Suite for registering external files (such as textures, logos, etc) that are used by an importer instance but do not appear as footage in the Project Window.Registered files will be taken into account when trimming or copying a project using the Project Manager.The <code>sessionPluginID</code> is valid only for the call that it is passed on. <code>alwaysUnquiet</code> Set to non-zero to tell Premiere if the clip should always be unquieted immediately when the application regains focus. <code>filepath</code> Added in Premiere Pro 4.1. For clips that have audio in files separate from the video file, set the filename here, so that UMIDs can properly be generated when exporting sequences to AAF. <code>canProvidePeakData</code> New in Premiere Pro CS6. This allows an importer to toggle whether or not it wants to provide peak audio data on a clip-by-clip basis.It defaults to the setting set in <code>imImportInfoRec.canProvidePeakAudio</code>.NOTE: Do not attempt to use this setting, with growing files. <code>mayBeGrowing</code> New in Premiere Pro CS6.0.2. Set to non-zero if this clip is growing and should be refreshed at the interval set in the Media Preferences."},{"location":"importers/structure-descriptions/#imfileopenrec8","title":"imFileOpenRec8","text":"<p>Selector: imOpenFile8</p> <p>The file Premiere wants the importer to open.</p> <pre><code>typedef struct {\n  imFileAccessRec8  fileinfo;\n  void              *privatedata;\n  csSDK_int32       reserved;\n  PrFileOpenAccess  inReadWrite;\n  csSDK_int32       inImporterID;\n  csSDK_size_t      outExtraMemoryUsage;\n  csSDK_int32       inStreamIdx;\n} imFileOpenRec8;\n</code></pre> Member Description <code>fileinfo</code> <code>imFileAccessRec8</code> describing the incoming file. <code>privatedata</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>reserved</code> Do not use. <code>inReadWrite</code> The file should be opened with the access mode specified:Either <code>kPrOpenFileAccess_ReadOnly</code> or <code>kPrOpenFileAccess_ReadWrite</code> <code>inImporterID</code> Can be used as the ID for calls in the PPix Cache Suite. <code>outExtraMemoryUsage</code> New in CS5. If the importer uses memory just by being open, which cannot otherwise be registered in the cache, put the size in bytes in this field. <code>inStreamIdx</code> New in CS6. If the clip has multiple streams (for stereoscopic video or otherwise), this ID differentiates between them."},{"location":"importers/structure-descriptions/#imfileref","title":"imFileRef","text":"<p>Selectors:</p> <ul> <li>imAnalysis,</li> <li>imDataRateAnalysis,</li> <li>imOpenFile8,</li> <li>imQuietFile,</li> <li>imCloseFile,</li> <li>imGetTimeInfo8,</li> <li>imSetTimeInfo8,</li> <li>imImportImage,</li> <li>imImportAudio7</li> </ul> <p>A file HANDLE on Windows, or a void* on MacOS.</p> <p><code>imFileRef</code> is also a member of <code>imFileAccessRec</code>.</p> <p>Use OS-specific functions, rather than ANSI file functions, when manipulating imFileRef.</p>"},{"location":"importers/structure-descriptions/#imframeformat","title":"imFrameFormat","text":"<p>Selector: imGetSourceVideo (member of imSourceVideoRec)</p> <p>Describes the frame dimensions and pixel format.</p> <pre><code>typedef struct {\n  csSDK_int32    inFrameWidth;\n  csSDK_int32    inFrameHeight;\n  PrPixelFormat  inPixelFormat;\n} imFrameFormat;\n</code></pre> Member Description <code>inFrameWidth</code> The frame dimensions requested. <code>inFrameHeight</code> <code>inPixelFormat</code> The pixel format of the frame requested."},{"location":"importers/structure-descriptions/#imgetaudiochannellayoutrec","title":"imGetAudioChannelLayoutRec","text":"<p>Selector: imGetAudioChannelLayout</p> <p>The importer should label each audio channel in the clip being imported.</p> <p>If no labels are specified, the channel layout will be assumed to be discrete.</p> <pre><code>typedef struct {\n  void*                inPrivateData;\n  PrAudioChannelLabel  outChannelLabels[kMaxAudioChannelCount];\n} imGetAudioChannelLayoutRec;\n</code></pre> Member Description <code>inPrivatedata</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>outChannelLabels</code> A valid audio channel label should be assigned for each channel in the clip.Labels are defined in the Audio Suite."},{"location":"importers/structure-descriptions/#imgetnextclosedcaptionrec","title":"imGetNextClosedCaptionRec","text":"<p>Selector: imGetNextClosedCaption</p> <p>This structure provides private data allocated in <code>imInitiateAsyncClosedCaptionScan</code>, and should be filled out to pass back a closed caption, it's time, format, size, and overall progress in the closed caption scan.</p> <pre><code>typedef struct {\n  void*                  inPrivateData;\n  const void*            inPrefs;\n  void*                  inAsyncCaptionScanPrivateData;\n  float                  outProgress;\n  csSDK_int64            outScale;\n  csSDK_int64            outSampleSize;\n  csSDK_int64            outPosition;\n  PrClosedCaptionFormat  outClosedCaptionFormat;\n  PrMemoryPtr            outCaptionData;\n  prUTF8Char             outTTMLData[kTTMLBufferSize];\n  csSDK_size_t           ioCaptionDataSize;\n} imGetNextClosedCaptionRec;\n</code></pre> Member Description <code>inPrivatedata</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>inPrefs</code> Clip Source Settings gathered from <code>imGetPrefs8</code> (setup dialog info). <code>inAsyncCaptionScanPrivateData</code> This provides any private data that was allocated in <code>imInitiateAsyncClosedCaptionScan</code>. <code>outProgress</code> Update this value to denote the current progress iterating through all the captions. Valid values are between 0.0 and 1.0. <code>outScale</code> The timebase of outPosition, represented as scale over sampleSize. <code>outSampleSize</code> <code>outPosition</code> The position of the closed caption. <code>outClosedCaptionFormat</code> The format of the closed captions. One of the following:<ul><li><code>kPrClosedCaptionFormat_Undefined</code></li><li><code>kPrClosedCaptionFormat_CEA608</code> - CEA-608 byte stream</li><li><code>kPrClosedCaptionFormat_CEA708</code> - CEA-708 byte stream (may contain 608 data wrapped in 708)</li><li><code>kPrClosedCaptionFormat_TTML</code> - W3C TTML string that conforms to the W3C Timed Text Markup Language (TTML) 1.0: http://www.w3.org/TR/ttaf1-dfxp or optionally conforming to SMPTE ST 2052-1:2010: hhttp://store.smpte.org/, or optionally conforming to EBU Tech 3350 http://tech.ebu.ch/webdav/site/tech/shared/tech/).</li></ul>If the TTML string contains tunneled data (e.g. CEA-608 data), then it is preferred that the plugin provide that through the appropriate byte stream format (e.g. <code>kPrClosedCaptionFormat_CEA608</code>). <code>outCaptionData</code> Memory location to where the plugin should write the closed caption bytes, if providing CEA-608 or CEA-708. <code>outTTMLData</code> UTF-8 String of valid W3C TTML data.The entire string may be split into substrings (e.g. line by line) and the host will concatenate and decode them (only used when outCaptionData is kPrClosedCaptionFormat_TTML). <code>ioCaptionDataSize</code> <code>Size</code> of outCaptionData buffer (in bytes) allocated from the host. The importer should set this variable to the actual number of bytes that were written to outCaptionData, or the length of the string (characters, not bytes) pointed by outTTMLData."},{"location":"importers/structure-descriptions/#imgetprefsrec","title":"imGetPrefsRec","text":"<p>Selector: imGetPrefs8</p> <p>Contains settings/prefs data gathered from (or defaults to populate) a setup dialog.</p> <p>If you are creating media, you can may generate a video preview that includes the background frame from the timeline.</p> <pre><code>typedef struct {\n  char            *prefs;\n  csSDK_int32     prefsLength;\n  char            firstTime;\n  PrTimelineID    timelineData;\n  void            *privatedata;\n  TDB_TimeRecord  tdbTimelineLocation;\n  csSDK_int32     sessionPluginID;\n  csSDK_int32     imageWidth;\n  csSDK_int32     imageHeight;\n  csSDK_uint32    pixelAspectNum;\n  csSDK_uint32    pixelAspectDen;\n  csSDK_int32     vidScale;\n  csSDK_int32     vidSampleSize;\n  float           sampleRate;\n} imGetPrefsRec;\n</code></pre> Member Description <code>prefs</code> A pointer to a private structure (which you allocate) for storing Clip Source Settings. <code>prefsLength</code> Prior to storing anything in the prefs member, set prefsLength to the size of your structure and return imNoErr; Premiere will re-size and call the plugin again with <code>imGetPrefs8</code>. <code>firstTime</code> If set, <code>imGetPrefs8</code> is being sent for the first time.Instead, check to see if prefs has been allocated. If not, <code>imGetPrefs8</code> is being sent for the first time. Set up default values for the prefsLength buffer and present any setup dialog. <code>timelineData</code> <code>Can</code> be passed to getPreviewFrameEx callback along with tdbTimelineLocation to get a frame from the timeline beneath the current clip or timeline location. This is useful for titler plugins. <code>privatedata</code> Private instance data.Allocate a handle using Premiere's memory functions and store it here, if not already allocated in <code>imGetInfo8</code>.Premiere will return the handle with subsequent selectors. <code>tdbTimelineLocation</code> <code>Can</code> be passed to getPreviewFrameEx callback along with timelineData to get a frame from the timeline beneath the current clip or timeline location. This is useful for titler plugins. <code>sessionPluginID</code> This ID should be used in the File Registration Suite for registering external files (such as textures, logos, etc) that are used by a importer instance but do not appear as footage in the Project Window.Registered files will be taken into account when trimming or copying a project using the Project Manager. The sessionPluginID is valid only for the call that it is passed on. <code>imageWidth</code> New in CS5. The native resolution of the video. <code>imageHeight</code> <code>pixelAspectNum</code> New in CS5. The pixel aspect ratio of the video. <code>pixelAspectDen</code> <code>vidScale</code> New in CS5. The frame rate of the video, represented as scale over sampleSize. <code>vidSampleSize</code> <code>sampleRate</code> New in CS5. Audio sample rate."},{"location":"importers/structure-descriptions/#imimageinforec","title":"imImageInfoRec","text":"<p>Selector: imGetInfo8 (member of imFileInfoRec8)</p> <p>Describes the video to be imported.</p> <pre><code>typedef struct {\n  csSDK_int32   imageWidth;\n  csSDK_int32   imageHeight;\n  csSDK_uint16  pixelAspectV1;\n  csSDK_uint16  depth;\n  csSDK_int32   subType;\n  char          fieldType;\n  char          fieldsStacked;\n  char          reserved_1;\n  char          reserved_2;\n  char          alphaType;\n  matteColRec   matteColor;\n  char          alphaInverted;\n  char          isVectors;\n  char          drawsExternal;\n  char          canForceInternalDraw;\n  char          dontObscure;\n  char          isStill;\n  char          noDuration;\n  char          reserved_3;\n  csSDK_uint32  pixelAspectNum;\n  csSDK_uint32  pixelAspectDen;\n  char          isRollCrawl;\n  char          reservedc[3];\n  csSDK_int32   importerID;\n  csSDK_int32   supportsAsyncIO;\n  csSDK_int32   supportsGetSourceVideo;\n  csSDK_int32   hasPulldown;\n  csSDK_int32   pulldownCadence;\n  csSDK_int32   posterFrame;\n  csSDK_int32   canTransform;\n  csSDK_int32   interpretationUncertain;\n  csSDK_int32   colorProfileSupport;\n  PrSDKString   codecDescription;\n  csSDK_int32   colorSpaceSupport;\n  PrTime        frameRate;\n  prBool        hasEmbeddedLUT;\n  csSDK_int32   reserved[12];\n} imImageInfoRec;\n</code></pre>"},{"location":"importers/structure-descriptions/#plug-in-info","title":"Plug-in Info","text":"Member Description <code>importerID</code> <code>Can</code> be used as the ID for calls in the PPix Cache Suite. <code>supportsAsyncIO</code> Set this to true if the importer supports <code>imCreateAsyncImporter</code> and ai* selectors. <code>supportsGetSourceVideo</code> Set this to true if the importer supports the <code>imGetSourceVideo</code> selector."},{"location":"importers/structure-descriptions/#bounds-info","title":"Bounds Info","text":"Member Description <code>imageWidth</code> Frame width in pixels. <code>imageHeight</code> Frame height in pixels. <code>pixelAspectNum</code> The pixel aspect ratio numerator and denominator.For synthetic importers, these are by default the PAR of the project.Only set this if you need a specific PAR for the geometry of the synthesized footage to be correct. <code>pixelAspectDen</code>"},{"location":"importers/structure-descriptions/#time-info","title":"Time Info","text":"Member Description <code>isStill</code> If set, the file contains a single frame, so only one frame will be cached. <code>noDuration</code> One of the following:<ul><li><code>imNoDurationFalse</code></li><li><code>imNoDurationNoDefault</code></li><li><code>imNoDurationStillDefault</code> - use the default duration for stills, as set by the user in the Preferences</li><li><code>imNoDurationNoDefault</code> - the importer will supply it's own duration</li></ul>This is primarily for synthetic clips, but can be used for importing non-sequential still images. <code>isRollCrawl</code> Set to non-zero value to specify this clip is a rolling or crawling title.This allows a player to optionally use the RollCrawl Suite to get sections of this title for real-time playback. <code>hasPulldown</code> Set this to true if the clip contains NTSC film footage with 3:2 pulldown. <code>pulldownCadence</code> Set this to the enumerated value that describes the pulldown of the clip:<ul><li><code>importer_PulldownPhase_NO_PULLDOWN</code></li></ul>2:3 cadences:<ul><li><code>importer_PulldownPhase_WSSWW</code></li><li><code>importer_PulldownPhase_SSWWW</code></li><li><code>importer_PulldownPhase_SWWWS</code></li><li><code>importer_PulldownPhase_WWWSS</code></li><li><code>importer_PulldownPhase_WWSSW</code></li></ul>24pa cadences:<ul><li><code>importer_PulldownPhase_WWWSW</code></li><li><code>importer_PulldownPhase_WWSWW</code></li><li><code>importer_PulldownPhase_WSWWW</code></li><li><code>importer_PulldownPhase_SWWWW</code></li><li><code>importer_PulldownPhase_WWWWS</code></li></ul> <code>posterFrame</code> New in Premiere Pro CS3. Poster frame number to be displayed.If not specified, the poster frame will be the first frame of the clip."},{"location":"importers/structure-descriptions/#format-info","title":"Format Info","text":"Member Description <code>depth</code> Bits per pixel. This currently has no effect and should be left unchanged. <code>subType</code> The four character code of the file's codec; associates files with MAL plugins. For uncompressed files, set to <code>imUncompressed</code>. <code>fieldType</code> One of the following:<ul><li><code>prFieldsNone</code></li><li><code>prFieldsUpperFirst</code></li><li><code>prFieldsLowerFirst</code></li><li><code>prFieldsUnknown</code></li></ul> <code>fieldsStacked</code> Fields are present, and not interlaced. Deprecated since Premiere Pro 7.0. <code>alphaType</code> Used when depth is 32 or greater. One of the following:<ul><li><code>alphaNone</code> - no alpha channel (the default)</li><li><code>alphaStraight</code> - straight alpha channel</li><li><code>alphaBlackMatte</code> - premultiplied with black</li><li><code>alphaWhiteMatte</code> - premultiplied with white</li><li><code>alphaArbitrary</code> - premultiplied with the color specified in matteColor</li><li><code>alphaOpaque</code> - for video with alpha channel prefilled to opaque.</li></ul>This gives Premiere the opportunity to make an optimization by skipping the fill to opaque that would otherwise be performed if alphaNone was set. <code>matteColor</code> <code>Newly</code> used in Premiere Pro CS3. Used to specify matte color if <code>alphaType</code> is set to <code>alphaArbitrary</code>. <code>alphaInverted</code> If non-zero, alpha is treated as inverted (e.g. black becomes transparent). <code>canTransform</code> Set to non-zero value to specify this importer handles resolution independent files and can apply a transform matrix.The matrix will be passed during the import request in <code>imImportImageRec.transform</code>.This code path is currently not called by Premiere Pro. After Effects uses this call to import Flash video. <code>interpretationUncertain</code> Use an 'or' operator to combine any of the following flags:<ul><li><code>imPixelAspectRatioUncertain</code></li><li><code>imFieldTypeUncertain</code></li><li><code>imAlphaInfoUncertain</code></li><li><code>imEmbeddedColorProfileUncertain</code></li></ul> <code>colorProfileSupport</code> Deprecated as of 13.0. New in CS5.5.Set to <code>imColorProfileSupport_Fixed</code> to support color management.If the importer is uncertain, it should use <code>interpretationUncertain</code> above instead. <code>codecDescription</code> Text description of the codec in use. <code>ColorProfileRec</code> New in 13.0; describes the color profile being used by the importer, with this media. <code>colorSpaceSupport</code> Set to <code>imColorSpaceSupport_Fixed</code> to support color management.If importer is uncertain, it should use <code>imColorSpaceSupport_None</code> above instead. <code>hasEmbeddedLUT</code> Set to <code>kPrTrue</code> if media contains embedded LUT. Else set to <code>kPrFalse</code>."},{"location":"importers/structure-descriptions/#unused","title":"Unused","text":"Member Description <code>pixelAspectV1</code> Obsolete. Maintained for backwards compatability.Plugins written for the Premiere 6.x or Premiere Pro API should use <code>pixelAspectNum</code> and <code>pixelAspectDen</code>. <code>isVectors</code> Use <code>canTransform</code> instead. <code>drawsExternal</code> <code>canForceInternalDraw</code> <code>dontObscure</code>"},{"location":"importers/structure-descriptions/#imimportaudiorec7","title":"imImportAudioRec7","text":"<p>Selector: imImportAudio7</p> <p>Describes the audio samples to be returned, and contains an allocated buffer for the importer to fill in.</p> <p>Provide the audio in 32-bit float, uninterleaved audio format.</p> <pre><code>typedef struct {\n  PrAudioSample  position;\n  csSDK_uint32   size;\n  float          **buffer;\n  void           *privatedata;\n  void           *prefs;\n} imImportAudioRec7;\n</code></pre> Member Description <code>position</code> In point, in audio sample frames.The importer should save the out point of the request in privatedata, because if position is less than zero, then the audio request is sequential, which means the importer should return contiguous samples from the last <code>imImportAudio7</code> call. <code>size</code> The number of audio sample frames to import. <code>buffer</code> An array of buffers, one buffer for each channel, with length specified in size.These buffers are allocated by the host application, for the plugin to fill in with audio data. <code>privatedata</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>prefs</code> Clip Source Settings data gathered from <code>imGetPrefs8</code> (setup dialog info)."},{"location":"importers/structure-descriptions/#imimportimagerec","title":"imImportImageRec","text":"<p>Selector: imImportImage</p> <p>Describes the frame to be returned.</p> <pre><code>typedef struct {\n  csSDK_int32    onscreen;\n  csSDK_int32    dstWidth;\n  csSDK_int32    dstHeight;\n  csSDK_int32    dstOriginX;\n  csSDK_int32    dstOriginY;\n  csSDK_int32    srcWidth;\n  csSDK_int32    srcHeight;\n  csSDK_int32    srcOriginX;\n  csSDK_int32    srcOriginY;\n  csSDK_int32    unused2;\n  csSDK_int32    unused3;\n  csSDK_int32    rowbytes;\n  char           *pix;\n  csSDK_int32    pixsize;\n  PrPixelFormat  pixformat;\n  csSDK_int32    flags;\n  prFieldType    fieldType;\n  csSDK_int32    scale;\n  csSDK_int32    sampleSize;\n  csSDK_int32    in;\n  csSDK_int32    out;\n  csSDK_int32    pos;\n  void           *privatedata;\n  void           *prefs;\n  prRect         alphaBounds;\n  csSDK_int32    applyTransform;\n  float          transform[3][3];\n  prRect         destClipRect;\n} imImportImageRec;\n</code></pre>"},{"location":"importers/structure-descriptions/#bounds-info-for-imimportimagerec","title":"Bounds Info (for imImportImageRec)","text":"Member Description <code>dstWidth</code> Width of the destination rectangle (in pixels). <code>dstHeight</code> Height of the destination rectangle (in pixels). <code>dstOriginX</code> Origin X point (0 indicates the frame is drawn offscreen). <code>dstOriginY</code> Origin Y point (0 indicates the frame is drawn offscreen). <code>srcWidth</code> The same number returned as dstWidth. <code>srcHeight</code> The same number returned as dstHeight. <code>srcOriginX</code> The same number returned as dstOriginX. <code>srcOriginY</code> The same number returned as dstOriginY."},{"location":"importers/structure-descriptions/#frame-info","title":"Frame Info","text":"Member Description <code>rowbytes</code> The number of bytes in a single row of pixels. <code>pix</code> Pointer to a buffer into which the importer should draw. Allocated based on information from the <code>imGetInfo8</code>. <code>pixsize</code> The number of pixels. rowbytes * height. <code>pixformat</code> The pixel format Premiere requests. <code>flags</code> <code>imDraftMode</code> - Draw quickly if possible, using a faster and possibly less accurate algorithm.This may be passed when playing from the timeline.<code>imSamplesAreFields</code> - Most importers will ignore as Premiere already scales in/out/scale to account for fields, but if you need to know that this has occurred (because maybe you measure something in 'frames'), check this flag.Also, may we suggest considering measuring in seconds instead of frames? <code>fieldType</code> If the importer can swap fields, it should render the frame with the given field dominance: either <code>imFieldsUpperFirst</code> or <code>imFieldsLowerFirst</code>. <code>scale</code> The frame rate of the video, represented as scale over sampleSize. <code>sampleSize</code> <code>in</code> In point, based on the timebase defined by scale over sampleSize. <code>out</code> Out point, based on the timebase defined by scale over sampleSize. <code>pos</code> Import position, based on the above timebase.API bug: Synthetic and custom importers will always receive zero.Thus, adjusting the in point on the timeline will not offset the in point. <code>privatedata</code> Instance data gathered during <code>imGetInfo</code> or <code>imGetPrefs</code>. <code>prefs</code> Clip Source Settings data gathered during <code>imGetPrefs</code> (setup dialog info). <code>alphaBounds</code> This is the rect outside of which the alpha is always 0. Simply do not alter this field if the alpha bounds match the destination bounds.If set, the alpha bounds must be contained by the destination bounds. This is only currently used when a plugin calls <code>ppixGetAlphaBounds</code>, and not currently used by any native plugins. <code>applyTransform</code> New in After Effects CS3. Not currently provided by Premiere.If non-zero, the host is requesting that the importer apply the transform specified in transform and destClipRect before returning the resulting image in pix. <code>transform</code> New in After Effects CS3. Not currently provided by Premiere. The source to destination transform matrix. <code>destClipRect</code> New in After Effects CS3. Not currently provided by Premiere. Destination rect inside the bounds of the pix buffer."},{"location":"importers/structure-descriptions/#imimportinforec","title":"imImportInfoRec","text":"<p>Selector: imInit</p> <p>Describes the importer's capabilities to Premiere.</p> <pre><code>typedef struct {\n  csSDK_uint32  importerType;\n  csSDK_int32   canOpen;\n  csSDK_int32   canSave;\n  csSDK_int32   canDelete;\n  csSDK_int32   canResize;\n  csSDK_int32   canDoSubsize;\n  csSDK_int32   canDoContinuousTime;\n  csSDK_int32   noFile;\n  csSDK_int32   addToMenu;\n  csSDK_int32   hasSetup;\n  csSDK_int32   dontCache;\n  csSDK_int32   setupOnDblClk;\n  csSDK_int32   keepLoaded;\n  csSDK_int32   priority;\n  csSDK_int32   canAsync;\n  csSDK_int32   canCreate;\n  csSDK_int32   canCalcSizes;\n  csSDK_int32   canTrim;\n  csSDK_int32   avoidAudioConform;\n  prUTF16Char   *acceleratorFileExt;\n  csSDK_int32   canCopy;\n  csSDK_int32   canSupplyMetadataClipName;\n  csSDK_int32   private;\n  csSDK_int32   canProvidePeakAudio;\n  csSDK_int32   canProvideFileList;\n  csSDK_int32   canProvideClosedCaptions;\n  prPluginID    fileInfoVersion;\n} imImportInfoRec;\n</code></pre>"},{"location":"importers/structure-descriptions/#screen-info","title":"Screen Info","text":"Member Description <code>noFile</code> If set, this is a synthetic importer. The file reference will be zero. <code>addToMenu</code> If set to <code>imMenuNew</code>, the importer will appear in the File &gt; New menu. <code>canDoContinuousTime</code> If set, the importer can render frames at arbitrary times and there is no set timecode.A color matte generator or a titler would set this flag. <code>canCreate</code> If set, Premiere will treat this synthetic importer as if it creates files on disk to be referenced for frames and audio.See Additional Details for more information on custom importers."},{"location":"importers/structure-descriptions/#file-handling-flags","title":"File Handling Flags","text":"Member Description <code>canOpen</code> If set, the importer handles open and close operations.Set if the plugin needs to be called to handle <code>imOpenFile</code>, <code>imQuietFile</code>, and <code>imCloseFile</code>. <code>canSave</code> If set, the importer handles File &gt; Save and File &gt; Save As after a clip has been captured and must handle the <code>imSaveFile</code> selector. <code>canDelete</code> If set, the importer can delete its own files.The plugin must handle the <code>imDeleteFile</code> selector. <code>canCalcSizes</code> If set, the importer can calculate the disk space used by a clip during imCalcSize.An importer should support this call if it uses a tree of files represented as one top-level file to Premiere. <code>canTrim</code> If set, the importer can trim files during imTrimFile. <code>canCopy</code> Set this to true if the importer supports copying clips in the Project Manager."},{"location":"importers/structure-descriptions/#setup-flags","title":"Setup Flags","text":"Member Description <code>hasSetup</code> If set, the importer has a setup dialog. The dialog should be presented in response to <code>imGetPrefs</code> <code>setupOnDblClk</code> If set, the setup dialog should be opened whenever the user double clicks on a file imported by the plugin the timeline or the project bin."},{"location":"importers/structure-descriptions/#memory-handling-flags","title":"Memory Handling Flags","text":"Member Description <code>dontCache</code> Unused. <code>keepLoaded</code> If set, the importer plugin should never be unloaded.Don't set this flag unless it's absolutely necessary (it usually isn't)."},{"location":"importers/structure-descriptions/#other","title":"Other","text":"Member Description <code>priority</code> Determines priority levels for importers that handle the same filetype.Importers with higher numbers will override importers with lower numbers.For overriding importers that ship with Premiere, use a value of 100 or greater.Higher-priority importers can defer files to lower-priority importers by returning <code>imBadFile</code> during <code>imOpenFile8</code> or <code>imGetInfo8</code>. <code>importType</code> Type identifier for the import module assigned based on the plugin's IMPT resource.Do not modify this field. <code>canProvideClosedCaptions</code> New in Premiere Pro CC. Set this to true if the importer supports media with embedded closed captioning. <code>avoidAudioConform</code> Set this to true if the importer supports fast audio retrieval and does not need the audio clips it imports to be conformed. <code>canProvidePeakAudio</code> New in Premiere Pro CS5.5. Set this to true if your non-synthetic importer wants to provide peak audio data using <code>imGetPeakAudio</code>. <code>acceleratorFileExt</code> Fill this prUTF16Char array of size 256 with the file extensions of accelerator files that the importer creates and uses. <code>canSupplyMetadataClipName</code> Allows file based importer to set clip name from metadata.Set this in <code>imFileInfoRec8.streamName</code>. <code>canProvideFileList</code> New in CS6. Set this to true if the importer will provide a list of all files for a copy operation in response to <code>imQueryInputFileList</code>. <code>fileInfoVersion</code> New in CC 2014. This is used by an optimization in an internal importer. Do not use."},{"location":"importers/structure-descriptions/#unused-in-imimportinforec","title":"Unused (in imImportInfoRec)","text":"Member Description <code>canResize</code> <code>canDoSubsize</code> <code>canAsync</code>"},{"location":"importers/structure-descriptions/#imindformatrec","title":"imIndFormatRec","text":"<p>Selector: imGetIndFormat</p> <p>Describes the format(s) supported by the importer. Synthetic files can only have one format.</p> <pre><code>typedef struct {\n  csSDK_int32  filetype;\n  csSDK_int32  flags;\n  csSDK_int32  canWriteTimecode;\n  char         FormatName[256];\n  char         FormatShortName[32];\n  char         PlatformExtension[256];\n  prBool       hasAlternateTypes;\n  csSDK_int32  alternateTypes[kMaxAlternateTypes];\n  csSDK_int32  canWriteMetaData;\n} imIndFormatRec;\n</code></pre> Member Description <code>filetype</code> Unique four character code (fourcc) of the file. <code>flags</code> Legacy mechanism for describing the importer capabilities.Though the flags will still be honored for backward compatability, current and future importers should not use these flags.See table below for details. <code>canWriteTimecode</code> If set, timecode can be written for this filetype. <code>FormatName[256]</code> The descriptive importer name. <code>FormatShortName[256]</code> The short name for the plugin, appears in the format menu. <code>PlatformExtension[256]</code> List of all the file extensions supported by this importer.If there's more than one, separate with null characters. <code>hasAlternateTypes</code> Unused <code>alternateTypes[kMaxAlternateTypes]</code> Unused <code>canWriteMetaData</code> New in 6.0. If set, imSetMetaData is supported for the filetype <p>The flags listed below are only for legacy plugins and should not be used.</p> Member Description Flag Usage <code>xfIsMovie</code> Unused <code>xfCanReplace</code> Unused <code>xfCanOpen</code> Unused: Use <code>imImportInfoRec.canOpen</code> instead. <code>xfCanImport</code> Unused: The PiPL resource describes the file as an importer. <code>xfIsStill</code> Indicates that the importer handles still images. <code>xfIsSound</code> Unused: Use <code>imFileInfoRec.hasAudio</code> instead. <code>xfCanWriteTimecode</code> If set, the importer can respond to <code>imGetTimecode</code> and <code>imSetTimecode</code>.Obsolete: use <code>imIndFormatRec.canWriteTimecode</code> instead. <code>xfCanWriteMetaData</code> Writes (and reads) metadata, specific to the importer's four character code filetype.Obsolete: use <code>imIndFormatRec.canWriteMetaData</code> instead. <code>xfCantBatchProcess</code> Unused"},{"location":"importers/structure-descriptions/#imindpixelformatrec","title":"imIndPixelFormatRec","text":"<p>Selector: imGetIndPixelFormat</p> <p>Describes the pixel format(s) supported by the importer.</p> <pre><code>typedef struct {\n  void           *privatedata;\n  PrPixelFormat  outPixelFormat;\n  const void*    prefs;\n} imIndPixelFormatRec;\n</code></pre> Member Description <code>privatedata</code> Instance data from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>outPixelFormat</code> One of the pixel formats supported by the importer <code>prefs</code> New in CC. Clip Source Settings data gathered during <code>imGetPrefs8</code> (setup dialog)."},{"location":"importers/structure-descriptions/#iminitiateasyncclosedcaptionscanrec","title":"imInitiateAsyncClosedCaptionScanRec","text":"<p>Selector: imInitiateAsyncClosedCaptionScan</p> <p>Both <code>imGetNextClosedCaption</code> and <code>imCompleteAsyncClosedCaptionScan</code> may be called from a different thread from which imInitiateAsyncClosedCaptionScan was originally called.</p> <p>To help facilitate this, outAsyncCaptionScanPrivateData can be allocated by the importer to be used for the upcoming closed caption scan calls, which should then be deallocated in <code>imCompleteAsyncClosedCaptionScan</code>.</p> <p>The estimated duration of all the closed captions can also be filled in.</p> <p>This is useful for certain cases where the embedded captions contain many frames of empty data.</p> <pre><code>typedef struct {\n  void*        privatedata;\n  void*        prefs;\n  void*        outAsyncCaptionScanPrivateData;\n  csSDK_int64  outScale;\n  csSDK_int64  outSampleSize;\n  csSDK_int64  outEstimatedDuration;\n} imInitiateAsyncClosedCaptionScanRec;\n</code></pre> Member Description <code>privatedata</code> Instance data gathered during <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>prefs</code> Clip Source Settings data gathered during <code>imGetPrefs8</code> (setup dialog). <code>outAsyncCaptionScanPrivateData</code> The importer can allocate instance data for this closed caption scan, and pass it back here. <code>outScale</code> New in CC October 2013. The frame rate of the video clip, represented as scale over sampleSize. <code>outSampleSize</code> <code>outEstimatedDuration</code> New in CC October 2013. The estimated duration of all the captions, in the above timescale"},{"location":"importers/structure-descriptions/#immetadatarec","title":"imMetaDataRec","text":"<p>Selector: imGetMetaData and imSetMetaData</p> <p>Describes the metadata specific to a given four character code.</p> <pre><code>typedef struct {\n  void          *privatedata;\n  void          *prefs;\n  csSDK_int32   fourCC;\n  csSDK_uint32  buffersize;\n  char          *buffer;\n} imMetaDataRec;\n</code></pre> Member Description <code>privatedata</code> Instance data gathered during <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>prefs</code> Clip Source Settings data gathered during <code>imGetPrefs8</code> (setup dialog). <code>fourcc</code> Fourcc code of the metadata chunk. <code>buffersize</code> <code>Size</code> of the data in buffer. <code>buffer</code> The metadata."},{"location":"importers/structure-descriptions/#impeakaudiorec","title":"imPeakAudioRec","text":"<p>Selector: imGetPeakAudio</p> <p>Describes the peak values of the audio at the specified position.</p> <pre><code>typedef struct {\n  void           *inPrivateData;\n  void           *inPrefs;\n  PrAudioSample  inPosition;\n  float          inSampleRate;\n  csSDK_int32    inNumSampleFrames;\n  float          **outMaxima;\n  float          **outMinima;\n} imPeakAudioRec;\n</code></pre> Member Description <code>inPrivateData</code> Instance data gathered during <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>inPrefs</code> Instance data gathered during <code>imGetPrefs8</code> (setup dialog). <code>inPosition</code> The starting audio sample frame of the peak data. <code>inSampleRate</code> The sample rate at which to generate the peak data. <code>inNumSampleFrames</code> The number of sample frames in each buffer. <code>outMaxima</code> An array of arrays to be filled with the maximum sample values. <code>outMinima</code> An array of arrays to be filled with the minimum sample values."},{"location":"importers/structure-descriptions/#impreferredframesizerec","title":"imPreferredFrameSizeRec","text":"<p>Selector: imGetPreferredFrameSize</p> <p>Describes a frame size preferred by the importer.</p> <pre><code>typedef struct {\n  void           *inPrivateData;\n  void           *inPrefs;\n  PrPixelFormat  inPixelFormat;\n  csSDK_int32    inIndex;\n  csSDK_int32    outWidth;\n  csSDK_int32    outHeight;\n} imPreferredFrameSizeRec;\n</code></pre> Member Description <code>inPrivateData</code> Instance data gathered during <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>inPrefs</code> Clip Source Settings data gathered during <code>imGetPrefs8</code> (setup dialog). <code>inPixelFormat</code> The pixel format for this preferred frame size. <code>inIndex</code> The index of this preferred frame size. <code>outWidth</code> The dimensions of this preferred frame size. <code>outHeight</code>"},{"location":"importers/structure-descriptions/#imquerycontentstaterec","title":"imQueryContentStateRec","text":"<p>Selector: imQueryContentState</p> <p>Fill in the outContentStateID, which should be a GUID calculated based on the content state of the clip at inSourcePath.</p> <p>If the state hasn't changed since the last call, the GUID returned should be the same.</p> <pre><code>typedef struct {\n  const prUTF16Char*  inSourcePath;\n  prPluginID          outContentStateID;\n} imQueryContentStateRec;\n</code></pre>"},{"location":"importers/structure-descriptions/#imquerydestinationpathrec","title":"imQueryDestinationPathRec","text":"<p>Selector: imQueryDestinationPath</p> <p>Fill in the desired <code>outActualDestinationPath</code>, based on the <code>inSourcePath</code> and <code>inSuggestedDestinationPath</code>.</p> <pre><code>typedef struct {\n  void               *inPrivateData;\n  void               *inPrefs;\n  const prUTF16Char  *inSourcePath;\n  const prUTF16Char  *inSuggestedDestinationPath;\n  prUTF16Char        *outActualDestinationPath;\n} imQueryDestinationPathRec;\n</code></pre> Member Description <code>inPrivateData</code> Instance data gathered during <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>inPrefs</code> Clip Source Settings data gathered during <code>imGetPrefs8</code> (setup dialog). <code>inSourcePath</code> The path of the source file to be trimmed <code>inSuggestedDestinationPath</code> The path suggested by Premiere where the destination file should be created. <code>outActualDestinationPath</code> The path where the importer wants the destination file to be created."},{"location":"importers/structure-descriptions/#imqueryinputfilelistrec","title":"imQueryInputFileListRec","text":"<p>Selector: imQueryInputFileList</p> <p>Fill in the outContentStateID, which should be a GUID calculated based on the content state of the clip at <code>inSourcePath</code>.</p> <p>If the state hasn't changed since the last call, the GUID returned should be the same.</p> <pre><code>typedef struct {\n  void*        inPrivateData;\n  void*        inPrefs;\n  PrSDKString  inBasePath;\n  csSDK_int32  outNumFilePaths;\n  PrSDKString  *outFilePaths;\n} imQueryInputFileListRec;\n</code></pre> Member Description <code>inPrivateData</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>inPrefs</code> Clip Source Settings data gathered from <code>imGetPrefs8</code> (setup dialog info). <code>inBasePath</code> Path of main file that was passed earlier in <code>imOpenFile</code>. <code>outNumFilePaths</code> The first time <code>imQueryInputFileList</code> is sent, fill in the number of files that the media uses. <code>outFilePaths</code> The second time <code>imQueryInputFileList</code> is sent, this will be preallocated as an array of NULL strings.Use the String Suite to fill the array with PrSDKStrings with the actual paths."},{"location":"importers/structure-descriptions/#imquerystreamlabelrec","title":"imQueryStreamLabelRec","text":"<p>Selector: imQueryStreamLabel</p> <p>New in CS6. Based on the stream ID passed in, allocate and pass back a label for the stream.</p> <p>For stereoscopic importers, use the predefined labels in PrSDKStreamLabel.h.</p> <pre><code>typedef struct {\n  void          *inPrivateData;\n  csSDK_int32   *inPrefs;\n  csSDK_int32   inStreamIdx;\n  PrSDKString*  outStreamLabel;\n} imQueryStreamLabelRec;\n</code></pre> Member Description <code>privatedata</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>prefs</code> Clip Source Settings data gathered from <code>imGetPrefs8</code> (setup dialog info). <code>inStreamIdx</code> The ID of the stream that needs to be labeled. <code>outStreamLabel</code> The stream label, allocated using the String Suite."},{"location":"importers/structure-descriptions/#imsavefilerec8","title":"imSaveFileRec8","text":"<p>Selector: imSaveFile8</p> <p>Describes the file to be saved.</p> <pre><code>typedef struct {\n  void                *privatedata;\n  csSDK_int32         *prefs;\n  const prUTF16Char*  sourcePath;\n  const prUTF16Char*  destPath;\n  char                move;\n  importProgressFunc  progressCallback;\n  void                *progressCallbackID;\n} imSaveFileRec8;\n</code></pre> Member Description <code>privatedata</code> Instance data gathered from <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>prefs</code> Clip Source Settings data gathered from <code>imGetPrefs8</code> (setup dialog info). <code>sourcePath</code> Full path of the file to be saved. <code>destPath</code> Full path the file should be saved to. <code>move</code> If non-zero, this is a move operation and the original file (the sourcePath) can be deleted after copying is complete. <code>progressCallback</code> Function to call repeatedly to provide progress and to check for cancel by user. May be a NULL pointer, so make sure the function pointer is valid before calling. <code>progressCallbackID</code> Pass to <code>progressCallback</code>."},{"location":"importers/structure-descriptions/#imsourcevideorec","title":"imSourceVideoRec","text":"<p>Selector: imGetSourceVideo, <code>aiInitiateAsyncRead</code>, <code>aiGetFrame</code></p> <p>Describes the requested frame, to be passed back in outFrame.</p> <pre><code>typedef struct {\n  void              *inPrivateData;\n  csSDK_int32       currentStreamIdx;\n  PrTime            inFrameTime;\n  imFrameFormat     *inFrameFormats;\n  csSDK_int32       inNumFrameFormats;\n  bool              removePulldown;\n  PPixHand          *outFrame;\n  void              *prefs;\n  csSDK_int32       prefsSize;\n  PrSDKString       selectedColorProfileName;\n  PrRenderQuality   inQuality;\n  imRenderContext   inRenderContext;\n  PrSDKColorSpaceID   opaqueColorSpaceIdentifier;\n} imSourceVideoRec;\n</code></pre> Member Description <code>inPrivateData</code> Instance data gathered during <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>currentStreamIdx</code> New in CS6. If the clip has multiple streams (for stereoscopic video or otherwise), this ID differentiates between them. <code>inFrameTime</code> Time of frame requested. <code>inFrameFormats</code> An array of requested frame formats, in order of preference. If NULL, then any format is acceptable. <code>inNumFrameFormats</code> The number of frame formats in the <code>inFrameFormats</code>. <code>removePulldown</code> If true, pulldown should be removed if the pixel format supports it. <code>outFrame</code> Allocate memory to hold the requested frame, and pass it back here. <code>prefs</code> New in Premiere Pro 4.1. prefs data from <code>imGetPrefs8</code> <code>prefsSize</code> New in Premiere Pro 4.1. Size of prefs data. <code>selectedColorProfileName</code> New in Premiere Pro CS5.5. A string that specifies the color profile of the imported frame. <code>inQuality</code> New in Premiere Pro CC 2014. <code>inQuality</code> New in Premiere Pro CC 2014. <code>inQuality</code> New in Premiere Pro CC 2014."},{"location":"importers/structure-descriptions/#imsubtypedescriptionrec","title":"imSubTypeDescriptionRec","text":"<p>Selector: imGetSubTypeNames</p> <p>Added in Premiere Pro CS3. Describes the codec name associated with a given fourcc.</p> <pre><code>typedef struct {\n  csSDK_int32  subType;\n  prUTF16Char  subTypeName[256];\n} imSubTypeDescriptionRec;\n</code></pre>"},{"location":"importers/structure-descriptions/#imtimeinforec8","title":"imTimeInfoRec8","text":"<p>Selector: imGetTimeInfo8 and imSetTimeInfo8</p> <p>Describes the timecode and timecode rate associated with a clip.</p> <pre><code>typedef struct {\n  void         *privatedata;\n  void         *prefs;\n  char         orgtime[18];\n  csSDK_int32  orgScale;\n  csSDK_int32  orgSampleSize;\n  char         alttime[18];\n  csSDK_int32  altScale;\n  csSDK_int32  altSampleSize;\n  char         orgreel[40];\n  char         altreel[40];\n  char         logcomment[256];\n  csSDK_int32  dataType;\n} imTimeInfoRec;\n</code></pre> Member Description <code>privatedata</code> Instance data gathered during <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>prefs</code> Clip Source Settings data gathered during <code>imGetPrefs8</code> (setup dialog). <code>orgtime[18]</code> The original time in hours;minutes;seconds;frames, as captured from the source reel.The use of semi-colons indicates (to Premiere) drop-frame timecode, e.g. \"00;00;00;00\".Use colons for non-drop-frame timecode, e.g. \"00:00:00:00\". <code>orgScale</code> Timebase of the timecode in orgtime, represented as scale over sampleSize. <code>orgSampleSize</code> <code>alttime[18]</code> An alternative timecode (may differ from the source timecode), formatted as described above. <code>altScale</code> Timebase of the timecode in alttime. <code>altSampleSize</code> <code>orgreel[40]</code> Original reel name. <code>altreel[40]</code> Alternate reel name. <code>logcomment[256]</code> Comment string. <code>dataType</code> Currently always set to 1, denoting SMPTE timecode. More values may be added in the future."},{"location":"importers/structure-descriptions/#imtrimfilerec8","title":"imTrimFileRec8","text":"<p>Selector: imTrimFile8</p> <p>Describes how to trim a clip, based on information returned by the importer during <code>imCheckTrim8</code>.</p> <p>Also provides a callback to update the progress bar and check if the user has cancelled.</p> <pre><code>typedef struct {\n  void                *privatedata;\n  void                *prefs;\n  csSDK_int32         trimIn;\n  csSDK_int32         duration;\n  csSDK_int32         keepAudio;\n  csSDK_int32         keepVideo;\n  const prUTF16Char   *destFilePath;\n  csSDK_int32         scale;\n  csSDK_int32         sampleSize;\n  importProgressFunc  progressCallback;\n  void                *progressCallbackID;\n} imTrimFileRec8;\n</code></pre> Member Description <code>privatedata</code> Instance data gathered during <code>imGetInfo8</code> or <code>imGetPrefs8</code>. <code>prefs</code> Clip settings data gathered during <code>imGetPrefs8</code> (setup dialog). <code>trimIn</code> In point of the trimmed clip, in the timebase specified by scale and sampleSize. <code>duration</code> Duration of the trimmed clip. If 0, then the request is to leave the clip untrimmed, and at the current duration <code>keepAudio</code> If non-zero, the request is to keep the audio in the trimmed result. <code>keepVideo</code> If non-zero, the request is to keep the video in the trimmed result. <code>destFilePath</code> The unicode path and name of the file to create. <code>scale</code> The frame rate of the video, represented as scale over sampleSize. <code>sampleSize</code> <code>progressCallback</code> <code>importProgressFunc</code> callback to call repeatedly to provide progress and to check for cancel by user.May be a NULL pointer, so make sure the function pointer is valid before calling. <code>progressCallbackID</code> Pass to <code>progressCallback</code>."},{"location":"importers/structure-descriptions/#imindcolorspacerec","title":"imIndColorSpaceRec","text":"<p>Selector: imGetIndColorSpace</p> <p>Describes the colorspace of the media.</p> <pre><code>typedef ColorSpaceRec imIndColorSpaceRec;\n\ntypedef struct {\n  void                 *privatedata;\n  PrSDKColorSpaceType  outColorSpaceType;\n  RawColorProfileRec   ioProfileRec;\n  prSEIColorCodesRec   outSEICodesRec;\n} ColorSpaceRec;\n</code></pre> Member Description <code>privatedata</code> Private. <code>outColorSpaceType</code> One of the following:<ul><li><code>kPrSDKColorSpaceType_Undefined</code></li><li><code>kPrSDKColorSpaceType_ICC</code></li><li><code>kPrSDKColorSpaceType_LUT</code> // DO NOT USE after 14.x.</li><li><code>kPrSDKColorSpaceType_SEITags</code></li><li><code>kPrSDKColorSpaceType_MXFTags</code> // DO NOT USE, Not supported.</li><li><code>kPrSDKColorSpaceType_Predefined</code></li></ul> <code>ioProfileRec</code> A structure describing the color profile.<pre>csSDK_int32  ioBufferSize;void*        inDestinationBuffer;PrSDKString  outName;</pre> <code>outSEICodesRec</code> A structure describing the color space using codes; used with H.265, HEVC, AVC andProRes media.<pre>csSDK_int32  colorPrimariesCode;csSDK_int32  transferCharacteristicCode;csSDK_int32  matrixEquationsCode;csSDK_int32  bitDepth;prBool       isFullRange;prBool       isRGB;</pre>"},{"location":"importers/structure-descriptions/#rawcolorspacerec","title":"RawColorSpaceRec","text":"<p>Selector: <code>imGetIndColorSpace</code></p> <p>Describes the colorspace in use with the media.</p> <pre><code>typedef struct\n{\n        PrSDKColorSpaceType           colorSpaceType;\n        RawColorProfileRec            profileRec;   // for ICC and Predefined Color Spaces\n        prSEIColorCodesRec            seiCodesRec;  // H-265 codes for HEVC, AVC, ProRes\n} RawColorSpaceRec;\n</code></pre> Member Description <code>colorSpaceType</code> One of the following:<ul><li><code>kPrSDKColorSpaceType_Undefined</code></li><li><code>kPrSDKColorSpaceType_ICC</code></li><li><code>kPrSDKColorSpaceType_LUT</code> // DO NOT USE after 14.x.</li><li><code>kPrSDKColorSpaceType_SEITags</code></li><li><code>kPrSDKColorSpaceType_MXFTags</code> // DO NOT USE, Not supported.</li><li><code>kPrSDKColorSpaceType_Predefined</code></li></ul> profileRec A structure describing the color space.<pre>csSDK_int32  ioBufferSize;void*        inDestinationBuffer;PrSDKString  outName;</pre> <code>seiCodesRec</code> A structure describing the color space; used with H.265, HEVC, AVC and ProRes media.<pre>csSDK_int32  colorPrimariesCode;csSDK_int32  transferCharacteristicCode;csSDK_int32  matrixEquationsCode;csSDK_int32  bitDepth;prBool       isFullRange;prBool       isRGB;</pre> <p>Colorspace can be described via multiple way, type depends on <code>colorSpaceType</code>.</p> <p>If type is <code>kPrSDKColorSpaceType_Predefined</code> - Color space is specified via predefined strings from <code>PrSDKColorSpaces.h</code>.</p> <p>If type is <code>kPrSDKColorSpaceType_ICC</code> - Color space is specified via ICC profile in <code>profileRec</code>.</p> <p>If type is <code>kPrSDKColorSpaceType_SEITags</code> - Color space is specified via enums codes for color primaries (C), transfer characteristic (T),  matrix equation (M). Supported C-T-M enums are defined in <code>PrSDKColorSEICodes.h</code>.</p>"},{"location":"importers/structure-descriptions/#embeddedlutrec","title":"EmbeddedLUTRec","text":"<p>Selector: <code>imGetIndColorSpace</code></p> <p>Describes the LUT embedded with in the media.</p> <pre><code>typedef struct\n{\n  void*               privateData;\n  RawColorProfileRec  lutBlobRec;\n  RawColorSpaceRec    lutInColorSpaceRec;\n  RawColorSpaceRec    lutOutColorSpaceRec;\n} EmbeddedLUTRec;\n</code></pre> Member Description <code>privatedata</code> Private. <code>lutBlobRec</code> Describes the embedded LUT. <code>lutInColorSpaceRec</code> Describes the LUT input colorspace rec. <code>lutOutColorSpaceRec</code> Describes the LUT output colorspace rec."},{"location":"importers/structure-descriptions/#imrendercontext","title":"imRenderContext","text":"<p>Selector: imGetSourceVideo (member of imSourceVideoRec)</p> <p>Describes the context of the render; why it's occurring, and what rate and ratio is in use.</p> <pre><code>typedef struct\n{\n  imRenderIntent inIntent;\n  double inPlaybackRatio;\n  double inPlaybackRate;\n} imRenderContext;\n</code></pre> Member Description <code>inIntent</code> The intent of the render being requested.<ul><li><code>imRenderIntent_Unknown</code> (-1)</li><li><code>imRenderIntent_Export</code> 0</li><li><code>imRenderIntent_Stopped</code> // DO NOT USE after 14.x.</li><li><code>imRenderIntent_Scrubbing</code></li><li><code>imRenderIntent_Preroll</code></li><li><code>imRenderIntent_Playing</code></li><li><code>imRenderIntent_SpeculativePrefetch</code></li><li><code>imRenderIntent_Thumbnail</code> // DO NOT USE after 14.x.</li><li><code>imRenderIntent_Analysis</code></li><li><code>imRenderIntent_ExportPreview</code></li><li><code>imRenderIntent_ExportProxies</code></li></ul> <code>inPlaybackRatio</code> <code>1.0</code> means full framerate, lower values indicate deteriorating playback. <code>inPlaybackRate</code> <code>1.0</code> means 1x forward, <code>-1.0</code> means 1x backward."},{"location":"importers/structures/","title":"Structures","text":"Structure Sent with selector imAcceleratorRec imRetargetAccelerator imAnalysisRec imAnalysis imAsyncImporterCreationRec imCreateAsyncImporter imAudioInfoRec7 imGetInfo8 (member of imFileInfoRec8) imCalcSizeRec imCalcSize8 imCheckTrimRec imCheckTrim8 imClipFrameDescriptorRec imSelectClipFrameDescriptor imCompleteAsyncClosedCaptionScanRec imCompleteAsyncClosedCaptionScan imIndColorProfileRec imGetIndColorProfile imCopyFileRec imCopyFile imDataRateAnalysisRec imDataRateAnalysis imDeferredProcessingRec imDeferredProcessing imDeleteFileRec imDeleteFile imFileAccessRec8 imGetInfo8 and imGetPrefs8 imFileAttributesRec imGetFileAttributes imFileInfoRec8 imGetInfo8 imFileOpenRec8 imOpenFile8 imFileRef <ul><li>imAnalysis</li><li>imDataRateAnalysis</li><li>imOpenFile8</li><li>imQuietFile</li><li>imCloseFile</li><li>imGetTimeInfo8</li><li>imSetTimeInfo8</li><li>imImportImage</li><li>imImportAudio7</li></ul> <code>imFileSpec</code> <ul><li>imGetInfo8</li><li>imGetPrefs8</li><li>imSaveFile8</li><li>imDeleteFile</li><li>imTrimFile8</li></ul>Member of:<ul><li>imFileAccessRec8</li><li>imSaveFileRec8</li><li>imDeleteFileRec</li><li>imTrimFileRec8</li></ul> imFrameFormat imGetSourceVideo (member of imSourceVideoRec) imGetNextClosedCaptionRec imGetNextClosedCaption imGetPrefsRec imGetPrefs8 imImageInfoRec imGetInfo8 (member of imFileInfoRec8) imImportAudioRec7 imImportAudio7 imImportImageRec imImportImage imImportInfoRec imInit imIndFormatRec imGetIndFormat imIndPixelFormatRec imGetIndPixelFormat imInitiateAsyncClosedCaptionScanRec imInitiateAsyncClosedCaptionScan imMetaDataRec imGetMetaData and imSetMetaData imPeakAudioRec imGetPeakAudio imPreferredFrameSizeRec imGetPreferredFrameSize imQueryContentStateRec imQueryContentState imQueryDestinationPathRec imQueryDestinationPath imQueryInputFileListRec imQueryInputFileList imQueryStreamLabelRec imQueryStreamLabel <code>imRollCrawlInfoRec</code> <code>imGetRollCrawlInfo</code> <code>imRollCrawlRenderRec</code> <code>imRollCrawlRenderPage</code> imSaveFileRec8 imSaveFile8 imSourceVideoRec imGetSourceVideo imSubTypeDescriptionRec imGetSubTypeNames imTimeInfoRec8 imGetTimeInfo8 and imSetTimeInfo8 imTrimFileRec8 imTrimFile8"},{"location":"importers/suites/","title":"Suites","text":""},{"location":"importers/suites/#suites_1","title":"Suites","text":"<p>For information on how to acquire and manage suites, see SweetPea Suites.</p>"},{"location":"importers/suites/#async-file-reader-suite","title":"Async File Reader Suite","text":"<p>New in Premiere Pro CS5. A cross-platform file handling suite.</p>"},{"location":"importers/suites/#deferred-processing-suite","title":"Deferred Processing Suite","text":"<p>Allows an importer to schedule processing time when importing asynchronously, and to notify the user that the media item is pending additional processing.</p> <p>In the Project panel, the name of the item will be italicized, and its thumbnail will show as Pending.</p>"},{"location":"importers/whats-new/","title":"What's New","text":""},{"location":"importers/whats-new/#whats-new-in-premiere-pro-cc-2019-130","title":"What's New in Premiere Pro CC 2019 (13.0)","text":"<p>We've begun adding colorspace support to Premiere Pro's APIs, beginning with Importers.</p> <p>Adding APIs <code>AddFrameToCacheWithColorSpace()</code> and <code>GetFrameFromCacheWithColorSpace()</code> which will deprecate <code>AddFrameToCacheWithColorProfile2()</code> and <code>GetFrameFromCacheWithColorProfile2()</code>.</p>"},{"location":"importers/whats-new/#whats-new-in-premiere-pro-cc-2014","title":"What's New in Premiere Pro CC 2014","text":"<p>Importers can now choose the format they are rendering in, which allows importers to change pixel formats and quality based on criteria like enabled hardware and other Clip Source Settings, such as HDR. To handle the negotiation, implement <code>imSelectClipFrameDescriptor</code>.</p> <p><code>imSourceVideoRec</code> now includes a quality attribute. PPix Cache Suite is now at version 6, adding <code>AddFrameToCacheWithColorProfile2()</code> and <code>GetFrameFromCacheWithColorProfile2()</code>, which are the same as the ones added in version 5 with the addition of a PrRenderQuality parameter.</p> <p><code>imFileInfoRec8.highMemUsage</code> is no longer supported.</p>"},{"location":"importers/whats-new/#whats-new-in-premiere-pro-cc-october-2013-release","title":"What's New in Premiere Pro CC October 2013 release?","text":"<p><code>imInitiateAsyncClosedCaptionScanRec</code> now provides extra fields for the importer to fill in the estimated duration of all the captions. This is useful for certain cases where the embedded captions contain many frames of empty data.</p>"},{"location":"importers/whats-new/#whats-new-in-premiere-pro-cc","title":"What's New in Premiere Pro CC?","text":"<p>Starting in CC, importers can support closed captioning that is embedded in the source media. Note that Premiere Pro can also import and export captions in a sidecar file (e.g. .mcc, .scc, or</p> <p>.xml) alongside any media file, regardless of the media file format. This does not require any specific work on the importer side. The importer only needs to add support if it will support embedded closed captions.</p> <p>Importers can now support audio beyond basic mono, stereo, and 5.1, without implementing multiple streams (existing importers do not need to be updated). The importer specifies a channel layout by implementing the new <code>imGetAudioChannelLayout</code> selector. Otherwise the channel layout will be assumed to be discrete.</p> <p>The clip preferences are now passed with <code>imIndPixelFormatRec</code>, so that an importer can choose to return varying pixel formats depending on the Clip Source Settings.</p>"},{"location":"importers/whats-new/#whats-new-in-premiere-pro-cs602","title":"What's New in Premiere Pro CS6.0.2?","text":"<p>This release adds more support for growing files by adding a new flag, <code>imFileInfoRec8.mayBeGrowing</code>.</p>"},{"location":"importers/whats-new/#whats-new-in-premiere-pro-cs6","title":"What's New in Premiere Pro CS6?","text":"<p>Importers can now bring in stereoscopic footage as a single clip with separate left and right channels.</p> <p>With some additional work, importers can now support growing files. The refresh rate for growing files is set by the user in Preferences &gt; Media &gt; Growing Files. The importer should get the refresh rate using the new call <code>GetGrowingFileRefreshInterval()</code> in the Importer File Manager Suite. Call <code>RefreshFileAsync()</code> to refresh the file.</p> <p>A new selector, <code>imQueryInputFileList</code>, was added to support Collect Files in After Effects for file types that use more than a single file. In imImportInfoRec, a new member, <code>canProvideFileList</code>, specifies whether the importer can provide a list of all files for a copy operation. If the importer does not implement this selector, the host will assume the media just uses a single file at the original imported media path.</p> <p>The Media Accelerator Suite is now at version 4. <code>FindPathInDatabaseAndValidateContentState</code> provides a new way to find existing media accelerators, making sure they are up-to-date.</p> <p>Importers can now choose whether or not they want to provide peak audio data on a clip-by-clip basis.</p> <p>The importer-wide setting still remains in <code>imImportInfoRec.canProvidePeakAudio</code>, but an importer can override the general setting by setting <code>imFileInfoRec8.canProvidePeakAudio</code> appropriately.</p>"},{"location":"importers/whats-new/#whats-new-in-premiere-pro-cs55","title":"What's New in Premiere Pro CS5.5?","text":"<p>Importers can now support color management, when running in After Effects. The importer should set <code>imImageInfoRec.colorProfileSupport</code> to <code>imColorProfileSupport_Fixed</code>, and then describe the color profiles supported by the clip using the new <code>imGetIndColorProfile</code> selector. When importing the frame, specify the color profile in <code>imSourceVideoRec. selectedColorProfileName</code>. The PPix Cache Suite has been updated to differentiate between color profiles as well.</p> <p>New <code>canProvidePeakAudio</code> flag to allow an importer to provide peak audio data by responding to <code>imGetPeakAudio</code>.</p> <p>The new return value, <code>imRequiresProtectedContent</code>, allows an importer to be disabled if a library it depends on has not been activated.</p>"},{"location":"importers/whats-new/#whats-new-in-premiere-pro-cs5","title":"What's New in Premiere Pro CS5?","text":"<p>When an importer's settings dialog is opened, the importer now has access to the resolution, pixel aspect ratio, timebase, and audio sample rate of the source clip, in <code>imGetPrefsRec</code>.</p> <p>Custom importers can now use a new call in the Importer File Manager Suite, <code>RefreshFileAsync()</code>, to be able to update a clip after it is modified in <code>imGetPrefs8</code>.</p> <p>Two new selectors have been added.</p> <ul> <li><code>imQueryDestinationPath</code> allows importers that trim or copy files to be able to change the destination path of the trimmed or copy file.</li> <li><code>imQueryContentState</code> gives the host an alternate way of checking the state of a clip, for clips that have multiple source files.</li> </ul> <p>A new return value, <code>inFileNotAvailable</code> can be returned from <code>imQueryContentState</code> if the clip is no longer available because it is offline or has been deleted.</p> <p>As a convenience, when a file is opened, an importer can tell Premiere Pro how much memory to reserve for the importer's usage, rather than calling ReserveMemory in the Memory Manager Suite. The importer should pass back this value in <code>imFileOpenRec8.outExtraMemoryUsage</code>.</p> <p>Several new return values are available for more descriptive error reporting:</p> <ul> <li><code>imBadHeader</code>,</li> <li><code>imUnsupportedCompression</code>,</li> <li><code>imFileOpenFailed</code>,</li> <li><code>imFileHasNoImportableStreams</code>,</li> <li><code>imFileReadFailed</code>,</li> <li><code>imUnsupportedAudioFormat</code>,</li> <li><code>imUnsupportedVideoBitDepth</code>,</li> <li><code>imDecompressionError</code>, and</li> <li><code>imInvalidPreferences</code></li> </ul>"},{"location":"importers/whats-new/#whats-new-in-premiere-pro-cs4","title":"What's New in Premiere Pro CS4?","text":"<p>For CS4 only, importers are loaded and called from a separate process. As a result of being in a separate process, (1) all importers must do their own file handling, (2) privateData is no</p> <p>longer accessible from <code>imGetPrefs8</code>, and (3) the compressed frame selectors such as <code>imGetCompressedFrame</code> are no longer supported (this may now be achieved using custom pixel formats and a renderer plugin).</p> <p>To debug importers, attach to the <code>ImporterProcessServer</code> process. There is also a separate Importer Process Plugin Loading.log.</p> <p>All legacy selectors have been removed, and are now longer supported. All structures used only in these legacy selectors have been removed as well.</p> <p>There are built-in XMP metadata handlers for known filetypes. These handlers write and read metadata to and from the file, without going through the importer. <code>imSetTimeInfo8</code> is no longer called, since this is set by the XMP handler for that filetype.</p> <p>All file-based importers (which does not include synthetics) are required to do their own file handling now, rather than having Premiere Pro open the files. The <code>imCallbackFuncs</code>: <code>OpenFileFunc</code> and <code>ReleaseFileFunc</code> are no longer supported.</p> <p>Due to the out-of-process importing, <code>privateData</code> is not accessible during <code>imGetPrefs8</code>, and has been removed from <code>imGetPrefsRec</code>.</p> <p><code>imGetFrameInfo</code>, <code>imDisposeFrameInfo</code>, <code>imGetCompressedFrame</code>, and <code>imDisposeCompressedFrame</code> are no longer supported. Supporting a custom pixel format in an importer, a renderer, and an exporter is the new way to implement smart rendering, by passing custom compressed data from input to output.</p> <p>New <code>imFrameNotFound</code> return code. Returned if an importer could not find the requested frame (typically used with async importers).</p> <p>New in Premiere Pro 4.1, importer prefs are now part of imSourceVideoRec, passed to both <code>imGetSourceVideo</code> and the async import calls</p> <p>New in Premiere Pro 4.1, there is a new filepath member in imFileInfoRec8. For clips that have audio in files separate from the video file, set the filename here, so that UMIDs can properly be generated for AAFs.</p>"},{"location":"importers/whats-new/#whats-new-in-premiere-pro-cs3","title":"What's New in Premiere Pro CS3?","text":"<p>Importers can specify an initial poster frame for a clip in imImageInfoRec.</p> <p>Importers can specify subtype names during the new <code>imGetSubTypeNames</code> selector. This selector is sent after each <code>imGetIndFormat</code>, which gives an importer the opportunity to enumerate all the fourCCs and display names (e.g. \"Cinepak\") of their known compression types for a specific filetype. The importer can return imUnsupported, or create an array of <code>imSubTypeDescriptionRec</code> records (pairs of fourCCs and codec name strings) for all the codecs/subtypes it knows about.</p> <p>Importers that open their own files should specify how many files they keep open between <code>imOpenFile8</code> and <code>imQuietFile</code> using the new Importer File Manager Suite, if the number is not equal to one. Importers that don't open their own files, or importers that only open a single file should not use this suite. Premiere's File Manager now keeps track of the number of files held open by importers, and limits the number open at a time by closing the least recently used files when too many are open. On Windows, this helps memory usage, but on Mac OS this addresses a whole class of bugs that may occur when too many files are open.</p> <p>Importers can also specify that certain files have very high memory usage, by setting <code>imFileInfoRec8.highMemUsage</code>. The number of files allowed to be open with this flag set to true is currently capped at 5.</p> <p>Importers can now specify an arbitrary matte color for premultiplied alpha channels in <code>imImageInfoRec.matteColor</code>. Importers can state that they are uncertain about a clip's pixel aspect ratio, field type, or alpha info in imImageInfoRec.interpretationUncertain.</p> <p>The imInvalidHandleValue is now -1 for Mac OS.</p> <p>Importers can specify a transform matrix for frames by setting <code>imImageInfoRec.canTransform = kPrTrue</code>, and then during <code>imImportImage</code>, when <code>imImportImageRec.applyTransform</code> is non-zero, use <code>imImportImageRec.transform</code>, and <code>destClipRect</code> to calculate the transform - This code path is currently not called by Premiere Pro. After Effects uses this call to import Flash video.</p> <p>New in Premiere Pro 3.1, the new capability flag, <code>imImportInfoRec.canSupplyMetadataClipName</code>, allows an importer to set the clip name from metadata, rather than the filename. The clip name should be set in <code>imFileInfoRec8.streamName</code>. This is useful for clips recorded by some new file-based cameras.</p> <p>New in Premiere Pro 3.1, the new <code>imGetFileAttributes</code> selector allows an importer to provide the clip creation date in the new imFileAttributesRec.</p>"},{"location":"intro/best-practices/","title":"Best Practices","text":"<p>When a plugin receives a selector it doesn't recognize, it should always return the code specific to the plugin type that means the selector is not supported (i.e. imUnsupported, rmUnsupported, etc).</p> <p>In this way, new selectors can be added to the API and legacy plugins will automatically answer whether or not they support it.</p>"},{"location":"intro/best-practices/#structure-alignment","title":"Structure Alignment","text":"<p>All the sample projects include <code>PrSDKTypes.h</code>.</p> <p>This header sets the proper (single-byte) structure alignment and specifies the necessary (C-style) external linkage.</p>"},{"location":"intro/debugging-plugins/","title":"Debugging Plug-Ins","text":"<p>Once you've got the plugin building directly into the plugins folder as explained above, here's how to specify Premiere Pro as the application to run during debug sessions:</p>"},{"location":"intro/debugging-plugins/#windows","title":"Windows","text":"<ol> <li>In the Visual Studio solution, in the Solution Explorer panel, choose the project you want to debug</li> <li>Right-click it and choose Set as StartUp Project</li> <li>Right-click it again and choose Properties</li> <li>In Configuration Properties &gt; Debugging &gt; Command, provide the path to the executable file of the host application the plugins will be running in (this may be Premiere Pro or After Effects)</li> <li>From there you can either hit the Play button, or you can launch the application and later at any point choose Debug &gt; Attach to Process\u2026</li> </ol>"},{"location":"intro/debugging-plugins/#macos","title":"macOS","text":"<ol> <li>In Xcode, in the Project Navigator, choose the xcodeproj you want to debug</li> <li>Choose Product &gt; Scheme &gt; Edit Scheme\u2026</li> <li>Under Run, in the Info tab, for Executable, choose the host application the plugins will be running in (this may be Premiere Pro or After Effects)</li> <li>From there you can either hit the Play button to build and run the current scheme, or you can launch the application and later at any point choose Debug &gt; Attach to Process.</li> </ol> <p>Another way to do this in Visual Studio is by placing a line of code</p> <pre><code>_asm int 3;\n</code></pre> <p>or</p> <pre><code>DebugBreak();\n</code></pre> <p>You will then receive the Microsoft error reporting message, but if you hit the Debug button you will enable Just-In-Time Debugging and can attach to the process.</p>"},{"location":"intro/document-overview/","title":"Document Overview","text":"<p>This introduction information is common to all the plugin types.</p> <p>All developers should read this chapter, and browse through chapters two and three before diving too deep into plugin development.</p> <p>Resources is a short chapter that describes the Premiere Pro-specific resources used by plugins, including the Plug-in Property List (PiPL).</p> <p>Universals documents concepts, data types, and structures used throughout the APIs. It also describes suites and functions used by more than one type of plugin.</p> <p>Hardware introduces Media Abstraction, used by hardware integrators and software developers to integrate with Premiere and accelerate specific workflows.</p> <p>This document is designed to be read non-linearly. You can browse through the topics from the bookmarks that appear in the left-hand panel in Acrobat, or the right-hand panel in the Preview application on macOS. A simple search for a well-chosen keyword will also turn up much information on any given topic.</p>"},{"location":"intro/document-overview/#documentation-conventions","title":"Documentation Conventions","text":"<p>Functions, structure names and general C/C++ code are in Courier; <code>MyStruct.member</code> and <code>MyFunction()</code></p> <p>Underlined text in light blue is hyperlinked. Premiere selectors are italicized; imGetPrefs.</p>"},{"location":"intro/getting-support/","title":"Getting Support and Providing Feedback","text":"<p>Please read relevant sections of this document and view the included sample code before requesting assistance. Please direct questions regarding installation, configuration, or use of Adobe products to Adobe Technical Support.</p> <p>Having a solid understanding of digital video concepts is vital to developing plugins. This documentation assumes you understand basic video topics such as resolution, frame rates, field interlacing, pixel aspect ratio, bit depth, timecode, compression, color spaces, etc. You must also understand how your plugin will fit into a user's workflow in Premiere Pro. If you aren't yet familiar with Premiere Pro or video editing concepts, we recommend the Adobe Premiere Pro Classroom in a Book.</p> <p>Use the Premiere Pro SDK forum to ask questions on the API and general integration.</p>"},{"location":"intro/load-em-up/","title":"Load Em Up","text":""},{"location":"intro/load-em-up/#plug-in-caching","title":"Plug-in Caching","text":"<p>On its first launch, Premiere Pro loads all the plugins, reads the Plug-In Property Lists (PiPL) Resource, and sends any startup selectors to determine the plugins' capabilities. To speed up future application launches, it saves some of these capabilities in what we call the plugin cache (the registry on Windows, a Property List file on macOS).</p> <p>The next time the application is launched, the cached data is used wherever possible, rather than loading all the plugins on startup. Using this changed data will make the application launch faster, but for a small set of plugins that need to be initialized every time, it may be undesirable. These include plugins that need to get run-time information that might change in between app launches (i.e. installed codec lists), and plugins that check for hardware and need to be able to fail. So we give your plugin control final say over whether or not it is reloaded each time.</p> <p>By default, importers, recorders, and exporters are not cached. Exporters can be cached by setting exExporterInfoRec.isCacheable to non-zero during exSelStartup. Importers and recorders can be cached by returning <code>*IsCacheable</code> instead of <code>*NoError</code> (e.g. for importers, imIsCacheable instead of imNoError) on the startup selector.</p> <p>By default, legacy video filters and device controllers are cached by default. To specify that legacy video filters must be reloaded each time, rather than cached, Premiere filters should respond to fsCacheOnLoad.</p>"},{"location":"intro/load-em-up/#resolving-plug-in-loading-problems","title":"Resolving Plug-in Loading Problems","text":"<p>There are various tools to help in the development process.</p> <p>On Windows only, you can force Premiere to reload all the plugins by holding down shift on startup. The plugin cache on macOS may be deleted manually from the user folder, at <code>~/Library/Preferences/com.Adobe.Premiere Pro [version].plist.</code></p> <p>For plugin loading issues, you may first check one of the plugin loading logs.</p> <p>On Windows: <code>[user folder]\\AppData\\Roaming\\Adobe\\Premiere Pro\\[version number]\\Plugin Loading.log</code></p> <p>On macOS, this is: <code>~/Library/Application Support/Adobe/Premiere Pro/[version number]/Plugin Loading.log</code></p> <p>Your plugin will be listed by path and filename, and the log will contain details on what happened during the plugin loading process. Starting in CC 2017, it now logs any error codes returned from an effect on PF_Cmd_GLOBAL_SETUP.</p> <p>If the log says a plugin has been marked as Ignore, the most common culprit is a library dependency that could not be loaded. If your plugin uses some image processing or proprietary code library, is it installed on the system, and in the right place? On Windows, a tool such as Dependency Walker (depends.exe) is helpful to check a plugin's dependencies.</p>"},{"location":"intro/load-em-up/#library-linkage","title":"Library Linkage","text":"<p>On Windows, we strongly recommend dynamically linking to libraries, rather than static linking. In Visual Studio, the runtime library linkage setting is in C/C++ &gt; Code Generation &gt; Runtime Library.</p> <p>We ask developers to compile with the /MD flag (or /MDd for debug builds), and not with the /MT flag.</p> <p>Failure to do so can contribute to the problem where the Premiere Pro process can run out of fiber-local storage slots, and subsequent plugins fail to load.</p>"},{"location":"intro/load-em-up/#no-shortcuts","title":"No Shortcuts","text":"<p>The Premiere Pro plugin loader does not follow Windows shortcuts. Although it does follow macOS symbolic links, we recommend against using symbolic links in the plugins folder, since the plugin loader checks the timestamp of the symbolic link rather than the timestamp of the plugin pointed to.</p> <p>Explanation: If you use a symbolic link and the plugin fails to load once (for example, if the plugin pointed to isn't there) it will be marked to ignore when Premiere launches. Even if the plugin is restored to the proper location, the plugin loader will check the modification time of</p> <p>the symbolic link, rather than the plugin pointed to, and continue to ignore the plugin until the modification date of the symbolic link is updated. So plugins should be placed directly in a plugins folder or subfolder.</p>"},{"location":"intro/localization/","title":"Localization","text":"<p>The language used by Premiere Pro is decided by the user during installation.</p> <p>Plug-ins can determine this setting from the following locations:</p> <p>On Windows, in the registry at <code>HKEY_CURRENT_USER\\Software\\Adobe\\Premiere Pro\\[version]</code>, in a key named <code>\"Language\"</code>.</p> <p>On macOS, at <code>~/Library/Preferences/com.Adobe.Premiere Pro.[version].plist</code>, at <code>Root &gt; Language</code>.</p> <p>The string will be set to one of the values below by Premiere Pro at startup.</p> Language String English <code>en_US</code> French <code>fr_FR</code> German <code>de_DE</code> Italian <code>it_IT</code> Japanese <code>ja_JP</code> Spanish <code>es_ES</code> Korean <code>ko_KR</code> Chinese (new in CC) <code>zh_CN</code> Russian (new in CC 2014) <code>ru_RU</code> Brazilian Portugese (new in CC 2014) <code>pt_BR</code> <p>Changing the string will not change the language Premiere Pro runs in, unless you override the application language by placing a file in the following location:</p> <p>Windows: <code>[App installation folder]\\lang-override.txt</code></p> <p>macOS: <code>[App Installation folder]/[Premiere Pro application package]/Contents/lang-override.txt</code></p>"},{"location":"intro/plugin-installation/","title":"Plug In Installation","text":"<p>Plug-ins must have an installer. This simplifies installation by the user, provides more compact distribution, and ensures all the pieces are installed correctly.</p> <p>Create a container folder for your plug-in(s) to minimize user confusion.</p> <p>Don't unintentionally overwrite existing plugins, or replace newer versions.</p> <p>The installer should find the default installation directories as described below.</p> <p>It is also appreciated when an installer allows the user to specify an alternate directory.</p> <p>Plugins should be installed in the common plugin location.</p> <p>Supported Premiere and After Effects plugins installed here will be loaded by Premiere Pro, After Effects, Audition, and Media Encoder.</p> <p>Other plugin types, such as QuickTime and VfW codecs should be installed at the operating system level.</p>"},{"location":"intro/plugin-installation/#windows","title":"Windows","text":"<p>As of Premiere Pro version 22.0, the <code>\\Plug-ins</code> directories have been renamed <code>\\Plugins</code>, to better coincide with Apple's Human Interface Guidelines. Premiere Pro will continue to attempt to load plugins from <code>\\Plug-Ins</code> directories as well, for the foreseeable future. We will continue to specify</p> <p>Starting in CC, each version of Premiere Pro will create a unique registry key that provide locations of folders of interest for third-party installations for that version.</p> <p>For example, here are the registry values for CC 2015.3:</p> <p>Key: <code>HKEY_LOCAL_MACHINE/Software/Adobe/Premiere Pro/10.0/</code></p> <p>Value name: <code>CommonPluginInstallPath</code></p> <p>Value data: <code>C:\\Program Files\\Adobe\\Common\\Plugins\\7.0\\MediaCore\\\\</code> (or whatever the proper MediaCore plugins folder is; note that this is the same as what the After Effects installer provides for a corresponding registry key)</p> <p>Starting in CC 2015.3, control surface plugins should be installed here:</p> <p><code>/Library/Application Support/Adobe/Common/Plug-ins/ControlSurface/</code></p> <p>For sequence presets:</p> <p>Value name: <code>SequencePresetsPath</code></p> <p>Value data: <code>[Adobe Premiere Pro installation path]\\Settings\\SequencePresets\\</code></p> <p>For sequence preview presets:</p> <p>Value name: <code>SequencePreviewPresetsPath</code></p> <p>Value data: <code>[Adobe Premiere Pro installation path]\\Settings\\EncoderPresets\\SequencePreview\\</code></p> <p>For exporter presets:</p> <p>Value name: <code>CommonExporterPresetsPath</code></p> <p>Value data: [User folder]AppDataRoamingAdobeCommonAME7.0Presets\\</p> <p>Effects presets:</p> <p>Value name: <code>PluginInstallPath</code></p> <p>Value data: <code>[Adobe Premiere Pro installation path]\\Adobe Premiere Pro\\Plugins\\Common</code></p> <p>Third-party installers can start from this path, and then modify the string to build the path to the language-specific effect presets.</p> <p>Prior to CC, the only path given in the registry was the common plug-in path for the most recently installed version of Premiere Pro:</p> <p>HKEY_LOCAL_MACHINE/Software/Adobe/Premiere Pro/CurrentVersion</p> <p>Value name: <code>Plug-InsDir</code></p> <p>Value data: <code>REG_SZ</code> containing the full path of the plugin folder.</p> <p>As an example: <code>C:\\Program Files\\Adobe\\Common\\Plugins\\7.0\\MediaCore\\</code></p> <p>The best way to locate other preset folders was to start from the root path for Premiere Pro in the registry at</p> <p><code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\\\ Adobe Premiere Pro.exe</code>.</p> <p>Then, just add the proper subdirectories as described in the macOS section.</p>"},{"location":"intro/plugin-installation/#macos","title":"macOS","text":"<p>Starting in Premiere Pro version 22.0, The common plugin location is:</p> <p><code>/Library/Application Support/Adobe/Common/Plugins/[version]/MediaCore/</code></p> <p>Starting in CC 2015.3, control surface plugins should be installed here:</p> <p><code>/Library/Application Support/Adobe/Common/Plugins/ControlSurface/</code></p> <p>Previously, starting in CC 2015, Premiere Pro provided installer hints for Mac. You'll find <code>com.Adobe.Premiere Pro.paths.plist</code> at <code>/Library/Preferences</code>, which contains hints for your Mac installer to know where to install plugins, and is similar to the registry entries we have been providing on Win.</p> <p>The common plugin location was at:</p> <p><code>/Library/Application Support/Adobe/Common/Plug-ins/[version]/MediaCore/</code></p> <p>Starting in CC 2015.3, control surface plugins should be installed here:</p> <p><code>/Library/Application Support/Adobe/Common/Plug-ins/ControlSurface/</code></p> <p>Following OS X Code Signing guidelines, plugins should be installed in this separate shared location rather than in the application bundle.</p> <p>For sequence presets:</p> <p><code>/Settings/SequencePresets/[Your specific folder]/</code></p> <p>Sequence preview presets:</p> <p><code>/Settings/EncoderPresets/SequencePreview/[Your editing mode GUID]/</code></p> <p>Encoder presets:</p> <p><code>/MediaIO/systempresets/[Your exporter folder]/</code></p> <p>Effects presets:</p> <p><code>/Plugins/[language subdirectory]/Effect Presets/</code> (see Localization for the list of language codes)</p> <p>Editing modes:</p> <p><code>/Settings/Editing Modes/</code></p>"},{"location":"intro/plugin-installation/#plugin-naming-conventions","title":"Plugin Naming Conventions","text":"<p>On Windows, Premiere Pro plugins must have the file extension \".prm\". On macOS, they have the file extension \".bundle\". Other supported plug-in standards use their conventional file extensions: \".aex\" for After Effects plugins, \".dll\" for VST plugins.</p> <p>While it is not required for your plugin to load, naming your plugins using the plugin type as a prefix (e.g. ImporterSDK, FilterSDK, etc.) will help reduce user confusion.</p>"},{"location":"intro/plugin-installation/#plugin-blocklisting-formerly-blacklisting","title":"Plugin Blocklisting (formerly Blacklisting)","text":"<p>Specific plugins can be blocked from being loaded by MediaCore in specific applications, using blocklists.</p> <p>Note</p> <p>This does not work for After Effects plugins loaded by AE, although it does work for AE plugins loaded in Premiere Pro.</p> <p>In the plugins folder, look for the appropriate blacklist file, and append the the filename of the plugin to the file (e.g. BadPlugin, not BadPlugin.prm). If the file doesn't exist, create it first. \"Blocklist.txt\" contains names of plugins blacklisted from all apps. Plugins can be blocked from loading in specific apps by including them in \"Blocklist Adobe Premiere Pro.txt\", or \"Blocklist After Effects.txt\", etc.</p>"},{"location":"intro/plugin-installation/#creating-sequence-presets","title":"Creating Sequence Presets","text":"<p>Not to be confused with encoder presets or sequence preview encoder presets, sequence presets are the successor to project presets. They contain the video, audio, timecode, and track layout information used when creating a new sequence.</p> <p>If you wish to add Sequence Presets for the New Sequence dialog, save the settings with a descriptive name and comment. Emulate our settings files. Install the presets as described in this section.</p>"},{"location":"intro/plugin-installation/#application-level-preferences","title":"Application-level Preferences","text":"<p>For Windows 7 restricted user accounts, the only place that code has guaranteed write access to a folder is inside the user documents folder and its subfolders.</p> <p>..Users[user name]AppDataRoamingAdobePremiere Pro[version]\\</p> <p>This means that you cannot save data or documents in the application folder. There is currently no plugin API for storing preferences in the application prefs folder. Plugins can create their own preferences file in the user's Premiere prefs directory like so:</p> <pre><code>HRESULT herr = SHGetKnownFolderPath(FOLDERID_RoamingAppData, 0, NULL, preferencesPath);\nstrcat(preferencesPath, \"\\\\Adobe\\\\Premiere Pro\\\\[version]\\\\MyPlugin.preferences\");\n</code></pre> <p>On MacOS: <code>NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirector y,NSLocalDomainMask,\u2026)</code></p> <p>This should get you started getting the Application Support folder which you can add onto to create something like:</p> <p><code>/Library/Application Support/Adobe/Premiere Pro/[version]/ MyPlugin.preferences</code></p>"},{"location":"intro/plugin-installation/#dog-ears","title":"Dog Ears","text":"<p>Premiere Pro's built-in player has a mode to display statistics, historically known as \"dog ears\", which can be useful in debugging and tuning performance of importers, effects, transitions, and transmitters. The statistics include frames per second, frames dropped during playback, pixel format rendered, render size, and field type being rendered.</p> <p>You can bring up the debug console in Premiere Pro. You can do this via Ctrl/Cmd-F12. To enable the dog ears, type this:</p> <pre><code>debug.set EnableDogEars=true\n</code></pre> <p>to disable, use this:</p> <pre><code>debug.set EnableDogEars=false\n</code></pre> <p>If the enter keystroke seems to go to the wrong panel, this is an intermittent panel focus problem. Click the Tools or Info panel before typing in the Console panel, and the enter key will be processed properly.</p> <p>Once enabled, the player displays the statistics as black text on a partially transparent background. This allows you to still see the underlying video (to some extent) and yet also read the text. When you turn off dog ears, the setting may not take effect until you switch or reopen your current sequence.</p> <p>Note</p> <p>If you are developing a transmitter, displaying dog ears will result in duplicate calls to PushVideo for the same frame. This happens because the player routinely updates the dog ears on a timer even when the frame hasn't changed for updated stats. As of CS6, this triggers a PushVideo to active transmitters as a side effect.</p>"},{"location":"intro/premiere-pro-plugin-types/","title":"Premiere Pro Plug-In Types","text":"Type Description Importers Import video and audio media into Premiere.Synthetic importers, a subset, dynamically synthesize media without creating an actual file on disk.Custom importers, dynamically synthesize media to disk. Export Controllers Can drive any exporter to generate a file in any format and perform custom post-processing operations.Developers wanting to integrate Premiere Pro with an asset management system will want to use this API instead of the exporter API. Exporters Allows the user to output media to disk. Transmitters Sends video, audio, and closed captioning to any external device during playback and editing. Video Filters We strongly recommend using the After Effects SDK to develop effects plugins. Most of the effects included in Premiere Pro are After Effects plugins.Process a series of video frames with parameters that can be animated over time. GPU Effects &amp; Transitions Process two video sources into a single destination over time.This API is based on the After Effects API, with certain functions to enable transition functionality in Premiere Pro. Control Surfaces Interface with a hardware control surface to support audio mixing, basic transport controls, and the Lumetri Color panel.The API supports two-way communication with Premiere Pro, so that motorized hardware faders, VU meters, etc can be in sync with the application."},{"location":"intro/premiere-pro-plugin-types/#other-supported-plug-in-standards","title":"Other Supported Plug-In Standards","text":"Type Description Adobe After Effects API Premiere Pro supports a portion of the AE API.The After Effects SDK is not included in the Premiere Pro SDK.The last chapter in the After Effects SDK Guide.pdf, included in the After Effects SDK, contains information on known differences with how Premiere Pro supports the AE API. VST Starting in CC, Premiere supports version 3 of the VST specification for audio effects.In CS6.x and previous versions, support was limited to version 2.4. ASIO An ASIO driver is often provided in addition to a transmit plug-in, to provide audio output during editing, playback, and Export To Tape.Prior to CS6, an ASIO driver was required to support audio input for voiceover recording in the audio mixer. On macOS, a Core Audio component may be provided rather than an ASIO driver. Core Audio macOS only. May be provided instead of an ASIO driver."},{"location":"intro/premiere-pro-plugin-types/#plug-in-support-across-adobe-video-and-audio-applications","title":"Plug-in Support Across Adobe Video and Audio Applications","text":"<p>This chart shows which third-party plugins are supported by the various Video and Audio applications.</p> Premiere Pro After Effects Media Encoder Audition Character Animator Prelude After Effects AEGPs X After Effects effects X X After Effects transitions X ASIO X X X X Control Surfaces X X CoreAudio X X X X Premiere device controllers X Premiere export controllers X Premiere exporters X X X X Premiere importers X X X X X Premiere recorders X Premiere transmitters X X X X Premiere video filters X QuickTime codecs X X X X X Transitions X VfW codecs X X X X X VST audio effects X X"},{"location":"intro/premiere-pro-plugin-types/#premiere-elements-plug-in-support","title":"Premiere Elements Plug-in Support","text":"<p>Premiere Elements uses the same core libraries for plug-in support that Premiere Pro does, although Premiere Elements is 32-bit, whereas Premiere Pro is 64-bit starting with CS5.</p> Premiere Elements version Equivalent Premiere Pro API version 12 CS6 11 CS5.5 10 CS5.5 9 CS5 8 CS4 <p>It's always important to test the plug-in fully in each application before advertising compatibility.</p> <p>Check out Guidelines for Exporters in Premiere Elements for instructions on how to set up your exporter to be used in Premiere Elements.</p>"},{"location":"intro/premiere-pro-plugin-types/#what-exactly-is-a-premiere-pro-plugin","title":"What Exactly Is a Premiere Pro Plugin?","text":"<p>Premiere plugins contain a single entry point of a type specific to each API.</p> <p>Plugins are DLLs on Windows, and Carbon or Cocoa Bundles on macOS.</p> <p>Plug-ins in the \\Plug-ins[language] folder, and any of its subfolders, will be loaded at launch.</p> <p>Plugins can have private resources.</p> <p>Only one plug-in per file is parsed, unlike After Effects and Photoshop plugins, which can contain multiple entry points.</p>"},{"location":"intro/sample-projects/","title":"Sample Projects","text":""},{"location":"intro/sample-projects/#descriptions","title":"Descriptions","text":"Name Description SDK File Importer This importer supports .sdk media files.To use the importer, choose File &gt; Import, and select an .sdk file.Such files may be created using the SDK Exporter.It supports uncompressed 8-bit RGB with or without alpha, and packed 10-bit YUV (v410).It supports mono, stereo, and 5.1 audio at arbitrary sample rates and 32-bit float.It supports trimming using the Project Manager, Properties and Data Rate Analysis, Unicode filenames, the avoidAudioConform flag, and can read video frames asynchronously.It also features a test harness for multistream audio, which can be turned on by uncommenting the <code>MULTISTREAM_AUDIO_TESTING</code> define in the header. Synth Import This synthetic importer generates 8-bit YUV and RGB, video only.To use it, choose File &gt; New &gt; SDK Synthetic Importer.When the clip is created, it demonstrates a sample settings dialog, which can be displayed again by double-clicking the clip in the Project Panel or Timeline Panel.Every time the settings dialog is displayed, it creates new footage in memory. It creates ten seconds of footage at 24 fps. The video consists of horizontal lines of random colors.No file is created on disk for an example of that, see the Custom Importer. SDK Custom Import This custom importer creates a clip similar to the Synth Import sample, but generates it to disk, rather than memory.To use it, choose File &gt; New &gt; SDK Custom Importer.Or, import an existing .sdkc clip from the File &gt; Import dialog.On Windows, newly generated files with .sdkc file extensions are created in C:WindowsTemp. On macOS, they are created on the Desktop.After the sample settings dialog, it optionally displays a background frame from the timeline (useful for titlers).The generated footage is between 2 and 30 frames at 24 fps, with a random resolution between 32 and 720 pixels wide and between 32 and 480 high, at DV NTSC pixel aspect ratio. ExportController Adds a new menu item to File &gt; Export &gt; SDK Export Controller.When selected, it displays a simple message box on Windows, takes the DV NTSC widescreen preset, and exports a file to <code>C:\\Windows\\Temp</code> on Windows, or to the Desktop on macOS. SDK Exporter This exporter writes .sdk files.To use it, choose File &gt; Export &gt; Media, and in the Export Settings choose File Type: SDK File.It supports uncompressed 8-bit RGB with or without alpha, and packed 10-bit YUV (v410).It supports mono, stereo, and 5.1 audio at arbitrary sample rates and 32-bit float.It demonstrates custom parameters, including a custom settings button.It also writes marker data to an .html file with the same filename.To write files with v410 compression using 8-bit RGB sources, this sample uses routines to convert the 8-bit RGB data to 32-bit RGB, then to 32-bit YUV, and finally to v410.These same routines may be adapted for transitions, filters, and other plugin types. Transmitter The sample transmit plugin does not output to any hardware, but can be used to step through interactions between the host and plugin in the debugger.To use it, go the the Preferences &gt; Playback, and choose the SDK Transmitter as the Audio Device, and as a Video Device.This transmit plugin provides the basic structure, separating concepts of plugin and instance. For video, it declares support for any pixel format and resolution.For audio, it declares support for 2 channels. It also declares a small latency value for demonstrative purposes.On Windows, there is some basic debug logging.It does not actually provide it's own clock at this time, but on playback it simply pretends to step forward a frame with every frame received.This may result in some bug behavior such as playing back at speeds faster or slower than normal, depending on how fast the host can push frames. SDK_ProcAmp This GPU-accelerated effect demonstrates a simple ProcAmp effect using the After Effects API with the Premiere Pro GPU extensions.The effect is found in the SDK folder of the Video Effects in the Effects Control panel.It supports Metal acceleration.This sample requires macOS 10.11.4 and later. Vignette This effect creates a vignette on video using the After Effects API with the Premiere Pro GPU extensions.Has CUDA and software render paths.Software rendering in Premiere Pro includes 8-bit/32-bit RGB/ YUV software render paths.Software rendering in After Effects includes 8-bit and 32-bit smart rendering.Thanks to Bart Walczak for donating this sample. SDK_CrossDissolve This GPU-accelerated transition demonstrates a simple cross dissolve transition using the After Effects API with the transition extensions.The transition is found in the SDK folder of the Video Transitions in the Effects Control panel.It supports CUDA acceleration. ControlSurface You should see the plugin in the PPro UI in Preferences &gt; Control Surface, when you hit the Add button, as one of the options in the Device Class drop-down next to Mackie and EUCON (currently shows as \"SDK Control Surface Sample\").Just a starting point for you to add your functionality."},{"location":"intro/sample-projects/#how-to-build-the-sdk-sample-projects","title":"How To Build the SDK Sample Projects","text":"<p>The required development environment is described in SDK Audience.</p> <p>See a quickstart video on building an effect using a similar SDK (on macOS) here.</p> <p>We've combined the sample projects into a single master project, stored in the Examples folder of the SDK.</p> <p>For macOS it is BuildAll.xcodeproj; for Windows, it is _BuildAll.sln.</p> <p>You'll need to specify some settings so that the plugins are built into a folder where they will be loaded by the application you are developing for.</p> <p>We recommend plugins be built into the following folder for macOS: <code>/Library/Application Support/Adobe/Common/Plug-ins/[version]/MediaCore/</code></p> <p>Version is locked at 7.0 for all CC versions, or CSx for earlier versions.</p> <p>For example: <code>/Library/Application Support/Adobe/Common/Plug-ins/7.0/MediaCore/</code></p> <p>or: <code>/Library/Application Support/Adobe/Common/Plug-ins/CS6/MediaCore/</code></p> <p>and the following path for Windows:</p> <p><code>[Program Files]\\Adobe\\Common\\Plug-ins\\[version]\\MediaCore\\\\</code></p> <p>for example: <code>C:\\Program Files\\Adobe\\Common\\Plug-ins\\7.0\\MediaCore\\\\</code></p> <p>or: <code>C:\\Program Files\\Adobe\\Common\\Plug-ins\\CS6\\MediaCore\\\\</code></p> <p>Note</p> <p>This Windows path is only recommended for development purposes.</p> <p>In Xcode, set the build location for the project in File &gt; Project Settings. Press the Advanced button. Under Build Location choose Custom, select Absolute, and set the Products path.</p> <p>In Visual Studio, for convenience, we have set the Output File for all sample projects to use the base path set by the environment variable PREMSDKBUILDPATH. You'll need to set this as a user environment variable for your system, and shown in the screenshot below.</p> <p> Setting Environment Variables</p> <ol> <li>On Windows, right-click My Computer &gt; Properties, and in the left sidebar choose Advanced System Settings.</li> <li>In the dialog that appears, hit the Environment Variables button.</li> <li>In the User variables, create a new variable named PREMSDKBUILDPATH, with the path as described above. (e.g. \"C:Program FilesAdobeCommonPlug-ins[version]MediaCore\").</li> <li>Log out of Windows, and log back in so that the variable will be set.</li> </ol> <p>When compiling the plugins, if you see a link error such as:</p> <p>\"Cannot open file \"[MediaCore plugins path]plugin.prm\", make sure to launch Visual Studio in administrator mode. In your Visual Studio installation, right-click devenv.exe, Properties &gt; Compatibility &gt; Privilege Level, click \"Run this program as an administrator\".</p> <p>It's not recommended to copy plugins into the plugin folder after you've built them, because that won't allow you to debug the plugins while the host application is running.</p>"},{"location":"intro/sdk-audience/","title":"SDK Audience","text":"<p>The Premiere Pro Software Development Kit enables developers to create plugins for Premiere Pro, After Effects, Audition, Media Encoder, Character Animator, and Premiere Elements.</p> <p>The required development environment for the Premiere Pro SDK for Windows is Microsoft Visual Studio 2015 Update 3 on Windows 7 or Windows 10 64-bit. When setting up Visual Studio you may need to adjust some installation settings to install the components for compiling 64-bit plugins. On macOS, the minimum environment is Xcode 7.3 on macOS 10.12 or later.</p> <p>The SDK includes sample projects for these development environments. On Windows, projects can often be updated to more current versions of Microsoft Visual Studio by simply opening the project and approving the automatic conversion. The sample code is written in C++. Other compilers and programming languages are not supported. We cannot assist with platform API programming issues not central to Premiere Pro plugin programming.</p> <p>If this is your first time developing a Premiere plugin, you can skip Whats New.</p> <p>If you are developing on macOS, see a quickstart video on building a plugin using a similar SDK (on macOS) here, and then go directly to Where Do I Start.</p>"},{"location":"intro/what-premiere-plugins-do/","title":"What Premiere Plug-Ins Do","text":"<p>Premiere APIs provide access to many points of the video editing pipeline.</p> <p>Recording from an external device, device control, media import and export, video effects and transitions, playback to external hardware, and integration with control surfaces can all be performed by plugins.</p>"},{"location":"intro/whats-new/","title":"Whats New","text":""},{"location":"intro/whats-new/#whats-new-in-240","title":"What's New in 24.0","text":"<p>With the removal of Capture functionality from Premiere Pro, support for Record modules and Device Control plug-ins have been removed from the SDK.</p>"},{"location":"intro/whats-new/#whats-new-in-154","title":"What's New in 15.4","text":"<p>We've updated the <code>PrSetEnv.h</code> header, to allow building ARM-native plugins.</p>"},{"location":"intro/whats-new/#whats-new-in-142","title":"What's New in 14.2","text":"<p>Cleared the dust and debris off of the SDK source files. ;) The primary motivation for this new SDK release is to provided updated headers. Example code utilizing those new headers, as well as documentation of their new contents, will (regrettably) need to wait for another day.</p>"},{"location":"intro/whats-new/#whats-new-in-131","title":"What's New in 13.1","text":"<p>Removed \"CC\" from the product name.</p>"},{"location":"intro/whats-new/#whats-new-in-130","title":"What's New in 13.0","text":"<p>The only significant change to Premiere Pro's C++ APIs for 13.0 is the addition of color-space specifiers to the Importer API. The ColorProfileRec structure is deprecated; instead, Importers will describe supported colorspaces (in response to imGetIndColorSpace ) using a ColorSpaceRec.</p>"},{"location":"intro/whats-new/#whats-new-in-120","title":"What's New in 12.0","text":""},{"location":"intro/whats-new/#effects-and-transitions","title":"Effects and Transitions","text":"<p>GPU Effects &amp; Transitions built using this SDK are now compatible with After Effects 15.0 and later. The sample GPU effect projects have been updated so that they load in both Premiere Pro and After Effects.</p> <p>The newly provided PrGPU SDK Macros and device functions allow you to write kernels that will compile on CUDA, and Metal.</p> <p>Multiple effects and transitions can now be implemented in a single plugin binary, by defining multiple entry points in software at runtime. The new method for registering entry points will be a replacement for the PiPL resource, and is currently only supported in Premiere Pro. The sample effects and transitions demonstrate this new method, while Plug-In Property Lists (PiPL) Resource remains, for backwards-compatibility in PPro, and compatibility with AE.</p> <p>Sequence Info Suite is now at version 5, adding the new call GetImmersiveVideoVRConfiguration(), which returns the VR video settings of the specified sequence.</p> <p>New selector available for Export Info Suite: kExportInfo_SourceBitrate. This returns the source's bitrate in kbps, and is not available for all source types. exParamType can now be of type exParamType_thumbnail. A new flag exParamFlag_verticalAlignment can now be set so that property name and value controls are displayed vertically rather than side-by-side.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-20171","title":"What's New in CC 2017.1","text":""},{"location":"intro/whats-new/#importers","title":"Importers","text":"<p>Importers that support captions can make use of the mayHaveCaptions flag in <code>imFileInfoRec8</code>, for better performance. Also, a <code>imImageInfoRec</code> is now added to <code>imInitiateAsyncClosedCaptionScanRec</code>, just for the width and height parameters.</p>"},{"location":"intro/whats-new/#exporters","title":"Exporters","text":"<p>Exporters can advertise whether they support color profile embedding. There are also APIs to set color profile in the exporter, and a flag that controls whether profile is to be embedded. The color profile is passed to an exporter via exDoExportRec, for it to embed in the output media according to format standards. This is currently used for exports from After Effects through Media Encoder.</p>"},{"location":"intro/whats-new/#transmit","title":"Transmit","text":"<p>New 10-bit and 12-bit RGB HLG formats have been added for expanded HDR support.</p> <p>In App Info Suite, a new identifier has been added for Character Animator, which now supports transmit plugins.</p>"},{"location":"intro/whats-new/#vr-video-support","title":"VR Video Support","text":"<p>The Playmod Immersive Video Suite can be used to query whether or not ambisonics monitoring is on or not, in the VR Video Settings.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-2017","title":"What's New in CC 2017","text":""},{"location":"intro/whats-new/#vr-video-support-added","title":"VR Video Support added","text":"<p>Transmit plugins can have the VR perspective in the desktop Monitor driven by the Head-Mounted Display, so when the person with the Head-Mounted Display looks in a different direction, the desktop Monitor shows that same perspective. To do this, the transmit plugin can use the new Playmod Immersive Video Suite to indicate that it supports tracking.</p> <p>Once Premiere sees the transmitter supports tracking, when the user activates the VR viewer, the new menu item, \"Track Head-Mounted Display\" will become active, and can be toggled to begin tracking. The transmitter should call NotifyDirection() as frequently it wants with updated info. Premiere will pick up the new position on the next frame draw.</p> <p>For importers, imFileInfoRec8 has now been expanded so that if an importer detects that a clip contains VR video, it can inform Premiere.</p>"},{"location":"intro/whats-new/#new-sample-projects","title":"New Sample Projects","text":"<p>This SDK includes a new render path for the ProcAmp sample for Metal. This sample requires macOS 10.11.4 and later.</p> <p>We've also added a sample GPU effect called Vignette, donated by Bart Walczak. This effect has OpenCL, CUDA, and software render paths. Software rendering in Premiere Pro includes</p> <p>8-bit/32-bit RGB/YUV software render paths. Software rendering in After Effects includes 8-bit and 32-bit smart rendering.</p> <p>And lastly, the Control Surface sample is now cross-platform.</p>"},{"location":"intro/whats-new/#new-panelscripting-capabilities","title":"New Panel/Scripting Capabilities","text":"<p>Scripting, the processing underlying HTML5 panels, is consistently being improved upon. In this release, we've added scripting functions to add/modify effect keyframes. See the sample panel code on GitHub:</p> <p>https://github.com/Adobe-CEP/Samples/tree/master/PProPanel</p> <p>In particular, see the function onPlayWithKeyframes() in jsx/Premiere.jsx</p>"},{"location":"intro/whats-new/#miscellaneous","title":"Miscellaneous","text":"<p>In Video Segment Render Suite, new versions of various calls have been added with an additional boolean value that allows renders to skip rendering of non-intrinsic effects.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-20240","title":"What's New in CC 2024.0","text":"<p>The Transmit API has been expanded to enable multiple audio outputs, and plug-ins which stream video and audio information.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-20154","title":"What's New in CC 2015.4","text":""},{"location":"intro/whats-new/#metal-rendering-for-effects-and-transitions","title":"Metal rendering for Effects and Transitions","text":"<p>GPU-accelerated rendering using Metal is now supported for third-party effects and transitions. PrGPUDeviceFramework_Metal has been added as one of the enum values in PrGPUDeviceFramework.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-20153","title":"What's New in CC 2015.3?","text":""},{"location":"intro/whats-new/#control-surfaces","title":"Control Surfaces","text":"<p>New suites have been added for Control Surfaces to support the Lumetri Color panel. Most controls are supported, including the color wheels, but not including the Curves controls.</p> <p>There is now a shared location for Control Surface plugins. On Mac:</p> <p>/Library/Application Support/Adobe/Common/Plugins/ControlSurface, and</p> <p>~/Library/Application Support/Adobe/Common/Plugins/ControlSurface</p> <p>On Win:</p> <p>C:Program FilesAdobeCommonPluginsControlSurface</p>"},{"location":"intro/whats-new/#importers_1","title":"Importers","text":"<p>Video duration can now be reported as a 64-bit integer, using the new imFileInfoRec8. vidDurationInFrames, to support longer file lengths. There is also a new suite function, SetImporterInstanceStreamFileCount(), for importers to specify how many files they open.</p>"},{"location":"intro/whats-new/#exporters_1","title":"Exporters","text":"<p>New flags can be set in exExporterInfoRec.flags, to restrict an exporter from being used in a way that doesn't make sense. Now, an exporter can specify that video-only export is not supported. Also, an exporter can turn off the Publish tab if it chooses to.</p>"},{"location":"intro/whats-new/#effects","title":"Effects","text":"<p>Source settings effects should use the updated Source Settings suite with new</p> <p>SetIsSourceSettingsEffect() function. They should make this call during PF_Cmd</p> <p>GLOBAL_SETUP. This function was added to handle the case when the effect is applied to proxy video.</p>"},{"location":"intro/whats-new/#misc","title":"Misc","text":"<p>Using the Sequence Info Suite, a new call has been added, GetProxyFlag(), for a plugin to know whether the proxy mode is on or off.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-20151","title":"What's New in CC 2015.1?","text":""},{"location":"intro/whats-new/#transmit_1","title":"Transmit","text":"<p>Native support for 12-bit Dolby PQ pixel formats, with Rec. 709, P3, and Rec. 2020 primaries, have been added.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-2015","title":"What's New in CC 2015?","text":""},{"location":"intro/whats-new/#after-effects-style-transitions","title":"After Effects-Style Transitions","text":"<p>AE-style Transitions can now get and set transition start and end percentages. The user can change the start and end parameters in the Effect Controls panel. To allow a plugin to be informed of changes to these values, there are two new functions in the PF TransitionSuite: RegisterTransitionStartParam() and RegisterTransitionEndParam(), which register these parameters with the plugin as float parameters. Once registered, the plugin will receive PF_Cmd_USER_CHANGED_PARAM when these params change, as well as when the transition is first applied, so the plugin can initialize them to the desired value.</p> <p>AE-style Transitions can now retrieve GPU frames from arbitrary locations in the underlying clips. There is a new PrGPUDependency_TransitionInputFrame, and PrGPUFilterFrameDependency has a new member to specify whether frames from the incoming or outgoing clips are needed.</p>"},{"location":"intro/whats-new/#source-settings-effect-importer","title":"Source Settings = Effect + Importer","text":"<p>Source Settings for clips can now be implemented using effects that are tied to importers. This has the advantage of providing settings in the Effect Controls panel, rather than in a modal dialog. Editors can adjust Source Settings for multiple clips this way. These effects are used for the DPX source settings, CinemaDNG, etc.</p> <p>To implement this, an importer should set <code>imImportInfoRec.hasSourceSettingsEffect</code> to true. Then in imFileInfoRec8, it should set sourceSettingsMatchName to the match name of the effect to be used for the Source Settings.</p> <p>On the effects side, a new PF Source Settings Suite has been added to PrSDKAESupport.h, for effects using the After Effects API. This is how an effect registers a function to handle the Source Settings command.</p> <p>A source settings effect is used primarily for the parameter UI and management. A source settings effect doesn't provide the actual frames. In fact, the effect isn't even called with PF_Cmd_RENDER. The frames come directly from the importer, which provides frames based on the settings as passed to the importer via prefs data.</p> <p>When a clip is first imported, the effect is called with PF_Cmd_SEQUENCE_SETUP. It should call PerformSourceSettingsCommand() in the Source Settings Suite, to initialize the prefs. This causes the importer to get called with imPerformSourceSettingsCommand, where it can read the file and set the default prefs. param1 of that function is imFileAccessRec8*, and param2 is imSourceSettingsCommandRec*.</p> <p>When the source settings effect parameters are changed, the effect gets called with PF_Cmd_TRANSLATE_PARAMS_TO_PREFS. The function signature is:</p> <pre><code>PF_Err TranslateParamsToPrefs(\n  PF_InData*                      in_data,\n  PF_OutData*                     out_data,\n  PF_ParamDef*                    params[],\n  PF_TranslateParamsToPrefsExtra  *extra)\n</code></pre> <p>With the new prefs, the importer will be sent imOpenFile8, imGetInfo8, imGetIndPixelFormat, imGetPreferredFrameSize, imGetSourceVideo, etc.</p> <p>imSourceSettingsCommandRec and PF Source Settings Suite allow the effect to communicate directly with the importer, so that it can initialize its parameters properly, based on the source media. In the DPX source settings effect, for example, in PF_Cmd_SEQUENCE_SETUP, it calls PF_SourceSettingsSuite-&gt;PerformSourceSettingsCommand(), which calls through to the importer with the selector imPerformSourceSettingsCommand. Here, the importer opens the media, looks at the header and initializes the prefs based on the media. For</p> <p>DPX, the initial parameters and default prefs are based on the bit depth of the video. These default prefs are passed back to the effect, which sets the initial param values and stashes a copy of them in sequence_data to use again for future calls to PF_Cmd_SEQUENCE_RESETUP.</p>"},{"location":"intro/whats-new/#importers_2","title":"Importers","text":"<p>For any importers that are using imClipFrameDescriptorRec, note that the structure definition has changed. Any importers that use this in both CC 2014 and CC 2015 or later will need to do a runtime check before accessing the members of this structure.</p>"},{"location":"intro/whats-new/#exporters_2","title":"Exporters","text":"<p>Exporters can now use standard parameters for audio channel configuration, as used with the built-in QuickTime exporter. The new exporter parameters ADBEAudioChannelConfigurationGroup and ADBEAudioChannelConfiguration supercede ADBEAudioNumChannels. The new Export Audio Param Suite can be used to query/change the audio channel configuration.</p> <p>The Sequence Audio Suite is now at version 2, revising <code>MakeAudioRenderer()</code> to take <code>PrAudioChannelLabel*</code> as a parameter.</p>"},{"location":"intro/whats-new/#transmitters","title":"Transmitters","text":"<p>Transmitters can get a few new bits of information to aid with A/V sync. In the Playmod Audio Suite, the new function GetNextAudioBuffer2() returns the actual time the rendered buffer is from.</p> <p>Also, in <code>tmPlaybackClock</code>, the new members <code>inAudioOffset</code> and <code>inVideoOffset</code> have been added to specify the offset chosen by the user in the preferences.</p> <p>The host accounts for these offsets automatically by sending frames early, but if a transmitter is manually trying to line up audio and video times, it can use this to know how far apart from each other they are supposed to be.</p>"},{"location":"intro/whats-new/#miscellaneous_1","title":"Miscellaneous","text":"<p>Legacy callbacks bottlenecks-&gt;ConvolvePtr() and IndexMapPtr() have had their parameter types updated to fix a bug. Any plugins that use these in both previous versions and CC 2015 will need to do a runtime check before calling this function.</p> <p>Starting in CC 2015, we now provide installer hints for Mac. You'll find a new plist file \"com. Adobe.Premiere Pro.paths.plist\" at \"/Library/Preferences\". This contains hints for your Mac installer to know where to install plugins, and is similar to the registry entries we have been providing on Win.</p>"},{"location":"intro/whats-new/#new-sample-projects_1","title":"New Sample Projects","text":"<p>This SDK includes updated GPU effect and transition samples that demonstrate GPU rendering. Thanks to Rama Hoetzlein from nVidia for the CUDA render path provided for the SDK_CrossDissolve sample!</p> <p>A barebones Control Surface sample is now provided, too.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-2014-82","title":"What's New in CC 2014 (8.2)?","text":"<p>Importers now have more visibility into the player's intent on a given async request, since the render context info is now passed in imSourceVideoRec.inRenderContext. Async importers can implement aiSelectEfficientRenderTime to specify if a frame request would be more efficient at another frame time, for example at I-frame boundaries. The Video Segment Render Suite has been updated to version 4, adding new calls that include imRenderContext as a parameter.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-2014-81","title":"What's New in CC 2014 (8.1)?","text":"<p>Importers that support growing files now get a hint if the host knows the file has stopped growing:</p> <p>imFileInfoRec8.ignoreGrowing.</p> <p>Exporters can now get the list of source pixel formats used by the clips in a sequence that is being smart rendered. GetExportSourceInfo(\u2026, kExportInfo_SourcePixelFormat, \u2026) provides this information.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-2014-801","title":"What's New in CC 2014 (8.0.1)?","text":"<p>Importers can fill in imImageInfoRec.codecDescription to provide a string that will be displayed for clips in the Video Codec column of the Project panel.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-2014","title":"What's New in CC 2014?","text":"<p>Importers can now choose the format they are rendering in, which allows importers to change pixel formats and quality based on criteria like enabled hardware and other source settings, such as HDR. To handle the negotiation, implement imSelectClipFrameDescriptor.</p> <p>imSourceVideoRec now includes a quality attribute. PPix Cache Suite is now at version 6, adding AddFrameToCacheWithColorProfile2() and</p> <p>GetFrameFromCacheWithColorProfile2(), which are the same as the ones added in version 5 with the addition of a PrRenderQuality parameter.</p> <p>imFileInfoRec8.highMemUsage is no longer supported.</p> <p>A new recorder return code was added, rmRequiresRoyaltyContent. Return this from</p> <p>recmod_Startup8 or recmod_StartRecord, if the codec used is unlicensed.</p> <p>OpenCL rendering now also uses the half-precision 16-bit floating point pixel format for rendering. GPU effects and transitions that support OpenCL should implement both 16f and 32f rendering.</p> <p>A new plugin API has been introduced for hardware Control Surfaces. This is the API that allows support for EUCON and Mackie devices to control audio mixing and basic transport controls. The API supports two-way communication with Premiere Pro, so that hardware faders, VU meters, etc are in sync with the application.</p> <p>Premiere Pro is now localized in Russian and Brazilian Portugese.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-october-2013","title":"What's New in CC October 2013?","text":"<p>We've extended the After Effects API to support native transitions in Premiere Pro.</p> <p>For device controllers, the new command cmdSetDeviceHandler was added. This command tells the device controller which panel is using the device controller - either the Capture panel, or Export to Tape panel.</p> <p>For importers, imInitiateAsyncClosedCaptionScanRec now provides extra fields for the importer to fill in the estimated duration of all the captions. This is useful for certain cases where the embedded captions contain many frames of empty data.</p> <p>We added version 2 of the Export File Suite to resolve a mismatch in seek modes.</p>"},{"location":"intro/whats-new/#whats-new-in-cc-july-2013","title":"What's New in CC July 2013?","text":"<p>The only significant additions made in the July 2013 update to version CC are in the device controller API.</p>"},{"location":"intro/whats-new/#whats-new-in-cc","title":"What's New in CC?","text":""},{"location":"intro/whats-new/#new-edit-to-tape-panel","title":"New Edit to Tape Panel","text":"<p>You can think of this as the Export to Tape equivalent of the Capture panel for capturing, which provides a video preview and various settings in the PPro UI. Among the benefits are more seamless integration, a more familiar UI for users, integrated device presets, and some new capabilities like adding Bars and Tone / Black Video / Universal Counting Leader to the start of your layoff to tape. To use this new feature, read more about what's new in the device controller API.</p>"},{"location":"intro/whats-new/#new-gpu-extensions-for-effects-and-transitions","title":"New GPU Extensions for Effects and Transitions","text":"<p>New GPU Extensions to existing APIs allow effects and transitions to access video frames in GPU memory, when using the Mercury Playback Engine in a GPU-accelerated mode. See GPU Effects &amp; Transitions for more information.</p>"},{"location":"intro/whats-new/#closed-captioning-support-in-importer-and-exporter-apis","title":"Closed Captioning Support in Importer and Exporter APIs","text":"<p>The importer and exporter APIs have been extended to support closed captioning embedded in media.</p> <p>Note</p> <p>Premiere Pro can also import and export captions in a sidecar file (e.g. .mcc, .scc, or .xml) alongside any media file, regardless of the media file format.</p>"},{"location":"intro/whats-new/#miscellaneous-improvements","title":"Miscellaneous Improvements","text":"<ul> <li>A new pixel format for native 10-bit RGB support - PrPixelFormat_RGB_444_10u, as well as <code>PrPixelFormat_UYVY_422_32f_*</code> formats</li> <li>VST 3 support allows many more audio plugins to run in Premiere Pro</li> <li>Windows installer improvements, by adding new registry values for preset and settings locations.</li> <li>Get the current build number via the App Info Suite</li> <li>Importers can now support audio beyond basic mono, stereo, and 5.1, without implementing multiple streams, and importers can return varying pixel formats depending on the clip settings. Read more about what's new for importers.</li> <li>Exporters can get the number of audio channels in the source, and check if the user has checked \"Use Previews\" in the Export Settings dialog. They can also move an existing settings parameter to a different location. Read more about what's new for exporters.</li> <li>The Sequence Info Suite can retrieve the field type, zero point, and whether or not the timecode is drop-frame</li> <li>New flags to the transition API as a hint to optimize rendering when a transition only has an input on one side</li> <li>The Video Segment Suite provides access to a new property: Effect_ClipName</li> </ul> <p>Premiere Pro is now localized in Chinese.</p>"},{"location":"intro/whats-new/#whats-new-in-cs60x","title":"What's New in CS6.0.x?","text":"<p>CS6.0.2 adds more support for growing files in importers. A transmitter can now label its audio channels for the Audio Output Mapping preferences.</p> <p>CS6.0.1 gives device controllers a way to get the number of frames dropped during an insert edit, to abort an Export to Tape if desired. This method is already superceded by the new Edit to Tape panel functionality in CC.</p>"},{"location":"intro/whats-new/#whats-new-in-cs6","title":"What's New in CS6?","text":""},{"location":"intro/whats-new/#transmit-api","title":"Transmit API","text":"<p>We are introducing the Transmit API as the preferred means for external hardware monitoring. This new API provides vastly simplified support for monitoring on external hardware. Transmit plugins offer more flexible usage, since they are not tied to the sequence Editing Mode, which cannot be changed once a sequence has been edited. Transmitters can be specified by the user in Preferences &gt; Playback. Other plugins such as importers and effects with settings preview dialogs can send video out to the active transmitter, opening up new possibilities for hardware monitoring. See Transmitters for more details.</p>"},{"location":"intro/whats-new/#exporter-enhancements","title":"Exporter Enhancements","text":"<p>Exporters can now use \"push\" model compression. This can simplify export code and improve performance. The \"pull\" model is still supported, and required for legacy versions and Encore.</p> <p>We've added the Export Standard Param Suite, which provides the standard parameters used in many built-in exporters. This can greatly reduce the amount of code needed to manage standard parameters for a typical exporter, and guarantee consistency with built-in exporters.</p> <p>Exporters can now set tooltip strings for parameters. Multiple exporters are now supported in a single plugin. And the Maximum Render Precision flag is now queried from the exporter, rather than being handled without the exporter's knowledge.</p> <p>Exporters can now set events (error, warning, or info) for a specific encode in progress in the Adobe Media Encoder render queue, using the new Exporter Utility Suite. These events are displayed in the application UI, and are also added to the AME encoding log.</p> <p>Make sure your presets go in the right location in the new AME Preset Browser. Read additional details of what's new in Exporters.</p>"},{"location":"intro/whats-new/#stereoscopic-video-pipeline","title":"Stereoscopic Video Pipeline","text":"<p>We are also adding API support for stereoscopic video throughout the render pipeline. This affects importers, effects built using the After Effects API, and exporters.</p>"},{"location":"intro/whats-new/#other-changes","title":"Other Changes","text":""},{"location":"intro/whats-new/#importers_3","title":"Importers","text":"<p>Importers can now support growing files in Premiere Pro. We have also added a way for importers to specify all their source files to be copied by Collect Files in After Effects. There is also a new function in the Media Accelerator Suite to validate the content state of a media accelerator. See additional details of what's new in Importers.</p>"},{"location":"intro/whats-new/#recorders","title":"Recorders","text":"<p>For Recorders, the parent window handle is now properly passed in during recmod_ShowOptions</p> <p>when a recorder should display its modal setup dialog.</p>"},{"location":"intro/whats-new/#players","title":"Players","text":"<p>For Players, pmPlayerSettings has a new member, mPrimaryDisplayFullScreen, which indicates whether or not the player should display fullscreen.</p>"},{"location":"intro/whats-new/#device-controllers","title":"Device controllers","text":"<p>Device controllers have a new callback, DroppedFrameProc, to provide the feature to abort and Export to Tape if frames are dropped.</p> <p>New video segment properties were added:</p> <ul> <li><code>kVideoSegmentProperty_MediaClipScaleToFramePolicy</code>,</li> <li><code>kVideoSegmentProperty_AdjustmentAdjustmentMediaIsOpaque</code>,</li> <li><code>kVideoSegmentProperty_AdjustmentOperatorsHash</code>,</li> <li><code>kVideoSegmentProperty_Media_InPointMediaTimeAsTicks</code>,</li> <li><code>kVideoSegmentProperty_Media_OutPointMediaTimeAsTicks</code>,</li> <li><code>kVideoSegmentProperty_Clip_TrackItemStartAsTicks</code>,</li> <li><code>kVideoSegmentProperty_Clip_TrackItemEndAsTicks</code>,</li> <li><code>kVideoSegmentProperty_Clip_EffectiveTrackItemStartAsTicks</code>,</li> <li><code>kVideoSegmentProperty_Clip_EffectiveTrackItemEndAsTicks</code></li> </ul> <p>The Memory Manager Suite is now at version 4. AdjustReservedMemorySize provides a way to adjust the reserved memory size relative to the current size. This may be easier for the plugin, rather than maintaining the absolute memory usage and updating it using the older ReserveMemory call.</p> <p>MPEG-4 pixel formats and full-range Rec. 709 MPEG-2 and MPEG-4 formats have now been added for native support in the render pipeline.</p>"},{"location":"intro/whats-new/#whats-new-in-cs55","title":"What's New in CS5.5?","text":""},{"location":"intro/whats-new/#importers_4","title":"Importers","text":"<p>Importers can now support color management, when running in After Effects. Now, even nonsynthetic importers can explicitly provide peak audio data. And a new return value allows an importer to specify that it is dependent on a library that needs to be activated. See additional details of what's new in Importers.</p>"},{"location":"intro/whats-new/#players_1","title":"Players","text":"<p>Players can now support closed captioning. See additional details of what's new in the players chapter.</p>"},{"location":"intro/whats-new/#exporters_3","title":"Exporters","text":"<p>Exporters now have a call to request a rendered frame and then conform it to a specific pixel format. See additional details of what's new in Exporters.</p>"},{"location":"intro/whats-new/#export-controller","title":"Export Controller","text":"<p>We have opened up a new Export Controller API that can drive any exporter to output a file in any format and perform custom post-processing operations. Developers wanting to integrate Premiere Pro with an asset management system will want to use this API instead of the exporter API. See Export Controllers for more details.</p> <p>A new pair of pixel formats was added to natively support full-range Rec. 601 4:2:0 YUV planar video, both progressive and interlaced: PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_601_FullRange and PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_601_FullRange.</p> <p>The Video Segment Suite now provides a new call to retrieve a segment node for a requested time. There are also a few new properties for media nodes:</p> <ul> <li><code>StreamIsContinuousTime</code>,</li> <li><code>ColorProfileName</code>,</li> <li><code>ColorProfileData</code>, and</li> <li><code>ScanlineOffsetToImproveVerticalCentering</code></li> </ul> <p>The Sequence Info Suite now provides a call to get the sequence frame rate, which may be useful for effects.</p> <p>The Image Processing Suite has a new call to set the aspect ratio flag of a DV frame.</p>"},{"location":"intro/whats-new/#whats-new-in-cs5","title":"What's New in CS5?","text":""},{"location":"intro/whats-new/#importers_5","title":"Importers","text":"<p>Importers now have access to the resolution, pixel aspect ratio, timebase, and audio sample rate of the source clip from a setup dialog. Custom importers can use a new call to update a clip after it has modified by the user in the setup dialog. Please refer to Importers for more info on what's new.</p>"},{"location":"intro/whats-new/#recorders_1","title":"Recorders","text":"<p>Recorders can now provide audio metering during preview and capture.</p>"},{"location":"intro/whats-new/#exporters-and-players","title":"Exporters and players","text":"<p>Exporters and players can automatically take advantage of GPU acceleration, if available on the end-user's system. Each project now has a setting for the renderer that the user can choose in the project settings dialog. When renders occur through the Sequence Render Suite or the Playmod Render Suite, they now go through the renderer chosen for the current project. This allows third-party exporters and players to use the built-in GPU acceleration available in the new Mercury Playback Engine.</p> <p>Exporters and players can now handle any pixel format, with the new Image Processing Suite. Exporters and players that parse segments and perform their own rendering can now call the host for subtree rendering. See the Video Segment Render Suite for details.</p> <p>Note</p> <p>If you provide an installer for an exporter, custom presets created in Premiere Pro are now visible in AME and vice-versa.</p>"},{"location":"intro/whats-new/#mac-64-bit-and-cocoa","title":"Mac 64-Bit and Cocoa","text":"<p>It is invalid to unload any bundle that uses Cocoa because of restrictions in the Objective-C runtime which do not support unregistering classes. If a plugin uses Cocoa, it must call CFRetain on its own bundle, otherwise it will cause a crash when the application is closing and tries to unload the plugins.</p>"},{"location":"intro/whats-new/#whats-new-in-cs4","title":"What's New in CS4?","text":""},{"location":"intro/whats-new/#new-renderer-api-and-custom-pixel-formats","title":"New Renderer API and Custom Pixel Formats","text":"<p>The new renderer API provides a way to take over and accelerate rendering of segments. Just as a player can choose which segments to accelerate, so a renderer can choose which segments to accelerate. Renderers may accelerate any segment, in any sequence, in any project.</p> <p>Renderers also provide a way to add completely custom pixel formats to the render pipeline. Supporting a custom pixel format in an importer, a renderer, and an exporter is the new way to implement smart rendering, by passing custom compressed data from input to output.</p>"},{"location":"intro/whats-new/#sequence-preview-formats","title":"Sequence Preview Formats","text":"<p>Sequence preview file formats are now defined by Sequence encoder preset files. Without any presets installed, you will not be able to create a new sequence using your custom editing mode.</p>"},{"location":"intro/whats-new/#separate-processes-during-export","title":"Separate Processes During Export","text":"<p>When choosing export settings, the settings UI is displayed by Premiere Pro. When the user confirms the settings, the clip or sequence is passed to Media Encoder. From Media Encoder, frames from the clip or sequence can be retrieved and rendered without further participation from Premiere Pro. For a clip export, Media Encoder uses any installed importers to get source frames. For sequence export, Media Encoder uses a process called PProHeadless, to import and render frames to be exported.</p> <p>Since there are so many processes involved during export, it is important that plugins be accessible to all processes, by being installed in the common plugins folder. PProHeadless Plugin Loading.log provides information on the PProHeadless process. PProHeadless is also used when the user creates a dynamic link to a .prproj that is not opened in Premiere Pro.</p>"},{"location":"intro/whats-new/#xmp-metadata","title":"XMP metadata","text":"<p>There are built-in XMP metadata handlers for known filetypes. These handlers write and read metadata to and from the file, without going through the importer. imSetTimeInfo8 is no longer called, since this is set by the XMP handler for that filetype.</p>"},{"location":"intro/whats-new/#more-pixel-format-flexibility","title":"More Pixel Format Flexibility","text":"<p>Effects, transitions, and exporters no longer need to support 8-bit RGB at a minimum. So, for example, an effect can be written to process floating point YUV only. If necessary, Premiere will make an intermediate conversion so that the effect will receive the pixel format it supports.</p>"},{"location":"intro/whats-new/#legacy-api","title":"Legacy API","text":"<p>Legacy API features, such as selectors and callbacks that are superceded by new ones, are deprecated, but are supported, unless indicated.</p>"},{"location":"intro/where-do-i-start/","title":"Where Do I Start","text":"<p>Read about the sample projects. Decide which one is closest to the functionality you want to provide. Build the plugin into the shared plugins folder.</p> <p>Launch Premiere Pro with the debugger attached, and set breakpoints at the plugin's entry point to see all communication between Premiere Pro and the plugin.</p> <p>The documentation is intended as a reference with detailed explanation where appropriate, but studying the interaction between Premiere Pro and plugins is the best way to understand it.</p> <p>Write plugins by modifying sample plugin source code. This will greatly simplify your efforts, and make it easier for us to help you. Feel free to explore and experiment with the API on your own once you're familiar with it, but please, resist the temptation to start from scratch; you'll only force yourself to repeat other developers' mistakes, including our own.</p> <p>If you run into behavior that seems wrong, see if you can reproduce the behavior using one of the unmodified sample projects. This can save you a lot of time, if you can determine whether the bug behavior was introduced by your modifications, or was already there to begin with.</p>"},{"location":"resources/impt-resource/","title":"IMPT Resource","text":"<p>Premiere Pro looks for an IMPT resource to identify a plugin as an importer.</p> <p>Before Premiere Pro 1.0, the IMPT resource was also used to declare the file extension supported by an importer.</p> <p>Since file extensions are now declared during imGetIndFormat, the drawtype four character code in the IMPT resource is no longer used by Premiere Pro.</p> <p>However, a unique drawtype fourcc is needed for the importer to function properly in After Effects on macOS.</p> <p>Do not use 0x4D4F6F76. This is already reserved by After Effects.</p> <pre><code>1000 IMPT DISCARDABLE BEGIN\n0x12345678 // Put your own unique hexadecimal code here\nEND\n</code></pre>"},{"location":"resources/pipl-resource/","title":"Plug-In Property Lists (PiPL) Resource","text":"<p>For many plugin types, Premiere loads a PiPL (Plug-in Property List) resource. The PiPL is described in a file with a \".r\" extension.</p> <p>The complete PiPL syntax is described in PiPL.r.</p> <p>You'll notice that PiPLs are really old. A vestige of 68k macOS programming, they spread to Windows.</p> <p>However, if you develop from the sample projects, you shouldn't have to do anything to get them to build properly for Latin languages.</p>"},{"location":"resources/pipl-resource/#which-types-of-plugins-need-pipls","title":"Which Types of Plugins Need PiPLs?","text":"<p>Exporters, players, and recorders do not need PiPLs.</p> <p>Standard importers do not need PiPLs. Synthetic and custom importers use a basic PiPL to specify their name, and the match name that Premiere uses to identify them. The name appears in the File &gt; New menu.</p> <p>Device controllers use a basic PiPL to specify their name and the match name that Premiere uses to identify them.</p> <p>Video filters use an extended PiPL to specify their name, the match name that Premiere uses to identify them, the bin they go in, how they handle pixel aspect ratio, whether or not they have randomness, and their parameters.</p> <p>For more information on the <code>ANIM_FilterInfo</code> and <code>ANIM_ParamAtom</code>, see the resources section in Video Filters.</p>"},{"location":"resources/pipl-resource/#a-basic-pipl-example","title":"A Basic PiPL Example","text":"<pre><code>#define plugInName \"SDK Custom Import\"\n#define plugInMatchName \"SDK Custom Import\"\n\nresource 'PiPL' (16000) {\n{\n\n  // The plugin type\n  Kind {PrImporter},\n\n  // The name as it will appear in a Premiere menu, this can be localized\n  Name {plugInName},\n\n  // The internal name of this plugin - do not localize this. This is used for both Premiere and After Effects plugins.\n  AE_Effect_Match_Name {plugInMatchName}\n\n  // Transitions and video filters define more PiPL attributes here\n}\n\n};\n</code></pre>"},{"location":"resources/pipl-resource/#how-pipls-are-processed-by-resource-compilers","title":"How PiPLs Are Processed By Resource Compilers","text":"<p>On macOS, .r files are processed natively by Xcode, as a Build Phase of type Build Carbon Resources. This step is already set for the sample projects.</p> <p>On Windows, .r files are processed with CnvtPiPL.exe, which creates an .rcp file based upon custom build steps in the project. The .rcp file is then included in the .rc file along with any other resources the plugin uses. These custom build steps are already in place in the sample projects.</p> <p>To view them, open up the sample project in .NET. In the Solution Explorer, right-click the .r file and choose Properties. In the dialog, choose the Custom Build Step folder. The Command</p> <p>Line contains the script for executing the CnvtPiPL.exe. Unless you are using a different compiler than the support compiler, or adding support for Asian languages, you should not need to modify the custom build steps. This script may also be found as a text file in the SDK at <code>\\\\Examples\\\\Resources\\\\Win\\\\Custom Build Steps.txt</code>. This text file also describes the additional switches used for Asian languages.</p>"},{"location":"resources/resources/","title":"Resources","text":"<p>There are two types of special resources that are specific to Premiere plugins: the PiPL and the IMPT.</p> <p>This chapter describes these resources, and how certain plugin types use them.</p>"},{"location":"transmitters/suites/","title":"Suites","text":"<p>For information on how to acquire and manage suites, as well as information on more suites that are available to other plugin types beyond just transmitters, see SweetPea Suites.</p>"},{"location":"transmitters/suites/#playmod-audio-suite","title":"Playmod Audio Suite","text":"<p>This suite is used to play audio during playback. There are many more functions that were used by players, still documented in the players chapter. Here we will only consider the single call in the suite that is relevant to transmitters.</p>"},{"location":"transmitters/suites/#host-based-or-plug-in-based-audio","title":"Host-Based, or Plug-in Based Audio?","text":"<p>A transmitter has two choices for playing audio: it can ask the host to play the audio through the audio device selected by the user, or it can get audio buffers from the host and handle its own playback of audio.</p>"},{"location":"transmitters/suites/#getnextaudiobuffer","title":"GetNextAudioBuffer","text":"<p>Retrieves from the host the next contiguous requested number of audio sample frames, specified in <code>inNumSampleFrames</code>, in <code>inInBuffers</code> as arrays of uninterleaved floats.</p> <p>The plugin must manage the memory allocation of <code>inInBuffers</code>, which must point to n buffers of floating point values of length <code>inNumSampleFrames</code>, where n is the number of channels. This call is only available if <code>InitPluginAudio</code> was used.</p> <p>Returns:</p> <ul> <li><code>suiteError_NoError</code>,</li> <li><code>suiteError_PlayModuleAudioNotInitialized</code>, or</li> <li><code>suiteError_PlayModuleAudioNotStarted</code></li> </ul> <pre><code>prSuiteError (*GetNextAudioBuffer)(\n  csSDK_int32   inPlayID,\n  float**       inInBuffers,\n  float**       outOutBuffers,\n  unsigned int  inNumSampleFrames);\n</code></pre> Parameter Description <code>inInBuffers</code> Currently unused in CS6.A pointer to an array of buffers holding <code>inNumSampleFrames</code> input audio in each buffer, corresponding to the total number of available input channels. <code>outOutBuffers</code> A pointer to an array of buffers <code>inNumSampleFrames</code> long into which the host will write the output audio.There must be N buffers, where N is the number of output channels for the output channel type specified in <code>InitPluginAudio</code>. <code>inNumSampleFrames</code> The size of each of the buffers in the array in both <code>inInBuffers</code> and <code>outOutBuffers</code>."},{"location":"transmitters/suites/#transmit-invocation-suite","title":"Transmit Invocation Suite","text":"<p>This suite can be used by other types of plugins to push frames to transmitters.</p> <p>For example, an effect or titler with a modal setup dialog could push frames to the output.</p>"},{"location":"transmitters/tmModule-functions/","title":"tmModule Functions","text":"<p>Fill in <code>0</code> for any unsupported calls. Thread safety is defined per-module, only a single thread will enter a module at a time.</p> Member Description <code>Startup</code> Initialize a transmitter, fill in basic plugin info, allocate memory to hold user settings and other data.<pre>tmResult (*Startup)(tmStdParms* ioStdParms,tmPluginInfo* outPluginInfo);</pre><code>tmResult_ContinueIterate</code> may be returned to support multiple transmit plugins within the same module.<code>ioPrivatePluginData</code>, <code>ioSerializedPluginData</code> &amp; <code>ioSerializedPluginDataSize</code> may be written from Startup. <code>Shutdown</code> Terminate a transmitter.<pre>tmResult (*Shutdown)(tmStdParms* ioStdParms);</pre>Dispose of <code>ioPrivatePluginData</code> if previously allocated in <code>Startup</code>. <code>QueryAudioMode</code> Describe the audio modes supported by the transmitter, one at a time.<pre>tmResult (*QueryAudioMode)(const tmStdParms* inStdParms,const tmInstance* inInstance,csSDK_int32 inQueryIterationIndex,tmAudioMode* outAudioMode);</pre>Note that currently one audio mode is currently supported. You can convert between audio formats using the Audio Suite. <code>QueryVideoMode</code> Describe the video modes supported by the transmitter, one at a time.<pre>tmResult (*QueryVideoMode)(const tmStdParms* inStdParms,const tmInstance* inInstance,csSDK_int32 inQueryIterationIndex,tmVideoMode* outVideoMode);</pre>The video sent later in <code>PushVideo</code> will be one of the formats specified here. <code>SetupDialog</code> Display your own modal settings dialog.<pre>tmResult (*SetupDialog)(tmStdParms* ioStdParms,prParentWnd inParent);</pre>Will only be called if the plugin returned <code>outHasSetup</code>.Save any settings to <code>ioSerializedPluginData</code> and if needed update <code>ioSerializedPluginDataSize</code>.<code>NeedsReset</code> will be invoked after this call, to allow your transmitter a chance to reset all open plugins and startup with the new settings. <code>NeedsReset</code> Will be called regularly on the first plugin of a module to allow rebuilding on state changes.<pre>tmResult (*NeedsReset)(const tmStdParms* inStdParms,prBool* outResetModule);</pre>If the passed in settings differ enough from the created settings, or if the settings on the hardware itself have changed, the transmitter should specify a reset is needed.If <code>outResetModule</code> is set to true, all open plugins will be shutdown and started up again. <code>CreateInstance</code> Creates an instance of a transmitter.<pre>tmResult (*CreateInstance)(const tmStdParms* inStdParms,tmInstance* ioInstance);</pre><code>inPlayID</code> and <code>inTimelineID</code> may be 0 if not driven by a player.Multiple instances may be created at the same time.Allocate <code>ioPrivateInstanceData</code>. <code>DisposeInstance</code> Dispose an instance of a transmitter.<pre>tmResult (*DisposeInstance)(const tmStdParms* inStdParms,tmInstance* ioInstance);</pre>Any <code>ioPrivateInstanceData</code> should be disposed. <code>ActivateDeactivate</code> Activate or deactivate a transmitter instance, for example during application suspend or switching between monitors.<pre>tmResult (*ActivateDeactivate)(const tmStdParms* inStdParms,const tmInstance* inInstance,PrActivationEvent inActivationEvent,prBool inAudioActive,prBool inVideoActive);</pre>Transmitters should manage hardware access with these calls, not <code>Startup</code>/<code>Shutdown</code>, since it is valid for multiple plugins to be simultaneously active for the same device.Audio and video may be independently activated. <code>StartPlaybackClock</code> Start a clock for playback.<pre>tmResult (*StartPlaybackClock)(const tmStdParms* inStdParms,const tmInstance* inInstance,const tmPlaybackClock* inClock);</pre>This will be sent not only when starting playback, but also for scrubbing.Will only be called if the transmitter returned <code>outHasClock</code>.The provided callback must be called each time the time changes, for example once for each frame in response to <code>PushVideo</code>.Start may be called multiple times without a stop in between to update playback parameters, for example if the speed changes during playback.Invoke the callback immediately during <code>StartPlaybackClock</code> with a negative number for preroll but do not use this to wait for frames.If video latency is specified, up to the latency's amount of frame marked as <code>playmode_Playing</code> will be sent before <code>StartPlaybackClock</code> is called. <code>StopPlaybackClock</code> Stop a clock for playback.<pre>tmResult (*StopPlaybackClock)(const tmStdParms* inStdParms,const tmInstance* inInstance);\n\n\n<code>PushVideo</code>\nAsynchronously pushes a video frame to a transmitter instance.<pre>tmResult (*PushVideo)(const tmStdParms* inStdParms,const tmInstance* inInstance,const tmPushVideo* inPushVideo);</pre>Will only be called if the transmitter returned <code>outHasVideo</code>.The list of video frames passed to the transmitter will be negotiated based on the properties returned from <code>QueryVideoMode</code>.The transmitter is responsible for disposing of all passed in <code>PPixes</code>.The instance will be created with the properties of the creating video segments which may differ from the actual frames that will be sent to the transmitter.For example, if a sequence is being played at 1/2 resolution, the instance will be created with the dimensions of the sequence, but the frames rendered and sent to the transmitter will be at 1/2.These properties may change by segment, for example if your transmitter supports multiple pixel formats, different segments may render to different pixel formats.\n\n\n<code>StartPushAudio</code>\nAsynchronously pushes audio samples to a transmitter instance.<pre>tmResult (*StartPushAudio)(const tmStdParms* inStdParms,const tmInstance* inInstance,PrTime inStartTime,PrTime inOutTime,prBool inLoop,prBool inScrubbing,csSDK_int32* outSamplesPerFrame);</pre>Initializes the device for subsequent PushAudio() calls. Will only be called if the transmitter returned <code>outPushAudioAvailable</code>.Device will be enabled for a \"secondary\" mode where audio from the \"primary\" or \"clock\" device, is pushed to a secondary device; very useful for remote devices.Unlick StartPlaybackClock(), StartPushAudio() is only called once, until StopPushAudio() is called.\n\n\n<code>PushAudio</code>\nAsynchronously pushes audio samples to a transmitter instance.  Note: PushAudio() may be called even if another API is called at the same time.<pre>tmResult (*PushAudio)(const tmStdParms* inStdParms,const tmInstance* inInstance,const tmPushAudio* inPushAudio);\n\n\n<code>StopPushAudio</code>\nStopPushAudio() is called when playback via PushAudio() ends.<pre>tmResult (*StopPushAudio)(const tmStdParms* inStdParms,const tmInstance* inInstance);\n\n\n<code>SetStreamingStateChangedCallback</code>\nSet the host callback for notification streaming state changes, i.e. when the plug-in becomes active or inactive due to changes connections   or enablement from the host.<pre>tmResult (*SetStreamingStateChangedCallback)(const tmStdParms* inStdParms,void* inContext,tmStreamingStateChangedCallback inCallback);\n\n\n<code>EnableStreaming</code>\nEnable/disable streaming to connected clients without loading or unloading the plug-in.<pre>tmResult (*EnableStreaming)(const tmStdParms* inStdParms,prBool            inEnabled);\n\n\n<code>IsStreamingEnabled</code>\nReturns whether streaming is enabled.<pre>tmResult (*IsStreamingEnabled)(const tmStdParms* inStdParms,prBool*           outEnabled);\n\n\n<code>IsStreamingActive</code>\nReturns whether the plug-in is actively streaming, i.e. streaming is enabled and the plug-in has active connections.<pre>tmResult (*IsStreamingActive)(const tmStdParms* inStdParms,prBool*           outActive);\n\n\n<code>Shutdown</code>\nTerminate a transmitter.<pre>tmResult (*Shutdown)(tmStdParms* ioStdParms);</pre>Dispose of <code>ioPrivatePluginData</code> if previously allocated in <code>Startup</code>."},{"location":"transmitters/tmModule-structures/","title":"tmModule Structures","text":""},{"location":"transmitters/tmModule-structures/#tmstdparms","title":"tmStdParms","text":"<p>This is passed to all calls. Most of it is allocated and filled in by the transmitter on Startup, and may be modified during SetupDialog.</p> <pre><code>typedef struct {\n  csSDK_int32   inPluginIndex;\n  PrMemoryPtr   ioSerializedPluginData;\n  csSDK_size_t  ioSerializedPluginDataSize;\n  void*         ioPrivatePluginData;\n  piSuitesPtr   piSuites;\n} tmStdParms;\n</code></pre> Member Description <code>inPluginIndex</code> If the plugin has defined multiple transmitters in the same module, this index value tells them apart. <code>ioSerializedPluginData</code> This data should contain user-selectable settings for the transmitter, that would be shown in the transmitter settings dialog, and need to persist so they can be saved and restored from one session to another.When allocating this for the first time during Startup, this must be allocated using <code>NewPtr</code> so it can be disposed by the host on shutdown.This must be flat memory that can be serialized by by the host and will be already filled in when Startup is called if previously available. <code>ioSerializedPluginDataSize</code> Size of the data above. Set this during Startup, if not already set. <code>ioPrivatePluginData</code> This data should contain any memory needed for use across calls to the transmitter, except the settings data stored in <code>ioSerializedPluginData</code>.Allocate this during Startup. Unlike <code>ioSerializedPluginData</code>, it does not need to be flat, and must be disposed of by the plugin on Shutdown."},{"location":"transmitters/tmModule-structures/#tmplugininfo","title":"tmPluginInfo","text":"<p>This is to be filled in by the transmitter on Startup.</p> <pre><code>typedef struct {\n  prPluginID    outIdentifier;\n  unsigned int  outPriority;\n  prBool        outAudioAvailable;\n  prBool        outAudioDefaultEnabled;\n  prBool        outClockAvailable;\n  prBool        outVideoAvailable;\n  prBool        outVideoDefaultEnabled;\n  prUTF16Char   outDisplayName[256];\n  prBool        outHideInUI;\n  prBool        outHasSetup;\n  csSDK_int32   outInterfaceVersion;\n} tmPluginInfo;\n</code></pre> Member Description <code>outIdentifier</code> Persistent plugin identifier. <code>outPriority</code> <code>0</code> is default, higher priority wins. <code>outAudioAvailable</code> Set this to <code>kPrTrue</code> if the transmitter supports audio. <code>outAudioDefaultEnabled</code> Set this to <code>kPrTrue</code> if you want to be turned on to handle audio by default. <code>outClockAvailable</code> Set this to <code>kPrTrue</code> if providing plugin based audio.Currently, even if using host-based audio, a transmitter must provide a clock - please let us know if you would like to use host-based audio only, and we will log a bug on this. <code>outVideoAvailable</code> Set this to <code>kPrTrue</code> if the transmitter supports video. <code>outVideoDefaultEnabled</code> Set this to <code>kPrTrue</code> if you want to be turned on to handle video by default. <code>outDisplayName[256]</code> Set the display name of the transmitter, up 256 UTF-16 characters, including NULL terminator. <code>outHideInUI</code> Set this to <code>kPrTrue</code> if you don't want this to show up as a user-selectable option in the transmitter choices. <code>outHasSetup</code> Set this to <code>kPrTrue</code> if providing a setup dialog. <code>outInterfaceVersion</code> Set this to the <code>tmInterfaceVersion</code> that the transmitter is being compiled for. <code>outPushAudioAvailable</code> New in 24.0. Set this to <code>kPrTrue</code> if the transmitter supports push audio functionality. The device will be enabled for a 'secondary' mode where audio from the 'primary' or 'clock' device is pushed to this one. <code>outHasStreaming</code> New in 24.0. Set this to <code>kPrTrue</code> if the transmitter streams audio or video (over a network). <p>Bug</p> <p>The following text block was present here, though seems to be misplaced. todo!</p> <p>The device will be enabled for a \"secondary\" mode where audio from the \"primary\" or \"clock\" device is pushed to this one. This is especially useful for remote devices. PushAudio APIs will only be used in this \"mirror\" case. StartPushAudio() initializes the device for subsequent PushAudio() calls. Unlike StartPlaybackClock, StartPushAudio() is only called once until StopPushAudio() is called. PushAudio() is called whenever the desired buffer size is</p>"},{"location":"transmitters/tmModule-structures/#tminstance","title":"tmInstance","text":"<p>This structure contains information for the transmitter to use for initializing an instance.</p> <pre><code>typedef struct {\n  csSDK_int32          inInstanceID;\n  PrTimelineID         inTimelineID;\n  PrPlayID             inPlayID;\n  prBool               inHasAudio;\n  csSDK_uint32         inNumChannels;\n  PrAudioChannelLabel  inChannelLabels[16];\n  PrAudioSampleType    inAudioSampleType;\n  float                inAudioSampleRate;\n  prBool               inHasVideo;\n  csSDK_int32          inVideoWidth;\n  csSDK_int32          inVideoHeight;\n  csSDK_int32          inVideoPARNum;\n  csSDK_int32          inVideoPARDen;\n  PrTime               inVideoFrameRate;\n  prFieldType          inVideoFieldType;\n  void*                ioPrivateInstanceData;\n} tmInstance;\n</code></pre> Member Description <code>inInstanceID</code> Instance identifier. <code>inTimelineID</code> <code>TimelineID</code>, for use with various suite functions. May be 0. <code>inPlayID</code> <code>PlayID</code>, for use with various suite functions. May be 0. <code>inHasAudio</code> True if the instance is handling a sequence with audio. <code>inNumChannels</code> The number of audio channels. <code>inChannelLabels[16]</code> The identifiers for each audio channel. <code>inAudioSampleType</code> The format of the audio data. <code>inAudioSampleRate</code> The sample rate of the audio data. <code>inHasVideo</code> True if the instance is handling a sequence with video. <code>inVideoWidth</code> The video resolution. <code>inVideoHeight</code> <code>inVideoPARNum</code> The numerator and denominator of the video pixel aspect ratio. <code>inVideoPARDen</code> <code>inVideoFrameRate</code> The frame rate of the video. <code>inVideoFieldType</code> The field dominance of the video. <code>ioPrivateInstanceData</code> May be written by plugin in <code>CreateInstance</code>, and disposed of by <code>DisposeInstance</code>. Need not be serializable by the host."},{"location":"transmitters/tmModule-structures/#tmaudiomode","title":"tmAudioMode","text":"<p>A full description of an audio mode that the transmitter will support.</p> <p>The transmitter should fill in this information during <code>QueryAudioMode</code>.</p> <pre><code>typedef struct {\n  float                outAudioSampleRate;\n  csSDK_uint32         outMaxBufferSize;\n  csSDK_uint32         outNumChannels;\n  PrAudioChannelLabel  outChannelLabels[16];\n  PrTime               outLatency;\n  PrSDKString          outAudioOutputNames[16]\n} tmAudioMode;\n</code></pre> Member Description <code>outAudioSampleRate</code> The preferred audio sample rate. <code>outMaxBufferSize</code> The maximum audio buffer size needed if the transmitter uses plugin-based audio to request audio buffers using the Playmod Audio Suite. <code>outNumChannels</code> The maximum number of audio channels supported. <code>outChannelLabels[16]</code> Set the audio channel configuration for the output hardware using the appropriate identifiers for each audio channel. <code>outLatency</code> This value is only used for playback, not when scrubbing.It specifies how early to send frames in advance when audio-only playback starts, and how many frames that will be sent prior to a <code>StartPlaybackClock</code> call. Use this value to get playback in sync between the Source/Program Monitors and external hardware output.All modes must have the same latency.Take care to not set this value any higher than necessary, since playback start will delayed by this amount. A value equivalent to 5 video frames or less is recommended. <code>outAudioOutputNames[16]</code> New in CS6.0.2. These must be displayable names of physical audio outputs like \"XYZ HD Speaker 1\"The audio output names in tmAudioMode should be allocated by the plugin using the String Suite and NOT disposed by the plugin. The host will take care of disposing these strings."},{"location":"transmitters/tmModule-structures/#tmvideomode","title":"tmVideoMode","text":"<p>A full description of a video mode that the transmitter will support.</p> <p>Transmitter should fill in this information during <code>QueryVideoMode</code>.</p> <pre><code>typedef struct {\n  csSDK_int32    outWidth;\n  csSDK_int32    outHeight;\n  csSDK_int32    outPARNum;\n  csSDK_int32    outPARDen;\n  prFieldType    outFieldType;\n  PrPixelFormat  outPixelFormat;\n  PrSDKString    outStreamLabel;\n  PrTime         outLatency;\n  ColorSpaceRec  outColorSpaceRec;\n} tmVideoMode;\n</code></pre> Member Description <code>outWidth</code> The preferred video resolution.Set to 0 if any resolution is supported. <code>outHeight</code> <code>outPARNum</code> The preferred video pixel aspect ratio.Set to 0 if any pixel aspect ratio is supported. <code>outPARDen</code> <code>outFieldType</code> The supported video field type.Set to prFieldsAny if any field dominance is supported. <code>outPixelFormat</code> The preferred video pixel format.Set to <code>PrPixelFormat_Any</code> if any format is acceptable.If your transmitter would benefit from on-GPU frames, please let us know. <code>outStreamLabel</code> Leave this as 0 for now. Stream labels are not yet supported by transmitters (bug group BG127571) <code>outLatency</code> This value is only used for playback, not when scrubbing.It specifies how early to send frames in advance when playback starts, and how many frames that will be sent prior to a <code>StartPlaybackClock</code> call.Use this value to get playback in sync between the Source/Program Monitors and external hardware output.All modes must have the same latency.Take care to not set this value any higher than necessary, since playback start will delayed by this amount. A value equivalent to 5 frames or less is recommended. <code>outColorSpaceRec</code> New in 14.x. Definition of the colorspace in use; defaults to BT 709 full range 32f.Transmitter can request host application to send frame in specific colorspace. See to <code>ColorSpaceRec</code> for detailed description."},{"location":"transmitters/tmModule-structures/#tmplaybackclock","title":"tmPlaybackClock","text":"<p>This structure is filled out by the host and sent to the transmitter to describe the playback clock to be managed by the transmitter.</p> <p>The transmitter uses the callback here to update the host at regular intervals.</p> <pre><code>typedef struct {\n  tmClockCallback         inClockCallback;\n  void*                   inCallbackContext;\n  PrTime                  inStartTime;\n  pmPlayMode              inPlayMode;\n  float                   inSpeed;\n  PrTime                  inInTime;\n  PrTime                  inOutTime;\n  prBool                  inLoop;\n  tmDroppedFrameCallback  inDroppedFrameCallback;\n} tmPlaybackClock;\n</code></pre> Member Description <code>tmClockCallback</code> A pointer to a call with the following signature:<pre>void (tmClockCallback)(  void   inContext,  PrTime  inRelativeTimeAdjustment);</pre>Call this function when the time changes with a non-speed adjusted amount to increment the clock by.This can be called once per frame in response to PushVideo.Using a negative time should only be used to wait for device, not to achieve sync.The transmitter will not receive any frames while using a negative time.After the first positive valued clock callback, the time will be in <code>StartTime + inRelativeTimeAdjustment * inSpeed</code>. <code>inCallbackContext</code> Pass this into the clock callback above. <code>inStartTime</code> Start the clock at this time. <code>inPlayMode</code> Specifies whether the <code>StartPlaybackClock</code> was set for playback or scrubbing. <code>inSpeed</code> 1.0 is normal speed, -2.0 is double speed backwards.Informational only.This is useful for the built-in DV transmitter, which only writes DV captions if playing at regular speed. <code>inInTime</code> Informational only and will be handled by the host. <code>inOutTime</code> <code>inLoop</code> <code>inDroppedFrameCallback</code> A pointer to a call with the following signature:<pre>void (tmDroppedFrameCallback)(  void        inContext,  csSDK_int64  inNewDroppedFrames);</pre>Use this call to report frames pushed to the transmit plugin on PushVideo but not delivered to the device.If every frame pushed to the transmitter is sent out to hardware on time, then this should never need to be called as the host will count frames not pushed to the plugin.<code>inNewDroppedFrames</code> should be the number of additional dropped frames since the last time <code>tmDroppedFrameCall</code> back was called."},{"location":"transmitters/tmModule-structures/#tmpushvideo","title":"tmPushVideo","text":"<p>Describes a frame of video to be transmitted.</p> <pre><code>typedef struct {\n  PrTime                 inTime;\n  pmPlayMode             inPlayMode;\n  PrRenderQuality        inQuality;\n  const tmLabeledFrame*  inFrames;\n  csSDK_size_t           inFrameCount;\n} tmPushVideo;\n</code></pre> Member Description <code>inTime</code> Describes which frame of the video is being passed in.A negative value means the frame should be displayed immediately.Use this value to determine the corresponding timecode for the frame being pushed. <code>inPlayMode</code> Pass this into the clock callback above. <code>inQuality</code> The quality of the render. <code>inFrames</code> The frame or set of frames to transmit. As of CS6, this will always be a single frame.<code>tmLabeledFrame</code> is defined as:<pre>typedef struct {  PPixHand          inFrame;  PrSDKStreamLabel  inStreamLabel;} tmLabeledFrame;</pre>The frame(s) must be disposed of by the transmitter when done. <code>inFrameCount</code> The number of frames in inFrames."},{"location":"transmitters/tmModule-structures/#tmpushaudio","title":"tmPushAudio","text":"<p>Describes audio samples to be transmitted.</p> <pre><code>typedef struct {\n      PrTime          inTime;\n      float**         inBuffers;\n      csSDK_uint32    inNumSamples;\n      csSDK_uint32    inNumChannels;\n} tmPushAudio;\n</code></pre> Member Description <code>inTime</code> Describes which frame of the video is being passed in.A negative value means the frame should be displayed immediately.Use this value to determine the corresponding timecode for the frame being pushed. <code>inBuffers</code> The audio date to be transmitted. <code>inNumSamples</code> Number of samples to process. <code>inNumChannels</code> Number of channels to output."},{"location":"transmitters/tmModule-structures/#tmstoppushaudio","title":"tmStopPushAudio","text":"<p>Sent when playback via PushAudio() ends.</p> <pre><code>typedef struct {\n      PrTime          inTime;\n      float**         inBuffers;\n      csSDK_uint32    inNumSamples;\n      csSDK_uint32    inNumChannels;\n} tmPushAudio;\n</code></pre> Member Description <code>inTime</code> Describes which frame of the video is being passed in.A negative value means the frame should be displayed immediately.Use this value to determine the corresponding timecode for the frame being pushed. <code>inBuffers</code> The audio date to be transmitted. <code>inNumSamples</code> Number of samples to process. <code>inNumChannels</code> Number of channels to output."},{"location":"transmitters/transmitter-basics/","title":"Transmitter Basics","text":""},{"location":"transmitters/transmitter-basics/#basic-organization","title":"Basic Organization","text":"<p>A transmitter module can define multiple plugins. Each plugin can appear in the Playback Preferences as an option for video playback and/or audio playback. Only one transmitter can be used for audio, since the transmitter used for audio drives the clock. Multiple transmitters may be selected for video simultaneously.</p> <p>When active, multiple instances of a single plugin can be created. An instance is created to display a clip or sequence. Hardware access is regulated through ActivateDeactivate. Only an active instance should access the hardware.</p>"},{"location":"transmitters/transmitter-basics/#video-formats","title":"Video Formats","text":"<p>Specify which video format(s) you wish to receive during QueryVideoMode. To simplify your plugin, be as specific as possible, and allow the host to perform the conversion asynchronously ahead of time. Packed and compressed formats are also supported. If multiple formats are specified, the closest will be selected at render time. If your transmitter would benefit from on-GPU frames, please let us know.</p> <p>When sent QueryVideoMode, the transmitter is informed about the clip/sequence video attributes by being passed a tmInstance pointer. So, for example, if the transmitter instance is constructed to support a 1920x1080 timeline, it can report that same size back to the host application, so that it will not have to handle any scaling. If, for example, it does handle scaling, and it is constructed to handle a 1440x1080 timeline, it can report 1440x1080 and handle the scaling itself. In this way you can choose a single fixed size depending on the timeline.</p> <p>When video frames are pushed to the transmitter, properties like pixel format may change on a segment-by-segment basis depending on the source footage. Other properties like size may change based on the current fractional resolution, which may differ between scrubbing and stopped.</p>"},{"location":"transmitters/transmitter-basics/#fractional-resolution","title":"Fractional Resolution","text":"<p>In the Premiere Pro Source and Program Monitors, the user can choose independent resolutions for rendering during playback and paused modes. For example, it is common to have the playback resolution set to half, and paused resolution set to full.</p> <p>If an output card has a hardware scaler, the transmit plugin can declare support for fractional resolutions. For example, for a 1920x1080 instance, it could declare support for not only</p> <p>1920x1080, but also 960x540, 480x270, etc. This will allow the renderer to skip the step of rescaling back up to full resolution after rendering at a fractional resolution. If however, the plugin only declares support for full resolution, the renderer will scale the video back up before pushing it to the transmitter.</p>"},{"location":"transmitters/transmitter-basics/#audio-format","title":"Audio Format","text":"<p>During QueryAudioMode, a transmitter will be told how many channels the instance has. The transmitter should change that value based on what it can support and then make sure the buffers it provides match that. Although Premiere Pro can support 32 channels of audio, transmitters can only support up to 16 channels of audio.</p> <p>As of CS6, sequences will currently always report audio available in CreateInstance, even if empty. An example of somewhere that a transmitter will be called with no audio is for video output from the RED settings dialog, which is video only.</p> <p>A transmitter should call GetNextAudioBuffer only when inAudioActive is passed as true to ActivateDeactivate.</p>"},{"location":"transmitters/transmitter-basics/#frame-rate","title":"Frame Rate","text":"<p>For framerate, video will be pushed to you at the rate of the timeline. This was chosen because of the wide variety in conversion policies, including pulldown, frame duplication, etc.</p>"},{"location":"transmitters/transmitter-basics/#dropped-frames","title":"Dropped Frames","text":"<p>If the host cannot keep up rendering, it will send duplicate frames with PushVideo. If you receive a frame that cannot be sent out to hardware on time, notify the host using inDroppedFrame Callback in tmPlaybackClock. In Premiere Pro, the user can turn on the Dropped Frame Indicator to see the total number of frames that were dropped either because the host couldn't keep up, or the hardware couldn't keep up.</p>"},{"location":"transmitters/transmitter-basics/#sync-between-application-ui-and-hardware-output","title":"Sync Between Application UI and Hardware Output","text":"<p>Naturally there is some latency between the time the host sends frames to be displayed on the output, and the time it can actually be displayed. Use tmVideoMode.outLatency to specify the latency. For example, if a transmitter specifies 5 frames of latency, when the user starts playback, the host will send 5 frames of video to the transmitter before sending StartPlaybackClock. This allows time for the transmitter to send frames to the hardware output in advance, so that the hardware output will be in sync with the monitor in the host application UI.</p> <p>When the user is scrubbing in the timeline, send the video frames as fast as possible to the output. The host application UI will not wait for the hardware output to catch up, and currently as of</p> <p>6.0.1 there may be a noticable latency. To reduce the scrubbing latency as much as possible, when scrubbing or stopped the transmitter should cancel any frames it has pending to immediately display the new one.</p>"},{"location":"transmitters/transmitter-basics/#dog-ears","title":"Dog Ears","text":"<p>Turn on dog ears to view statistics about the frames being sent to the transmitter. This is useful to view information such as pixel formats and much more.</p> <p>Note</p> <p>This mode may result in duplicate PushVideo calls made for a single frame.</p>"},{"location":"transmitters/transmitter-basics/#closed-captioning","title":"Closed Captioning","text":"<p>This captioning data is attached to a sequence by the user via menu items in the Sequence menu. In the Program Monitor, the Closed Captioning Display options in the fly-out menu give the user control over the display. The hardware should always transmit any Closed Captioning data, and the user can go through the hardware monitor's on-screen display menu to choose which caption track to view. The closed captioning data is accessible using the new Captioning Suite. Use this data for the hardware output.</p>"},{"location":"transmitters/transmitter-basics/#driving-transmitters-from-other-plugins","title":"Driving Transmitters from Other Plugins","text":"<p>Transmitters can be driven by many areas of the Premiere Pro interface. Currently, they are called to show frames from the Program Monitor and Source Monitor. But other types of plugins can use the Transmit Invocation Suite to push frames to transmitters. For example, an effect or titler with a modal setup dialog could push frames to the output.</p>"},{"location":"transmitters/transmitter-basics/#entry-point","title":"Entry Point","text":"<p>This entry point function will be called once on load, and once on unload.</p> <pre><code>tmResult (*tmEntryFunc)(\n  csSDK_int32  inInterfaceVersion,\n  prBool       inLoadModule,\n  piSuitesPtr  piSuites,\n  tmModule*    outModule)\n</code></pre> <p>A tmModule is a structure of function pointers, which the transmitter implements.</p>"},{"location":"transmitters/transmitters/","title":"Transmitters","text":"<p>This API provides support for pushing video, audio, and closed captions to external hardware. Transmitters can be specified by the user in Preferences &gt; Playback. Other plugins such as importers and effects with settings preview dialogs can send video out to the active transmitter, opening up new possibilities for hardware monitoring. Transmit plugins are supported in Premiere Pro, After Effects (starting in CC 2014), and Character Animator.</p> <p>When a new transmitter instance is created, it is asked to describe the format(s) it wishes to receive the rendered video in. A transmitter plugin can request different formats depending on the source clip or timeline format. The host application will handle all the conversions to the desired video format. As an example, a transmitter instance may specify that it can only handle a fixed width and height, but any pixel format. Besides video conversions, the host handles scheduling for prefetching the media and asynchronous rendering.</p> <p>A transmitter may leave the audio to be played by the host, through the system's sound drivers (ASIO or CoreAudio). Or, if a transmitter wants to handle the audio itself to send it to the external hardware, it can request audio using GetNextAudioBuffer in the Playmod Audio Suite.</p> <p>On playback, the host provides the transmitter with a clock callback, which the transmitter must call to update the host with the new time every frame. This allows the transmitter to orchestrate the audio/video sync.</p> <p>Transmitters can use the Captioning Suite to get any closed captions for the sequence.</p> <p>Transmitters do not need to call the Playmod Device Controller suite to handle Export to Tape. This is handled at the player level.</p>"},{"location":"transmitters/transmitters/#whats-new-in-premiere-pro-240","title":"What's New in Premiere Pro 24.0?","text":"<p>Support for additional audio output devices has been added.</p>"},{"location":"transmitters/transmitters/#whats-new-in-premiere-pro-cs602","title":"What's New in Premiere Pro CS6.0.2?","text":"<p>A transmitter can now provide strings to label its audio channels, in <code>tmAudioMode.outOutputAudioNames</code>. These strings will be used for the Audio Output Mapping preferences, rather than the default strings.</p>"},{"location":"universals/audio/","title":"Audio","text":""},{"location":"universals/audio/#32-bit-float-uninterleaved-format","title":"32-bit Float, Uninterleaved Format","text":"<p>All audio calls to and from Premiere use arrays of buffers of 32-bit floats to pass audio. Audio is not interleaved, rather separate channels are stored in separate buffers. So the structure for stereo audio looks like this:</p> <pre><code>float* audio[2];\n</code></pre> <p>where <code>audio[0]</code> is the address of a buffer N samples long, and <code>audio[1]</code> is the address of a second buffer N samples long. <code>audio[0]</code> contains the left channel, and <code>audio[1]</code> contains the right channel. N is the number of sample frames in the buffer.</p> <p>Since Premiere uses 32-bit floats for each audio sample, it can represent values above 0 dB. 0 dB corresponds to +/- 1.0 in floating point. A floating point sample can be converted to a 16-bit short integer by multiplying by 32767.0 and casting the result to a short.</p> <p>E.g.:</p> <pre><code>sample16bit[n] = (short int) (sample32bit[n] * 32767.0)\n</code></pre> <p>The plugin is responsible for converting to and from the 32-bit uninterleaved format when reading a file that uses a different format. There are calls to convert between formats in the Audio Suite. For symmetry in the int &lt;-&gt; float conversions, we recommend you use the utility functions provided.</p>"},{"location":"universals/audio/#audio-sample-types","title":"Audio Sample Types","text":"<p>Since 32-bit floats are the only audio format ever passed, there is no option of sample type or bit depth. However, file formats do use a variety of sample types and bit depths, so <code>AudioSampleTypes</code> define a variety of possible formats.</p> <p>These formats are used to set members in structures passed to Premiere to define the user interface, and do not affect the format of the audio passed to and from Premiere.</p> PrAudioSampleType Description <code>kPrAudioSampleType_8BitInt</code> 8-bit integer <code>kPrAudioSampleType_8BitTwosInt</code> 8-bit integer, two's complement <code>kPrAudioSampleType_16BitInt</code> 16-bit integer <code>kPrAudioSampleType_24BitInt</code> 24-bit integer <code>kPrAudioSampleType_32BitInt</code> 32-bit integer <code>kPrAudioSampleType_32BitFloat</code> 32-bit floating point <code>kPrAudioSampleType_64BitFloat</code> 64-bit floating point <code>kPrAudioSampleType_16BitIntBigEndian</code> 16-bit integer, big endian <code>kPrAudioSampleType_24BitIntBigEndian</code> 24-bit integer, big endian <code>kPrAudioSampleType_32BitIntBigEndian</code> 32-bit integer, big endian <code>kPrAudioSampleType_32BitFloatBigEndian</code> 32-bit floating point, big endian <code>kPrAudioSampleType_Compressed</code> Any non-PCM format <code>kPrAudioSampleType_Packed</code> Any PCM format with mixed sample types <code>kPrAudioSampleType_Other</code> A sample type not in this list <code>kPrAudioSampleType_Any</code> Any available sample type (used by exporters)"},{"location":"universals/audio/#audio-sample-frames","title":"Audio Sample Frames","text":"<p>A sample frame is a unit of measurement for audio. One audio sample frame describes all channels of one sample of audio. Each sample is a 32-bit float. Thus, the storage requirement of an audio sample frame in bytes is equal to <code>4 * number of channels</code>.</p>"},{"location":"universals/audio/#audio-sample-rate","title":"Audio Sample Rate","text":"<p><code>PrAudioSample</code> is a <code>prInt64</code></p>"},{"location":"universals/audio/#audio-channel-types","title":"Audio Channel Types","text":"<p>Premiere currently supports four different audio channel types: mono, stereo, 5.1, and max channel.</p> <p>Greater than 5.1 channel support was originally added in Premiere Pro 4.0.1, with partial support for a 16 channel master audio track, only for importing OMFs and playing out to hardware.</p> <p>In CS6, 16-channel audio export was added.</p> <p>Starting in CC, the audio channel support is increased to 32 channels.</p> PrAudioChannelType Description <code>kPrAudioChannelType_Mono</code> Mono <code>kPrAudioChannelType_Stereo</code> Stereo. The order of the stereo channels is:<ul><li><code>kPrAudioChannelLabel_FrontLeft</code></li><li><code>kPrAudioChannelLabel_FrontRight</code></li></ul> <code>kPrAudioChannelType_51</code> 5.1 audio.The order of the 5.1 channels is:<ul><li><code>kPrAudioChannelLabel_FrontLeft</code></li><li><code>kPrAudioChannelLabel_FrontRight</code></li><li><code>kPrAudioChannelLabel_BackLeft</code></li><li><code>kPrAudioChannelLabel_BackRight</code></li><li><code>kPrAudioChannelLabel_FrontCenter</code></li><li><code>kPrAudioChannelLabel_LowFrequency</code></li><li><code>kPrAudioChannelLabel_BackLeft</code></li><li><code>kPrAudioChannelLabel_BackRight</code></li></ul> <code>kPrAudioChannelType_MaxChannel</code> New in CC.<code>kMaxAudioChannelCount</code>, defined as 32 channels as of CC.All channels use <code>kPrAudioChannelLabel_Discrete</code>."},{"location":"universals/basic-types-structures/","title":"Basic Types Structures","text":"<p>These types and structures are defined in PrSDKTypes.h and PrSDKStructs.h, and are used throughout the Premiere API.</p> <p>Premiere defines cross-platform types for convenience when developing plugins for both Windows and Mac OS.</p> Name Description <code>prColor</code> An unsigned 32-bit integer that stores an RGB color.This type is useful for the 8-bpc colors retrieved by the color picker in a video effect or transition.Color channels are stored as BGRA, in order of increasing memory address from left to right. <code>prWnd</code> A Windows <code>HWND</code> or Mac OS <code>NSView*</code> <code>prParentWnd</code> A Windows <code>HWND</code> or Mac OS <code>NSWindow*</code> <code>prOffscreen</code> A Windows <code>HDC</code> <code>prRect</code> A Windows <code>RECT</code> or Mac OS <code>Rect</code>.Use the utility function <code>prSetRect</code> to set the dimensions of a <code>prRect</code> struct.This should be used because Mac OS <code>Rect</code> members have a different ordering than Windows <code>RECT</code> members. <code>prFloatRect</code> <pre>typedef struct {  float left;  float top;  float right;  float bottom;} prFloatRect;</pre> <code>prRgn</code> A Windows <code>HRGN</code> <code>prPoint</code>, <code>LongPoint</code> <pre>typedef struct {  csSDK_int32 x;  csSDK_int32 y;} prPoint, LongPoint;</pre><code>LongPoint</code> is deprecated, but still used for a couple of Bottleneck callbacks prFPoint <pre>typedef struct {  double x;  double y;} prFPoint64;</pre> <code>prPixel</code> (Deprecated) <code>prPixelAspectRatio</code> (Deprecated) <code>PPix</code>, <code>*PPixPtr</code>, <code>**PPixHand</code> Holds a video frame or field, and contains related attributes such as pixel aspect ratio and pixel format.Manipulate PPixs using the PPix Suite, never directly. <code>TDB_TimeRecord</code> A time database record representing a time value in the context of a video frame rate.<pre>typedef struct {  TDB_Time       value;  TDB_TimeScale  scale;  TDB_SampSize   sampleSize;} TDB_TimeRecord;</pre> <code>prBool</code> Can be either <code>kPrTrue</code> or <code>kPrFalse</code> <code>PrMemoryPtr</code>, <code>*PrMemoryHandle</code> A <code>char*</code> <code>PrTimelineID</code>, <code>PrClipID</code> A 32-bit signed integer. <code>prUTF8Char</code> An 8-bit unsigned integer. <code>PrSDKString</code> An opaque data type that should be accessed using the new String Suite. <code>PrParam</code> Used for exporter parameters<pre>struct PrParam{  PrParamType mType;  union  {    csSDK_int8   mInt8;    csSDK_int16  mInt16;    csSDK_int32  mInt32;    csSDK_int64  mInt64;    float        mFloat32;    double       mFloat64;    csSDK_uint8  mBool;    prFPoint64   mPoint;    prPluginID   mGuid;    PrMemoryPtr  mMemoryPtr;  };};enum PrParamType{  kPrParamType_Int8 = 1,  kPrParamType_Int16,  kPrParamType_Int32,  kPrParamType_Int64,  kPrParamType_Float32,  kPrParamType_Float64,  kPrParamType_Bool,  kPrParamType_Point,  kPrParamType_Guid,  kPrParamType_PrMemoryPtr};</pre> <code>prDateStamp</code> Used in by importers in <code>imFileAttributesRec.creationDateStamp</code>.<pre>typedef struct{  csSDK_int32  day;  csSDK_int32  month;  csSDK_int32  year;  csSDK_int32  hours;  csSDK_int32  minutes;  double       seconds;} prDateStamp;</pre>"},{"location":"universals/fields/","title":"Fields","text":"<p>There are different constants defined for fields. These constants are now largely interchangable in CS4, since the conflicting constants for the old compiler API have been removed.</p> Exporters, Players, Video Segment Suite, etc Recorders <code>prFieldsNone</code> <code>kMALFieldsNone</code> <code>prFieldsUpperFirst</code> <code>kMALFieldsUpperFirst</code> <code>prFieldsLowerFirst</code> <code>kMALFieldsLowerFirst</code> <code>prFieldsUnknown</code> <code>kMALFieldsUnknown</code> <code>prFieldsAny</code> <code>kMALFieldsInvalid</code> <code>prFieldsInvalid</code>"},{"location":"universals/legacy-callback-suites/","title":"Legacy Callback Suites","text":""},{"location":"universals/legacy-callback-suites/#pisuites","title":"piSuites","text":"<p>These callbacks are available to all plugins, although many of these callbacks are only appropriate for specific plugin types.</p> <pre><code>typedef struct {\n  int                   piInterfaceVer;\n  PlugMemoryFuncsPtr    memFuncs;\n  PlugWindowFuncsPtr    windFuncs;\n  PlugppixFuncsPtr      ppixFuncs;\n  PlugUtilFuncsPtr      utilFuncs;\n  PlugTimelineFuncsPtr  timelineFuncs;\n} piSuites, *piSuitesPtr;\n</code></pre> Member Description <code>piInterfaceVer</code> API version<ul><li>Premiere Pro CS4 - <code>PR_PISUITES_VERSION_9</code></li><li>Premiere Pro CS3 - <code>PR_PISUITES_VERSION_8</code></li><li>Premiere Pro 2.0 - <code>PR_PISUITES_VERSION_7</code></li><li>Premiere Pro 1.5.1 - <code>PR_PISUITES_VERSION_6</code></li><li>Premiere Pro 1.5 - <code>PR_PISUITES_VERSION_5</code></li><li>Premiere Pro 1.0 - <code>PR_PISUITES_VERSION_4</code></li><li>Premiere 6.x - <code>PR_PISUITES_VERSION_3</code></li><li>Premiere 5.1 - <code>PR_PISUITES_VERSION_2</code></li><li>Premiere 5.0 - <code>PR_PISUITES_VERSION_1</code></li></ul> memfuncs Pointer to memory functions windFuncs Pointer window functions ppixFuncs Pointer PPix functions utilFuncs Pointer to utility functions.In the utilFuncs, the getSPBasicSuite callback provides access to the SweetPea Suites, which are used for most of the newer functions. timelineFuncs Pointer to timeline functions"},{"location":"universals/legacy-callback-suites/#memory-functions","title":"Memory Functions","text":"<p>Memory and handle allocation. Where possible, use the PPix Creator Suite for PPix-specific allocation.</p> <p>Strings passed to and from Premiere in API structures are always null-terminated C strings.</p> Function Description <code>newPtr</code> Allocates a block of memory, returns a pointer to the new block.<pre>char* newPtr (csSDK_uint32 size);</pre> <code>newPtrClear</code> Equivalent to newPtr, but initializes the memory to 0.<pre>char* newPtrClear (csSDK_uint32 size);</pre> <code>setPtrSize</code> Resizes an allocated memory block.<pre>void setPtrSize (  PrMemoryPtr   *ptr,  csSDK_uint32  newsize);</pre> <code>getPtrSize</code> Returns size in bytes of an allocated memory block.<pre>csSDK_int32 getPtrSize (char *ptr);</pre> <code>disposePtr</code> Frees an allocated memory block.<pre>void disposePtr (char *ptr);</pre> <code>newHandle</code> Allocates a block of memory, returning a handle to it.<pre>char** newHandle (csSDK_uint32 size);</pre> <code>newHandleClear</code> Equivalent to newHandle, but initializes the memory to 0.<pre>char** newHandleClear (csSDK_uint32 size);</pre> <code>setHandleSize</code> Resizes an allocated memory handle.<pre>csSDK_int16 setHandleSize (  char          **PrMemoryHandle,  csSDK_uint32  newsize);</pre> <code>getHandleSize</code> Returns the size (in bytes) of an allocated block.<pre>csSDK_int32 getHandleSize ( char **PrMemoryHandle);</pre> <code>disposeHandle</code> Disposes of a previously allocated handle.<pre>void disposeHandle (char **PrMemoryHandle);</pre> <code>lockHandle</code> <code>unlockHandle</code> These legacy functions are deprecated and should no longer be used."},{"location":"universals/legacy-callback-suites/#window-functions","title":"Window Functions","text":"<p>Window management routines. Superceded by the Window Suite.</p> Function Description <code>updateAllWindows</code> Updates all windows. Windows only, doesn't work on Mac OS.<pre>void updateAllWindows (void);</pre> <code>getMainWnd</code> Returns the main application HWND.<pre>void getMainWnd (void);</pre>"},{"location":"universals/legacy-callback-suites/#ppix-functions","title":"PPix Functions","text":"<p>Used to manipulate a PPix. Superceded by the PPix Creator Suite for PPix allocation and the PPix Suite for general PPix functions.</p> Function Description <code>ppixGetPixels</code> Returns a pointer to the array of pixels contained in a PPix.<pre>char* ppixGetPixels (PPixHand pix);</pre> <code>ppixGetBounds</code> Returns the bounds of a PPix.<pre>void ppixGetBounds (  PPixHand  pix;  prRect    *bounds);</pre> <code>ppixGetRowbytes</code> Returns the rowbytes of a PPix so you can properly parse the pixels returned by ppixGetPixels.<pre>int ppixGetRowbytes (PPixHand pix);</pre> <code>ppixNew</code> Allocates and returns a handle to a new PPix, with specified bounds.Since this is an older call, the pixel format is hardcoded to BGRA_4444_8u.<pre>PPixHandle ppixNew (prRect *bounds);</pre> <code>ppixDispose</code> Frees a PPixHand.<pre>void ppixDispose (PPixHand pix);</pre> <code>ppixLockPixels</code> <code>ppixUnlockPixels</code> These legacy functions are deprecated and should no longer be used. <code>ppixGetPixelAspectRatio</code> Passes back the pixel aspect ratio of a PPixHand.Premiere populates the longs with the PAR numerator and denominator.<pre>int ppixGetPixelAspectRatio (  PPixHand      pix,  csSDK_uint32  num,  csSDK_uint32  den)</pre> <code>ppixGetAlphaBounds</code> Passes back the alpha bounds of a PPixHand.<pre>void ppixGetAlphaBounds (  PPixHand  pix,  prRect    *alphaBounds)</pre>"},{"location":"universals/legacy-callback-suites/#utility-functions","title":"Utility Functions","text":"Function Description <code>getSerialNumber</code> Passes back Premiere's serial number.<pre>void getSerialNumber (char* buffer);</pre><ul><li><code>buffer</code>: must be at least 40 characters long.</li></ul> <code>getFileTimebase</code> Passes back a file's timebase in a <code>TDB_TimeRecord</code> (allocated by the plugin).If the file is already in the sequence, it is preferable to get a file's timebase using the Video Segment Suiteto get the <code>kVideoSegmentProperty_Media_StreamFrameRate</code>.Note: Know your formats. Don't ask an audio only format for video, you may get unexpected results.<pre>csSDK_int32 getFileTimebase (  prFileSpec      filespec,  csSDK_int32     audioOnly,  TDB_TimeRecord  result);</pre><ul><li><code>filespec</code>: description of the file, use before getFileVideo</li><li><code>audioOnly</code>: if non-zero, return the audio timebase. If zero, return the video timebase.</li><li><code>result</code>: the returned timebase</li></ul> <code>getFileVideo</code> Gets a frame of video (at a specified time) from a file.If the file is already in the sequence, it is preferable to get a file's video using the Clip Render Suite.<pre>csSDK_int32 getFileVideo (  prFileSpec   filespec,  csSDK_int32  frame,  PPixHand     thePort,  prRect       bounds,  csSDK_int32  flags);</pre><li><code>filespec</code>: the description of the file</li><li><code>frame</code>: the frame to retrieve</li><li><code>thePort</code>: where the frame will be delivered, allocate prior to calling</li><li><code>bounds</code>: the boundary of the port</li><li><code>flags</code>: unused</li> <code>getFileVideoBounds</code> Passes back the bounds of a file.If the file is already in the sequence, it is preferable to get a file's video bounds using the Clip Render Suite.<pre>csSDK_int32 getFileVideoBounds (  prFileSpec filespec,  prRect bounds);</pre> <code>getSPBasicSuite</code> This very important call returns the SweetPea suite that allows plugins to acquire and release all other SweetPea Suites.<pre>SPBasicSuite* getSPBasicSuite();</pre> <code>getFileExtString</code> Passes back the list of valid entensions/filter strings given a class of media (see file types constants below).<pre>csSDK_int32 (plugGetFileExtStringFunc)(  csSDK_uint32  fileTypes,  char          inBuffer,  csSDK_uint32  inBufferSize);</pre><ul><li><code>kFileTypes_Still</code>: still media</li><li><code>kFileTypes_AudioOnly</code>: audio-only media</li><li><code>kFileTypes_AudioVideo</code>: audio and video media</li><li><code>kFileTypes_AllNoIntrinsics</code>: all importable media types via importer plugins (no prproj, txt, etc)</li></ul>"},{"location":"universals/legacy-callback-suites/#timeline-functions","title":"Timeline Functions","text":"Function Description <code>getClipVideo</code> Superceded by the Clip Render Suite, which provides asynchronous import.Retrieves a frame from a clip in a segment tree returned from the Video Segment Suite.It can be used by to retrieve and store a still frame, such as a title, for playback.This call is expensive; use it carefully.<pre>csSDK_int32 getClipVideo (  csSDK_int32  frame,  PPixHand     thePort,  prRect       *bounds,  csSDK_int32  flags,  PrClipID     clipData);</pre><ul><li><code>frame</code>: the frame number you're requesting</li><li><code>thePort</code>: allocate using the PPix Creator Suite before calling</li><li><code>bounds</code>: the boundaries of video to return</li><li><code>flags</code>: either <code>kGCVFlag_UseFilePixelAspectRatio</code> or 0. Setting it to <code>kGCVFlag_UseFilePixelAspectRatio</code> will return a PPix stamped with the PAR of the file. Setting it to 0 will return a PPix adjusted to the PAR of the project and stamped accordingly. It scales, but does not stretch the PPix to fit the destination PPix that is passed in. So if the destination PPix is larger than the frame asked for, the frame will maintain its frame aspect ratio, letterboxing or pillarboxing the frame with transparent black. To import a frame at its native dimensions, use getClipVideoBounds, allocate the destination PPix using the dimensions returned, and pass the PPixHand and the dimensions into <code>getClipVideo</code>. If the frame size is not the same as the sequence size, the frame must be positioned in the composite by the plugin.</li><li><code>clipData</code>: the clipData handle found in prtFileRec</li></ul> <code>getWorkArea</code> Passes back two longs with the start and end of the current work area (read-only).Set timelineData to the timelineData of the current sequence.<pre>csSDK_int32 getWorkArea (  PrTimelineID  timelineData,  csSDK_int32   workAreaStart,  csSDK_int32   workAreaEnd);</pre> <code>getCurrentTimebase</code> Passes back the current timebase of the timeline (<code>scale + sampleSize</code>).<pre>void getCurrentTimebase(  PrTimelineID  timelineData,  csSDK_uint32  scale,  csSDK_int32   sampleSize);</pre><ul><li><code>timelineData</code>: the timelineData of the current sequence</li><li><code>scale</code>: the sequence scale</li><li><code>sampleSize</code>: the sequence sampleSize</li></ul> <code>getCurrentPos</code> Returns the position of the current time indicator (the position bar set by the user).If (-1) is returned, the position bar in the timeline is not present.<pre>csSDK_int32 getCurrentPos(  PrTimelineID  timelineData);</pre><ul><li><code>timelineData</code>: the timelineData of the current sequence</li></ul> <code>getPreviewFrameEx</code> Gets a fully rendered frame from the timeline (all layers).Used by video filters and transitions for previews in a modal setup dialog.If the return value is -1, an error occurred, but if it is 0, the callback has returned safely.Exporters rendering final movies should NOT use this callback.<pre>csSDK_int32 getPreviewFrameEx(  PrTimelineID    timelineData,  csSDK_int32     inFrame,  PPixHand       outRenderedFrame,  const prRect   inFrameRect,  PrPixelFormat*  inRequestedPixelFormatArray,  csSDK_int32     inRequestedPixelFormatArrayCount,  csSDK_uint32    inPixelAspectRatioNumerator,  csSDK_uint32    inPixelAspectRatioDenominator,  bool            inAlwaysRender);</pre><ul><li><code>timelineData</code>: The timelineData of the current sequence. Pass a timeline handle as provided in EffectRecord, VideoRecord, compDoCompileInfo, or imGetPrefsRec.</li><li><code>inFrame</code>: The frame to get, specified in the current timebase. If a timelineData handle is specified (first param above), this frame will be relative to the start of the sequence.</li><li><code>outRenderedFrame</code>: The destination buffer. Allocate prior to this call by the plugin using the PPix Suite. Released by the caller before returning.</li></ul> <code>getClipVideoBounds</code> Passes back the dimensions of a clip in a sequence. For rolling/ crawling titles, use the Roll/Crawl Suite to get the dimensions instead.<pre>csSDK_int32 getClipVideoBounds (  PrClipID      inClipData,  prRect        outBounds,  csSDK_uint32  outPixelAspectRatioNumerator,  csSDK_uint32  *outPixelAspectRatioDenominator);</pre> <code>getClipVideoEx</code> Superceded by the Clip Render Suite, which provides asynchronous import.Retrieves a frame from a clip in a segment tree returned from the Video Segment Suite.It can be used by to retrieve and store a still frame, such as a title, for playback.This call is expensive; use it carefully.<pre>csSDK_int32 getClipVideoEx (  csSDK_int32          inFrame,  PPixHand             outRenderedFrame,  const prRect         inFrameRect,  const PrPixelFormat  *inRequestedPixelFormatArray,  csSDK_int32          inRequestedPixelFormatArrayCount,  csSDK_uint32         inPixelAspectRatioNumerator,  csSDK_uint32         inPixelAspectRatioDenominator,  PrClipID             inClipData);</pre><ul><li><code>inFrame</code>: the frame number you're requesting, in the timebase of the clip</li><li><code>outRenderedFrame</code>: Allocated by the host. The plugin should dispose of the PPixHand when done</li><li><code>inFrameRect</code>: the boundaries of video to return. To import a frame at its native dimensions, use getClipVideoBounds. If the frame size is not the same as the sequence size, the frame must be positioned in the composite by the plugin.</li><li><code>inClipData</code>: the PrClipID from the video segment</li></ul>"},{"location":"universals/legacy-callback-suites/#bottleneck-functions","title":"Bottleneck Functions","text":"<p>The pointer to the legacy bottleneck functions is passed only to transitions and video filters.</p> <p>These functions are not exposed for other plugin types.</p> <p>These functions are not aware of different pixel formats, and are intended only for 8-bit BGRA processing.</p> <p>Sample usage:</p> <pre><code>((*theData)-&gt;bottleNecks-&gt;StretchBits) (*srcpix,\n                                        *dstpix,\n                                        &amp;srcbox,\n                                        &amp;srcbox,\n                                        0,\n                                        NULL);\n</code></pre> Function Description <code>StretchBits</code> Stretches and copies an image, including the alpha channel.When the destination is larger than the source, it performs bilinear interpolation for smooth scaling.<pre>void StretchBits (  PPixHand  srcPix,  PPixHand  dstPix,  prRect    srcRect,  prRect    dstRect,  int       mode,  prRgn     rgn);</pre>StretchBits only works on 8-bit PPixs.srcRect is the area of the source PPix to copy; dstRect is used to scale the copy.Valid modes are <code>cbBlend</code>, <code>cbInterp</code>, and <code>cbMaskHdl</code>For <code>cbBlend</code>, the low byte of the mode defines the amount of blend between the source and destination in a range of 0-255.Example:To blend 30% of the source with the destination, use <code>cbBlend | (30*255/100)</code>While much slower than <code>cbBlend</code>, cbInterp mode does bilinear interpolation when resizing a source PPix to a larger destination, resulting in a much smoother image.cbMaskHdl tells StretchBits that prRgn is a handle to a 1-bit deep buffer the same size as the source and destination PPixs, to be used as a mask.Pass 0 for no clipping. The prRgn parameter is only used on Windows. <code>DistortPolygon</code> Maps the source rectangle to a four-point polygon in the destination.<pre>void DistortPolygon (  PPixHand  src,  PPixHand  dest,  prRect    srcbox,  prPoint   dstpts);</pre>When scaling up, <code>DistortPolygon</code> uses bilinear interpolation; it uses pixel averaging when scaling down. <code>MapPolygon</code> Maps a four-point src polygon into a four-point polygon (dstpts).If the source polygon is a rectangle, it is equivalent to <code>DistortPolygon</code>.<pre>void MapPolygon (  PPixHand  src,  PPixHand  dest,  prPoint   srcpts,  prPoint   dstpts );</pre> <code>DistortFixed</code> Equivalent to DistortPolygon, using fixed-point coordinates.<pre>void DistortFixed (  PPixHand   src,  PPixHand   dest,  prRect     srcbox,  LongPoint  dstpts);</pre> <code>FixedToFixed</code> Equivalent to MapPolygon, using fixed-point coordinates.<pre>void FixedToFixed (  PPixHand   src,  PPixHand   dest,  LongPoint  srcpts,  LongPoint  dstpts);</pre> <code>DoIndexMap</code> Image map function.<pre>void DoIndexMap (  char    src,  char    dst,  short   row,  short,  pixwidth,  short,  height,  char    lookup1,  char    lookup2,  char    *lookup3);</pre> <code>DoConvolve</code> Convolution function.<pre>void DoConvolve (  unsigned char  src,  unsigned char  dst,  short          *inmatrix,  short,         rowBytes,  short,         width,  short,         height);</pre>"},{"location":"universals/memory-management/","title":"Memory Management","text":"<p>Premiere Pro has a media cache in which it stores imported frames, intermediate frames (intermediate stages of a render), fully rendered frames, and audio.</p> <p>This is sized based on a specific percentage of physical memory, taking into account if multiple Adobe applications are also running.</p> <p>Premiere Pro manages this cache itself, so as it adds new items to the cache, it flushes least recently used items.</p>"},{"location":"universals/memory-management/#what-really-is-a-memory-problem","title":"What Really is a Memory Problem?","text":"<p>Often, users monitoring memory usage are alarmed when they see memory growing to a specific point during a render or playback. When the memory doesn't drop right back down after a render or playback, they might think they have found a memory leak. However, keeping in mind the function of the Premiere Pro media cache, this behavior is to be expected.</p> <p>On the other hand, memory contention between plugins and the rest of Premiere Pro can lead to memory problems. If a plugin allocates a significant amount of memory and the Premiere Pro media cache has not accounted for it, this means there is less free memory available after the media cache grows to the predefined size. Even if Premiere Pro does not completely run out of memory, limited memory can cause memory thrashing as memory is moved around to make room for video frames, which in turn can cause poor performance.</p>"},{"location":"universals/memory-management/#solutions-for-memory-contention","title":"Solutions for Memory Contention","text":"<p>The best approach to reduce memory contention is to reduce the memory requirements of each plugin. However, if the memory requirements of a plugin are significant, it should also use the Memory Manager Suite to report any memory usage that would not already be accounted for.</p> <p>Frames allocated using the PPix Creator Suite are accounted for, but any memory allocated using the old PPix and Memory functions are not automatically accounted for.</p>"},{"location":"universals/pixel-aspect-ratio/","title":"Pixel Aspect Ratio","text":"<p>Pixel Aspect Ratio (PAR) is usually represented as a rational number, with a numerator and a denominator.</p> <p>Note</p> <p>Several PAR values were changed in CS4 to match broadcast standards.</p> <p>Here are some examples of pixel aspect ratios:</p> <ul> <li>NTSC DV 0.9091 PAR is (10, 11)</li> <li>NTSC DV Widescreen 1.2121 PAR is (40, 33)</li> <li>PAL DV 1.0940 PAR is (768, 702)</li> <li>PAL DV 1.4587 PAR is (1024, 702)</li> <li>Square 1.0 PAR is (1,1)</li> </ul> <p>In certain legacy structures, PAR is represented as a single 32-bit integer, such as in <code>recCapInfoRec.pixelAspectRatio</code>.</p> <p>This uses a representation where the numerator is bit-shifted 16 to the left, and OR'd with the denominator. For example NTSC DV 0.9091 PAR is <code>(10 &lt;&lt; 16) \\| 11</code>.</p>"},{"location":"universals/pixel-formats-and-color-spaces/","title":"Pixel Formats And Color Spaces","text":"<p>As of CC, Premiere supports 69 different pixel formats, not including raw and custom formats.</p> <p>Why so many? Each pixel format has it's unique advantages and disadvantages. 8-bit formats are compact, but lack quality. 32-bit ones are more accurate, but overkill in some situations.</p> <p>Compressed formats are great for storing raw frames, but bad for effects processing. And so on\u2026 In summary, choose wisely!</p>"},{"location":"universals/pixel-formats-and-color-spaces/#what-format-should-i-use","title":"What Format Should I Use?","text":"<p>Starting in CS4, plugins no longer need to support 8-bit BGRA at a minimum. If required, Premiere can make intermediate format conversions in the render pipeline, although these intermediate conversions will be avoided if possible.</p> <p>Previously in CS3 and earlier, all plugins except importers needed to support 8-bit per channel BGRA, even if they supported other formats.</p> <p>When choosing which pixel formats to support, there are different factors to consider, depending on the plugin type.</p>"},{"location":"universals/pixel-formats-and-color-spaces/#importers","title":"Importers","text":"<p>Importers typically should provide frames in a format closest to the source format.</p> <p>If needed, Premiere can convert any compressed format to a 8-bit or 32-bit uncompressed format. Keeping the format compressed as long as possible as it passes through the render pipeline will save memory and bandwidth.</p> <p>Starting in Premiere Pro CC 2014, importers can now choose the format they are rendering in. This allows importers to change pixel formats and quality based on criteria like enabled hardware and other source settings, such as HDR. To handle the negotiation, implement imSelectClipFrameDescriptor.</p>"},{"location":"universals/pixel-formats-and-color-spaces/#effects","title":"Effects","text":"<p>Effects should support the uncompressed format(s) that works best with the effect's pixel processing algorithm.</p> <p>If the algorithm is based on RGB pixel calculations, provide a fast render path using 8-bit BGRA, and optionally a high-quality render path using 32-bit BGRA. If the algorithm is Y'UV-based, use the VUYA pixel formats.</p>"},{"location":"universals/pixel-formats-and-color-spaces/#exporters-and-transmitters","title":"Exporters and Transmitters","text":"<p>Exporters and transmitters should request frames in a format closest to the output format. New in CS5, PrPixelFormat_Any can be used in exporter render requests.</p> <p>Any render function that takes a list of pixel formats can now be called with just two formats - the desired 4:4:4:4 pixel format, and PrPixelFormat_Any. This allows the host to avoid frame conversions and decompressions in many very common cases. The best part is that the plugin doesn't need to</p> <p>understand all the possible pixel formats to make use of this. It can use the Image Processing Suite to copy/convert from any a PPix of any format to a separate memory buffer, which is a copy that would likely need to be done anyway.</p> <p>After the request is made, Premiere analyzes the preferred format of all importers and effects that are used to produce a single rendered frame, as well as the list of requested formats, and chooses the best format to use on a per-segment basis.</p> <p>If the requestor supports more than one format, and the importers and effects used for various clips in the sequence support different formats, the render may use different formats for each segment.</p> <p>Premiere Pro's built-in Rec. 601 to 709 color space conversion can be slow. So if the majority of the sources and effects use the Rec 601 color space, and if the exporter or transmitter can handle the 601 to 709 conversion quickly on its own, it may be faster to do the color space conversion in the exporter or transmitter.</p>"},{"location":"universals/pixel-formats-and-color-spaces/#other-considerations","title":"Other Considerations","text":"<p>For high-bit depth support, the 32f formats are the recommended route, rather than the 16u formats. For example, an exporter that supports 10-bit Y'UV should ask for frames in 32f Y'UV format, and then convert the 32f to 10u.</p> <p>The ARGB formats can be natively used in the After Effects render pipeline, and are used by After Effects effect plugins that do not specifically support any other pixel format. However, in Premiere Pro, these ARGB formats will require byte-swapping, and shouldn't be used.</p>"},{"location":"universals/pixel-formats-and-color-spaces/#byte-order","title":"Byte Order","text":"<p>BGRA, ARGB, and VUYA are written in order of increasing memory address from left to right. Uncompressed formats have a lower-left origin, meaning the first pixel in the buffer describes the pixel in the lower-left corner of the image. Compressed formats have format-specific origins. Use calls in the Image Processing Suite to get details on any format.</p> <p>8-bit and 16-bit BGRA formats do not contain super whites or super blacks.</p> <p>The 16-bit formats use channels that go from black at 0 to white at 32768, like After Effects and Photoshop 16-bit formats.</p>"},{"location":"universals/pixel-formats-and-color-spaces/#unpacked-uncompressed","title":"Unpacked, Uncompressed","text":"PrPixelFormat Bits / Channel Format / FourCC Additional Details BGRA_4444_8u 8 RGB VUYA_4444_8u 8 Y'UV VUYA_4444_8u_709 8 Y'UV Rec. 709 color space. New in Premiere Pro 4.1. BGRA_4444_16u 16 RGB BGRA_4444_32f 32 RGB VUYA_4444_32f 32 Y'UV VUYA_4444_32f_709 32 Y'UV Rec. 709 color space. New in Premiere Pro 4.1."},{"location":"universals/pixel-formats-and-color-spaces/#unpacked-uncompressed-native-after-effects-support-only","title":"Unpacked, Uncompressed, native After Effects support only","text":"PrPixelFormat Bits / Channel Format / FourCC Additional Details ARGB_4444_8u 8 RGB For native After Effects support. For native Premiere Pro support, use BGRA. ARGB_4444_16u 16 RGB ARGB_4444_32f 32 RGB"},{"location":"universals/pixel-formats-and-color-spaces/#unpacked-uncompressed-with-implicit-alpha","title":"Unpacked, Uncompressed, with implicit alpha","text":"PrPixelFormat Bits / Channel Format / FourCC Additional Details BGRX_4444_8u 8 RGB Implicitly opaque alpha channel. The actual data may be left filled with garbage, which allows optimized processing by both the plugin and host, with the understanding the the alpha channel is opaque. New in Premiere Pro CS5. VUYX_4444_8u 8 Y'UV VUYX_4444_8u_709 8 Y'UV XRGB_4444_8u 8 RGB BGRX_4444_16u 16 RGB XRGB_4444_16u 16 RGB BGRX_4444_32f 32 RGB VUYX_4444_32f 32 Y'UV VUYX_4444_32f_709 32 Y'UV XRGB_4444_32f 32 RGB BGRP_4444_8u 8 RGB Premultiplied alpha. New in Premiere Pro CS5. VUYP_4444_8u 8 Y'UV VUYP_4444_8u_709 8 Y'UV PRGB_4444_8u 8 RGB BGRP_4444_16u 16 RGB PRGB_4444_16u 16 RGB BGRP_4444_32f 32 RGB VUYP_4444_32f 32 Y'UV VUYP_4444_32f_709 32 Y'UV PRGB_4444_32f 32 RGB"},{"location":"universals/pixel-formats-and-color-spaces/#linear-rgb","title":"Linear RGB","text":"PrPixelFormat Bits / Channel Format / FourCC Additional Details BGRA_4444_32f_Linear 32 RGB These RGB formats have a gamma of 1, rather than the standard 2.2. New in Premiere Pro CS5. BGRP_4444_32f_Linear 32 RGB BGRX_4444_32f_Linear 32 RGB ARGB_4444_32f_Linear 32 RGB PRGB_4444_32f_Linear 32 RGB XRGB_4444_32f_Linear 32 RGB"},{"location":"universals/pixel-formats-and-color-spaces/#packed-uncompressed-formats","title":"Packed, Uncompressed formats","text":"PrPixelFormat Bits / Channel Format / FourCC Additional Details RGB_444_10u New in Premiere Pro CC. Full range 10-bit 444 RGB little-endian YUYV_422_8u_601 8 'YUY2' New in Premiere Pro CS4. YUYV_422_8u_709 8 'YUY2' Rec. 709 color space. New in Premiere Pro CS4. UYVY_422_8u_601 8 'UYVY' New in Premiere Pro CS4. UYVY_422_8u_709 8 'UYVY' Rec. 709 color space. New in Premiere Pro CS4. V210_422_10u_601 10 'v210' New in Premiere Pro CS4. V210_422_10u_709 10 'v210' Rec. 709 color space. New in Premiere Pro CS4. UYVY_422_32f_601 32 'UYVY' New in Premiere Pro CC. UYVY_422_32f_709 32 'UYVY' New in Premiere Pro CC."},{"location":"universals/pixel-formats-and-color-spaces/#compressed-yuv","title":"Compressed Y'UV","text":"PrPixelFormat Bits / Channel Format / FourCC Additional Details NTSCDV25 8 DV25 / 'dvsd' PALDV25 8 DV25 / 'dvsd' NTSCDV50 8 DV50 / 'dv50' PALDV50 8 DV50 / 'dv50' NTSCDV100_720p 8 DV100 720p / 'dvh1' PALDV100_720p 8 DV100 720p / 'dvh1' NTSCDV100_1080i 8 DV100 1080i / 'dvh1' PALDV100_1080i 8 DV100 1080i / 'dvh1' YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_601 8 Y'UV 4:2:0 / 'YV12' Progressive Rec. 601 color space YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_601 8 Y'UV 4:2:0 / 'YV12' Interlaced Rec. 601 color space YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_601_FullRange 8 Y'UV 4:2:0 / 'YV12' New in Premiere Pro CS5.5. Progressive Rec. 601 color space, full range Y'UV YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_601_FullRange 8 Y'UV 4:2:0 / 'YV12' New in Premiere Pro CS5.5. Interlaced Rec. 601 color space, full range Y'UV YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_709 8 Y'UV 4:2:0 / 'YV12' Progressive Rec. 709 color space YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_709 8 Y'UV 4:2:0 / 'YV12' Interlaced Rec. 709 color space YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_709_FullRange 8 Y'UV 4:2:0 / 'YV12' New in Premiere Pro CS6. Progressive Rec. 709 color space, full range Y'UV. Matricies scaled from 709 by each component's excursion (Y is scaled by 219/255 and UV scaled by 224/256) YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_709_FullRange 8 Y'UV 4:2:0 / 'YV12' New in Premiere Pro CS6. Interlaced Rec. 709 color space, full range Y'UV YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_601 8 Y'UV 4:2:0 / 'YV12' New in Premiere Pro CS6. Progressive Rec. 601 color space YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_601 8 Y'UV 4:2:0 / 'YV12' New in Premiere Pro CS6. Interlaced Rec. 601 color space YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_601_FullRange 8 Y'UV 4:2:0 / 'YV12' New in Premiere Pro CS6. Progressive Rec. 601 color space, full range Y'UV YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_601_FullRange 8 Y'UV 4:2:0 / 'YV12' New in Premiere Pro CS6. Interlaced Rec. 601 color space, full range Y'UV YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_709 8 Y'UV 4:2:0 / 'YV12' New in Premiere Pro CS6. Progressive Rec. 709 color space YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_709 8 Y'UV 4:2:0 / 'YV12' New in Premiere Pro CS6. Interlaced Rec. 709 color space YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_709_FullRange 8 Y'UV 4:2:0 / 'YV12' New in Premiere Pro CS6. Progressive Rec. 709 color space, full range Y'UV. Matricies scaled from 709 by each component's excursion (Y is scaled by 219/255 and UV scaled by 224/256) PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_709_FullRange 8 Y'UV 4:2:0 / 'YV12' New in Premiere Pro CS6. Interlaced Rec. 709 color space, full range Y'UV"},{"location":"universals/pixel-formats-and-color-spaces/#miscellaneous","title":"Miscellaneous","text":"PrPixelFormat Bits / Channel Format / FourCC Additional Details Raw ? ? Raw, opaque data, with no rowbytes or height"},{"location":"universals/pixel-formats-and-color-spaces/#custom-pixel-formats","title":"Custom Pixel Formats","text":"<p>New in CS4, custom pixel formats are supported. Plugins can define a pixel format which can pass through various aspects of our pipeline, but remain completely opaque to the built-in renderers. Use the macro MAKE_THIRD_PARTY_CUSTOM_PIXEL_FORMAT_FOURCC in the Pixel Format Suite. Please use a unique name to avoid collisions.</p> <p>The format doesn't need to be registered in any sense. They can just be used in the same way the current pixel formats are used, though in many cases they will be ignored.</p> <p>The first place the new pixel formats can appear in the render pipeline is at the importer level. Importers can advertise the availability of these pixel formats during imGetIndPixelFormat, just as they would for any other format.</p> <p>Note</p> <p>Importers must also support a non-custom pixel format, for the case where the built-in renderer is used, which would not be prepared to handle an opaque pixel format added by a third-party.</p> <p>In the importer, use the new CreateCustomPPix call in the PPix Creator 2 Suite, and specify a custom pixel format and a memory buffer size, and the call will pass back a PPix of the requested format. These PPixes can then be returned from an importer, like any other. The memory for the PPix will be allocated by MediaCore, and must be a flat data structure as they will need to be copied between processes.</p> <p>However, because the data itself is completely opaque, it can easily be a reference to another pixel buffer, as long as the reference can be copied. For example, the buffer could be a constant 16 bytes, containing a GUID which can be used to access a memory buffer by name in another process.</p> <p>To query for available custom pixel formats from the player, use the GetNumCustomPixelFormats and GetCustomPixelFormat calls in the Clip Render Suite. The custom pixel formats will not returned by the regular calls to get the supported frame formats, mostly to prevent them from being used.</p> <p>The other Clip Render Suite functions will accept requests for custom pixel formats and will return these custom PPixes like any others.</p> <p>With the Clip Render Suite, a third-party player can directly access these custom PPixes from a matched importer.</p>"},{"location":"universals/pixel-formats-and-color-spaces/#smart-rendering","title":"Smart Rendering","text":"<p>Smart rendering involves passing compressed frames from the importer to the exporter, to bypass any unnecessary decompression and recompression, which reduces quality and performance.</p> <p>The way to implement this is by passing custom PPixes between an importer, exporter, and usually a renderer.</p> <p>In the rare case of exporting a single clip, using the Clip Render Suite in the exporter to request custom PPixes from the importer is sufficient. But in the more common case of exporting a sequence, a renderer that supports the custom pixel format is required.</p> <p>When an exporter running in Media Encoder parses the segments in the sequence, it only has a very high-level view. It sees the entire sequence as a single clip (which is actually a temporary project file that has been opened using a Dynamic Link to the PProHeadless process), and it sees any optional cropping or filters as applied effects.</p> <p>So when the exporter parses that simple, high-level sequence, if there are no effects, it should use the MediaNode's ClipID with the Clip Render Suite to get frames directly from the PProHeadless process. In the PProHeadless process, the renderer can step in and parse the real sequence in all its glory.</p> <p>It can use the Clip Render Suite to get the frames in the custom pixel format directly from the importer, and then set the custom PPix as the render result. This custom PPix then is available to the exporter, in a pristine, compressed PPix.</p>"},{"location":"universals/suites/","title":"Suites","text":"<p>There are different sets of function suites available to Premiere plugins. SweetPea Suites are the more modern suites that have been added for most new functionality. The piSuites are still needed for various functionality that has not all been superceded by SweetPea Suites.</p> <p>Whenever possible, use SweetPea Suites.</p> <p>There are also function suites more specific to certain plugin types. The Bottleneck Functions are useful for transitions and video filters. Other suites available to only one plugin type are documented in the appropriate chapter for that plugin type.</p>"},{"location":"universals/sweetpea-suites/","title":"SweetPea Suites","text":""},{"location":"universals/sweetpea-suites/#overview","title":"Overview","text":"<p>Suites common to more than one plugin type are documented in this chapter below.</p> <p>Suites that are only used by one plugin type are documented in the chapter on that plugin type.</p> <p>Below is a table of all suites available in Premiere Pro:</p> Suite Name Relevant to Plug-in Type Accelerated Render Invocation Suite Exporters App Info Suite All Application Settings Suite All Async File Reader Suite Importers Async Operation Suite All Audio Suite Importers, Exporters Captioning Suite Device Controllers, Exporters, Transmitters Clip Render Suite Exporters Deferred Processing Suite Importers Error Suite All except Exporters starting in CS6 Export File Suite Exporters Export Info Suite Exporters Export Param Suite Exporters Export Progress Suite Exporters Export Standard Param Suite Exporters Exporter Utility Suite Exporters File Registration Suite Importers, Transitions, Video Filters Flash Cue Marker Data Suite Exporters GPU Device Suite GPU Effects and Transitions Image Processing Suite All Importer File Manager Suite Importers Legacy Callback Suites All Marker Suite Exporters Media Accelerator Suite Importers Memory Manager Suite All Palette Suite Exporters Pixel Format Suite All Playmod Audio Suite Transmitters Playmod Device Control Suite None (Deprecated) Playmod Overlay Suite Transmitters Playmod Render Suite None (Deprecated) PPix Cache Suite Importers PPix Creator Suite All PPix Creator 2 Suite All PPix Suite All PPix 2 Suite All Quality Suite None (Deprecated) RollCrawl Suite Exporters Scope Render Suite None (Deprecated) Sequence Audio Suite Exporters Sequence Info Suite Importers, Transitions, Video Filters Sequence Render Suite Exporters Stock Image Suite None (Deprecated) String Suite All Threaded Work Suite All Time Suite All Transmit Invocation Suite All Video Segment Render Suite Exporters Video Segment Suite Exporters Window Suite All"},{"location":"universals/sweetpea-suites/#acquiring-and-releasing-the-suites","title":"Acquiring and Releasing the Suites","text":"<p>All SweetPea suites are accessed through the Utilities Suite. Plugins can acquire the suites.</p> <pre><code>SPBasicSuite SPBasic = NULL;\nPrSDKPixelFormatSuite *PixelFormatSuite = NULL;\n\nSPBasic = stdParmsP-&gt;piSuites-&gt;utilFuncs-&gt;getSPBasicSuite();\n\nif (SPBasic) {\nSPBasic-&gt;AcquireSuite ( kPrSDKPixelFormatSuite, kPrSDKPixelFormatSuiteVersion, (const void**)&amp;PixelFormatSuite);\n}\n</code></pre> <p>Don't forget to release the suites when finished!</p> <pre><code>if (SPBasic &amp;&amp; PixelFormatSuite)\n{\n  SPBasic-&gt;ReleaseSuite ( kPrSDKPixelFormatSuite,\n                          kPrSDKPixelFormatSuiteVersion);\n}\n</code></pre>"},{"location":"universals/sweetpea-suites/#versioning","title":"Versioning","text":"<p>Generally from version to version, the changes made to a suite are additive, so it is recommended to work with the most recent version of a suite if possible. However the latest version of a suite may not be supported by older versions of Premiere Pro or other host applications. Attempting to acquire suites that are unsupported by the host application will result in a NULL pointer being returned from AcquireSuite.</p> <p>For a plugin to support multiple versions, it may choose to use a specific older version of the suite that is supported across those multiple versions. Alternatively, it may check the version of the host application (using the App Info Suite), and use the new suites where available, or the older suites when running in an older version. To acquire a specific older version of a suite, rather than requesting kPrSDKPixelFormatSuiteVersion in the example above, use a specific version number instead.</p>"},{"location":"universals/sweetpea-suites/#app-info-suite","title":"App Info Suite","text":"<p>Useful for plug-i that are shared between different applications, such as After Effects plugins, Premiere exporters, transmitters, and importers, where it may be important to know which host, version, or language the plugin is currently running in.</p> <p>Note</p> <p>This suite is not available to AE effects running in AE.</p> <p>This suite provides the host application and version number. For a version such as 6.0.3, it will return major = 6, minor = 0, and patch = 3. See PrSDKAppInfoSuite.h.</p> <p>Starting in version 2 of the suite, introduced in CC, the suite has a new selector to retrieve the build number. SpeedGrade CC supports this suite starting with the July 2013 update.</p> <p>In version 3, starting in CC 2014, the suite has a new selector to retrieve the language as a NULL-terminated string identifying the locale used in the host application. For example: \"en_US\", \"ja_JP\", \"zh_CN\".</p>"},{"location":"universals/sweetpea-suites/#application-settings-suite","title":"Application Settings Suite","text":"<p>New in CS4. This suite provides calls to get the scratch disk folder paths defined in the current project, where the captured files and preview files are created. It also provides a call to get the project file path. All paths are passed back as PrSDKStrings. Use the new String Suite to extract the strings to UTF-8 or UTF-16. See PrSDKApplicationSettingsSuite.h.</p>"},{"location":"universals/sweetpea-suites/#audio-suite","title":"Audio Suite","text":"<p>Calls to convert to and from the native audio format used by the Premiere API, at various bit depths. See PrSDKAudioSuite.h.</p>"},{"location":"universals/sweetpea-suites/#captioning-suite","title":"Captioning Suite","text":"<p>This suite enables a device controller, exporter, player, or transmitter to get the closed captioning data attached to a sequence. This suite provides the data in either Scenarist (CEA-608, *.scc) and MacCaption (CEA-708, *.mcc) formats. In the case of CEA-708, it includes not just the text to display, but it's also the position information, and background, font, etc. If the transmitter or player just wants to overlay the captioning data on a frame, it can use the Playmod Overlay Suite instead.</p>"},{"location":"universals/sweetpea-suites/#clip-render-suite","title":"Clip Render Suite","text":"<p>New in 2.0. Use this suite in the player or renderer, to request source frames directly from the importer. There are calls to find the supported frame sizes and pixel formats, so that the caller can make an informed decision about what format to request. Frames can be retrieved synchronously or asynchronously. Asynchronous requests can be cancelled, for example if the frames have passed their window of playback. See PrSDKClipRenderSuite.h.</p> <p>Starting in CS4, this suite includes calls to find any custom pixel format supported by a clip, and to get frames in those custom pixel formats.</p> <p>An exporter can use this suite to request frames from the renderer in a compressed pixel format.</p>"},{"location":"universals/sweetpea-suites/#error-suite","title":"Error Suite","text":"<p>Uses a single callback for errors, warnings, and info. This callback will activate a flashing icon in the lower left-hand corner of the main application window, which when clicked, will open up the new Events Window containing the error information. See PrSDKErrorSuite.h.</p> <p>Starting in version 3 of the suite, introduced in CS4, the suite supports UTF-16 strings. Starting in CS6, exporters should use the Exporter Utility Suite to report events.</p>"},{"location":"universals/sweetpea-suites/#file-registration-suite","title":"File Registration Suite","text":"<p>Used for registering external files (such as textures, logos, etc) that are used by a plugin instance but do not appear as footage in the Project Window. Registered files will be taken into account when trimming or copying a project using the Project Manager. See PrSDKFileRegistrationSuite.h.</p>"},{"location":"universals/sweetpea-suites/#flash-cue-marker-data-suite","title":"Flash Cue Marker Data Suite","text":"<p>New in CS4. Specific utilities to read Flash cue points. Use in conjunction with the Marker Suite. See PrSDKFlashCueMarkerDataSuite.h.</p>"},{"location":"universals/sweetpea-suites/#image-processing-suite","title":"Image Processing Suite","text":"<p>New in CS5. Various calls to get information on pixel formats and process frames. The ScaleConvert() call is the way to copy-convert from a buffer of any supported pixel format to a separate memory buffer.</p> <p>In version 2, new in CS5.5, we have added StampDVFrameAspect(), which allows a plugin to set the aspect ratio of a DV frame. This was added to supplement ScaleConvert(), which doesn't have an aspect ratio parameter.</p>"},{"location":"universals/sweetpea-suites/#marker-suite","title":"Marker Suite","text":"<p>New in CS4. New way to read markers of all types. See PrSDKMarkerSuite.h.</p>"},{"location":"universals/sweetpea-suites/#memory-manager-suite","title":"Memory Manager Suite","text":"<p>New in Premiere Pro 2.0. Calls to allocate and deallocate memory, and to reserve an amount of memory so that it is not used by the host. See PrSDKMemoryManagerSuite.h.</p> <p>In CS6, the suite is now at version 4. AdjustReservedMemorySize provides a way to adjust the reserved memory size relative to the current size. This may be easier for the plugin, rather than maintaining the absolute memory usage and updating it using the older ReserveMemory call.</p>"},{"location":"universals/sweetpea-suites/#reservememory","title":"ReserveMemory","text":"<p>A plugin instance can call ReserveMemory as a request to reserve space so that Premiere's media cache does not use it. Each time ReserveMemory is called, it updates Premiere Pro on how many bytes the plugin instance is currently reserving. The amount specified is absolute, rather than cumulative. So to release any reserved memory to be made available to Premiere Pro's media cache, call it with a size of 0. However, it's not needed to reset this when exporters are destructed on exSDK_EndInstance, since the media manager will be deleting all the references anyways.</p> <p>ReserveMemory changes the maximum size of Premiere's Media Cache. So if the cache size starts at 10 GB, and you reserve 1 GB, then the cache will not grow beyond 9 GB. ReserveMemory will reserve a different amount of memory, depending on the amount of available memory in the system, and what other plugin instances have already reserved. The media cache needs a minimum amount of memory to play audio, render, etc.</p> <p>Starting in version 2 of the suite, introduced in CS4, there are calls to allocate/deallocate memory. This is necessary for exporters, which are not passed the legacy memFuncs.</p>"},{"location":"universals/sweetpea-suites/#pixel-format-suite","title":"Pixel Format Suite","text":"<p>See the table of supported pixel formats. GetBlackForPixelFormat returns the minimum (black) value for a given pixel format. GetWhiteForPixelFormat returns the maximum (white) value for a given pixel format. Pixel types like YUYV actually contain a group of two pixels to specify a color completely, so the data size returned in this case will be 4 bytes (rather than 2). This call does not support MPEG-2 planar formats.</p> <p>ConvertColorToPixelFormattedData converts an BGRA/ARGB value into a value of a different pixel type. These functions are not meant to convert entire frames from one colorspace to another, but may be used to convert a single color value from a filter color picker or transition border. To convert frames between pixel formats, see the Image Processing Suite.</p> <p>New in Premiere Pro 4.0.1, <code>MAKE_THIRD_PARTY_CUSTOM_PIXEL_FORMAT_FOURCC()</code> defines a custom pixel format.</p>"},{"location":"universals/sweetpea-suites/#playmod-overlay-suite","title":"Playmod Overlay Suite","text":"<p>New in CS5.5. A transmitter can ask Premiere Pro to render the overlay for a specific time. As of CS6, this is only used for closed captioning.</p> <p>To render the closed captioning overlay, it is not necessary to know anything about the closed captioning data, whether it is CEA-608 or CEA-708. RenderImage will simply produce a PPixHand.</p> <p>The reason why it's not called Closed Captioning Overlay Suite is because going forward we want to use it as a general suite that provides all kinds of overlays. That way, when we add more overlay types in the future, you don't need to worry about updating your player each time to mirror the implementation on your side. In the future, we will likely use this same suite to render static overlays, such as safe areas. To support those, even if VariesOverTime returns false, you can call HasVisibleRegions at time 0.</p> <p>Version 2 in CC 2014 removes <code>CalculateVisibleRegions()</code>.</p>"},{"location":"universals/sweetpea-suites/#renderimage","title":"RenderImage","text":"<p>Render the overlay into an optionally provided BGRA PPixHand. RenderImage does not composite the overlay onto an existing frame, it just renders the overlay into the visible regions. After rendering the overlay at the player's display size, you will then need to composite that result over the frame.</p> <p>If the user has zoomed the video, it could be wasteful to render a full-sized overlay image and then scale it. For better performance, the overlay can be rendered at the actual display size. The inDisplayWidth, inDisplayHeight and inLogicalRegion parameters provide this extra information needed to optimize for scaling in the UI.</p> <p>As an example, let's say the sequence is 720x480 at 0.9091 PAR, and the Sequence Monitor is set to show the full frame at square PAR. Set inLogicalRegion to (0, 0, 720, 480), and inDisplayWidth to 654 and inDisplayHeight to 480.</p> <p>If the Monitor zoom level was set to 50%, then the inLogicalRegion should stay the same, but display width and height should be set to 327x240. If zoomed to 200%, display width and height should be set to 1308x960. To pan around (as opposed to showing the entire frame), the logical region should be adjusted to represent the part of the sequence frame currently being displayed.</p> <pre><code>prSuiteError (*RenderImage)(\n  PrPlayID       inPlayID,\n  PrTime         inTime,\n  const prRect*  inLogicalRegion,\n  int            inDisplayWidth,\n  int            inDisplayHeight,\n  prBool         inClearToTransparentBlack,\n  PPixHand*      ioPPix);\n</code></pre> Parameter Description <code>inLogicalRegion</code> The non-scaled region of the source PPix to overlay <code>inDisplayWidth</code> Width and height of PPix, if provided in ioPPix, scaled to account for Monitor zoom and PAR <code>inDisplayHeight</code> <code>inClearToTransparentBlack</code> If <code>kPrTrue</code>, the frame will first be cleared to transparent black before render <code>ioPPix</code> The frame into which to draw the overlay. If NULL, the host will allocate the PPix.If provided, the PPix must be BGRA, square pixel aspect ratio, and sized to inDisplayWidth &amp; inDisplayHeight."},{"location":"universals/sweetpea-suites/#getidentifier","title":"GetIdentifier","text":"<pre><code>prSuiteError (*GetIdentifier)(\n  PrPlayID       inPlayID,\n  PrTime         inTime,\n  const prRect*  inLogicalRegion,\n  int            inDisplayWidth,\n  int            inDisplayHeight,\n  prBool         inClearToTransparentBlack,\n  prPluginID*    outIdentifier);\n</code></pre>"},{"location":"universals/sweetpea-suites/#hasvisibleregions","title":"HasVisibleRegions","text":"<pre><code>prSuiteError (*HasVisibleRegions)(\n  PrPlayID       inPlayID,\n  PrTime         inTime,\n  const prRect*  inLogicalRegion,\n  int            inDisplayWidth,\n  int            inDisplayHeight,\n  prBool*        outHasVisibleRegions);\n</code></pre>"},{"location":"universals/sweetpea-suites/#variesovertime","title":"VariesOverTime","text":"<pre><code>prSuiteError (*VariesOverTime)(\n  PrPlayID  inPlayID,\n  prBool*   outVariesOverTime);\n</code></pre>"},{"location":"universals/sweetpea-suites/#ppix-cache-suite","title":"PPix Cache Suite","text":"<p>Used by an importer, player, or renderer to take advantage of the host application's PPix cache. See PrSDKPPixCacheSuite.h.</p> <p>Starting in version 2 of this suite, introduced in Premiere Pro 4.1, <code>AddFrameToCache</code> and <code>GetFrameFromCache</code> now have two extra parameters, <code>inPreferences</code> and <code>inPreferencesLength</code>. Now frames are differentiated within the cache, based on the importer preferences, so when the preferences change, the host will not use the old frame when it gets a frame request.</p> <p>Version 4, new in CS5.0.3, adds <code>ExpireNamedPPixFromCache()</code> and <code>ExpireAllPPixesFromCache()</code>, which allow a plugin to remove one or all PPixes from the Media Cache, which can be useful if the media is changing due to being edited in a separate application.</p> <p>To expire an individual frames expired using <code>ExpireNamedPPixFromCache()</code>, the identifier must be known. The plugin may specify an identifier using <code>AddNamedPPixToCache()</code>. If a frame is in the cache with multiple names, and you expire any one of those names, then the frame will be expired. Alternatively, for rendered frames, the identifier may be retrieved using <code>GetIdentifierForProduceFrameAsync()</code> in the Video Segment Render Suite.</p> <p>Clearing the cache will not interfere with any outstanding requests, because each request holds dependencies on the needed frames.</p> <p>Version 5, new in CS5.5, adds the new color profile-aware calls <code>AddFrameToCacheWithColorProfile()</code> and <code>GetFrameFromCacheWithColorProfile()</code>.</p> <p>Version 6, new in CC 2014, adds <code>AddFrameToCacheWithColorProfile2()</code> and <code>GetFrameFromCacheWithColorProfile2()</code>, which are the same as the ones added in version 5 with the addition of a <code>PrRenderQuality</code> parameter.</p> <p>Version 7, adds <code>AddFrameToCacheWithColorSpace()</code> and <code>GetFrameFromCacheWithColorSpace()</code>, these APIs deprecate <code>AddFrameToCacheWithColorProfile2()</code> and <code>GetFrameFromCacheWithColorProfile2()</code>.</p>"},{"location":"universals/sweetpea-suites/#ppix-creator-suite","title":"PPix Creator Suite","text":"<p>Includes callbacks to create and copy PPixs. See also the PPix Creator 2 Suite.</p>"},{"location":"universals/sweetpea-suites/#createppix","title":"CreatePPix","text":"<p>Creates a new PPix. The advantage of using this callback is that frames allocated are accounted for in the media cache, and are 16-byte aligned.</p> <p><code>ppixNew</code> and <code>newPtr</code> don't allocate memory in the media cache, or perform any alignment.</p> <pre><code>prSuiteError (*CreatePPix)(\n  PPixHand*           outPPixHand,\n  PrPPixBufferAccess  inRequestedAccess,\n  PrPixelFormat       inPixelFormat,\n  const prRect*       inBoundingRect);\n</code></pre> Parameter Description <code>PPixHand *outPPixHand</code> The new PPix handle if the creation was successful.NULL otherwise. <code>PrPPixBufferAccess inRequestedAccess</code> Requested pixel access. Read-only is not allowed (doesn't make sense).<code>PrPPixBufferAccess</code> values are defined in PPix Suite. <code>PrPixelFormat inPixelFormat</code> The pixel format of this PPix"},{"location":"universals/sweetpea-suites/#cloneppix","title":"ClonePPix","text":"<p>Clones an existing PPix.</p> <p>It will ref-count the PPix if only read access is requested and the PPix to copy from is read-only as well, otherwise it will create a new one and copy.</p> <pre><code>prSuiteError (*ClonePPix)(\n  PPixHand            inPPixToClone,\n  PPixHand*           outPPixHand,\n  PrPPixBufferAccess  inRequestedAccess);\n</code></pre> Parameter Description <code>PPixHand inPPixToClone</code> The PPix to clone from. <code>PPixHand *outPPixHand</code> The new PPix handle if the creation was successful.NULL otherwise. <code>PrPPixBufferAccess inRequestedAccess</code> Requested pixel access.Only read-only is allowed right now.<code>PrPPixBufferAccess</code> values are defined in PPix Suite."},{"location":"universals/sweetpea-suites/#ppix-creator-2-suite","title":"PPix Creator 2 Suite","text":"<p>More callbacks to create PPixs, including raw PPixs.</p> <p>Starting in version 2 of this suite, introduced in Premiere Pro 4.0.1, there is a new <code>CreateCustomPPix</code> call to create a PPix in a custom pixel format.</p> <p>New APIs added to create PPix with specific color space. Color aware Importers should use new color managed APIs for PPix creation. See PrSDKPPixCreator2Suite.h.</p>"},{"location":"universals/sweetpea-suites/#ppix-suite","title":"PPix Suite","text":"<p>Callbacks and enums pertaining to PPixs. See also PPix 2 Suite.</p>"},{"location":"universals/sweetpea-suites/#prppixbufferaccess","title":"PrPPixBufferAccess","text":"<p>Can be either:</p> <ul> <li><code>PrPPixBufferAccess_ReadOnly</code>,</li> <li><code>PrPPixBufferAccess_WriteOnly</code>,</li> <li><code>PrPPixBufferAccess_ReadWrite</code></li> </ul>"},{"location":"universals/sweetpea-suites/#dispose","title":"Dispose","text":"<p>This will free this PPix. The PPix is no longer valid after this function is called.</p> <pre><code>prSuiteError (*Dispose)(\n  PPixHand  inPPixHand);\n</code></pre> Parameter Description <code>PPixHand inPPixHand</code> The PPix handle to dispose."},{"location":"universals/sweetpea-suites/#getpixels","title":"GetPixels","text":"<p>This will return a pointer to the pixel buffer.</p> <pre><code>prSuiteError (*GetPixels)(\n  PPixHand            inPPixHand,\n  PrPPixBufferAccess  inRequestedAccess,\n  char**              outPixelAddress);\n</code></pre> Parameter Description <code>PPixHand inPPixHand</code> The PPix handle to operate on. <code>PrPPixBufferAccess inRequestedAccess</code>Most PPixs do not support write access modes. Requested pixel access. <code>char** outPixelAddress</code> The output pixel buffer address.May be NULL if the requested pixel access is not supported."},{"location":"universals/sweetpea-suites/#getbounds","title":"GetBounds","text":"<p>This will return the bounding rect.</p> <pre><code>prSuiteError (*GetBounds)(\n  PPixHand  inPPixHand,\n  prRect*   inoutBoundingRect);\n</code></pre> Parameter Description <code>PPixHand inPPixHand</code> The PPix handle to operate on. <code>prRect* inoutBoundingRect</code> The address of a bounding rect to be filled in."},{"location":"universals/sweetpea-suites/#getrowbytes","title":"GetRowBytes","text":"<p>This will return the row bytes of the PPix.</p> <pre><code>prSuiteError (*GetRowBytes)(\n  PPixHand      inPPixHand,\n  csSDK_int32*  outRowBytes);\n</code></pre> Parameter Description <code>PPixHand inPPixHand</code> The PPix handle to operate on. <code>csSDK_int32* outRowBytes</code> Returns how many bytes must be added to the pixel buffer address to get to the next line."},{"location":"universals/sweetpea-suites/#getpixelaspectratio","title":"GetPixelAspectRatio","text":"<p>This will return the pixel aspect ratio of this PPix.</p> <pre><code>prSuiteError (*GetPixelAspectRatio)(\n  PPixHand       inPPixHand,\n  csSDK_uint32*  outPixelAspectRatioNumerator,\n  csSDK_uint32*  outPixelAspectRatioDenominator);\n</code></pre> Parameter Description <code>PPixHand inPPixHand</code> The PPix handle to operate on. <code>PrPixelFormat* outPixelFormat</code> Returns the pixel format of this PPix"},{"location":"universals/sweetpea-suites/#getuniquekey","title":"GetUniqueKey","text":"<p>This will return the unique key for this PPix.</p> Returns If error the buffer size is too small (call <code>GetUniqueKeySize</code> to get the correct size) error the key is not available success the key data was filled in <pre><code>prSuiteError (*GetUniqueKey)(\n  PPixHand        inPPixHand,\n  unsigned char*  inoutKeyBuffer,\n  size_t          inKeyBufferSize);\n</code></pre> Parameter Description <code>PPixHand inPPixHand</code> The PPix handle to operate on. <code>unsigned char* inoutKeyBuffer</code> Storage for the key to be returned. <code>size_t inKeyBufferSize</code> Size of buffer"},{"location":"universals/sweetpea-suites/#getuniquekeysize","title":"GetUniqueKeySize","text":"<p>This will return the unique key size. This will not change for the entire run of the application.</p> <pre><code>prSuiteError (*GetUniqueKeySize)(\n  size_t*  outKeyBufferSize);\n</code></pre> Parameter Description <code>size_t* outKeyBufferSize</code> Returns the size of the PPix unique key."},{"location":"universals/sweetpea-suites/#getrendertime","title":"GetRenderTime","text":"<p>This will return the render time for this PPix.</p> <pre><code>prSuiteError (*GetRenderTime)(\n  PPixHand      inPPixHand,\n  csSDK_int32*  outRenderMilliseconds);\n</code></pre> Parameter Description <code>PPixHand inPPixHand</code> The PPix handle to operate on. <code>csSDK_int32* outRenderMilliseconds</code> Returns the render time in milliseconds.If the frame was cached, the time will be zero."},{"location":"universals/sweetpea-suites/#ppix-2-suite","title":"PPix 2 Suite","text":"<p>A call to get the size of a PPix. Starting in version 2 of this suite, introduced in CS4, there is a new <code>GetYUV420PlanarBuffers</code> call to get buffer offsets and rowbytes of YUV_420_MPEG2 pixel formats. See PrSDKPPix2Suite.h.</p>"},{"location":"universals/sweetpea-suites/#rollcrawl-suite","title":"RollCrawl Suite","text":"<p>Used by a player or renderer to obtain the pixels for a roll/crawl. The player or render can then move and composite it using accelerated algorithms or hardware. See PrSDKRollCrawlSuite.h.</p>"},{"location":"universals/sweetpea-suites/#sequence-info-suite","title":"Sequence Info Suite","text":"<p>New in CS4. Calls to get the frame size and pixel aspect ratio of a sequence. This is useful for importers, transitions, or video filters, that provide a custom setup dialog with a preview of the video, so that the preview frame can be rendered at the right dimensions. See PrSDKSequenceInfoSuite.h.</p> <p>Version 2, new in CS5.5, adds <code>GetFrameRate()</code>.</p> <p>Version 3, new in CC, adds <code>GetFieldType()</code>, <code>GetZeroPoint()</code>, and <code>GetTimecodeDropFrame()</code>.</p>"},{"location":"universals/sweetpea-suites/#string-suite","title":"String Suite","text":"<p>New in CS4. Calls to allocate, copy, and dispose of PrSDKStrings. See PrSDKStringSuite.h.</p>"},{"location":"universals/sweetpea-suites/#threaded-work-suite","title":"Threaded Work Suite","text":"<p>New in CS4. Calls to register and queue up a threaded work callback for processing on a render thread. If you queue multiple times, it is possible for multiple threads to call your callback. If this is a problem, you'll need to handle this on your end.</p>"},{"location":"universals/sweetpea-suites/#time-suite","title":"Time Suite","text":"<p>A SweetPea suite that includes the following structure, callbacks, and enum:</p>"},{"location":"universals/sweetpea-suites/#pmplaytimebase","title":"pmPlayTimebase","text":"Member Description <code>csSDK_uint32 scale</code> rate of the timebase <code>csSDK_int32 sampleSize</code> size of one sample <code>csSDK_int32 fileDuration</code> number of samples in file"},{"location":"universals/sweetpea-suites/#prvideoframerates","title":"PrVideoFrameRates","text":"Member Description <code>kVideoFrameRate_24Drop</code> 24000 / 1001 <code>kVideoFrameRate_24</code> 24 <code>kVideoFrameRate_PAL</code> 25 <code>kVideoFrameRate_NTSC</code> 30000 / 1001 <code>kVideoFrameRate_30</code> 30 <code>kVideoFrameRate_PAL_HD</code> 50 <code>kVideoFrameRate_NTSC_HD</code> 60000 / 1001 <code>kVideoFrameRate_60</code> 60 <code>kVideoFrameRate_Max</code> 0xFFFFFFFF"},{"location":"universals/sweetpea-suites/#gettickspersecond","title":"GetTicksPerSecond","text":"<p>Get the current ticks per second. This is guaranteed to be constant for the duration of the runtime.</p> <pre><code>prSuiteError (*GetTicksPerSecond)(\n  PrTime*  outTicksPerSec);\n</code></pre>"},{"location":"universals/sweetpea-suites/#gettickspervideoframe","title":"GetTicksPerVideoFrame","text":"<p>Get the current ticks in a video frame rate. inVideoFrameRate may be any of the <code>PrVideoFrameRates</code> enum.</p> <pre><code>prSuiteError (*GetTicksPerVideoFrame)(\n  PrVideoFrameRates  inVideoFrameRate,\n  PrTime*            outTicksPerFrame);\n</code></pre>"},{"location":"universals/sweetpea-suites/#getticksperaudiosample","title":"GetTicksPerAudioSample","text":"<p>Get the current ticks in an audio sample rate.</p> Returns If <code>kPrTimeSuite_RoundedAudioRate</code> the requested audio sample rate is not an even divisor of the base tick count and therefore times in this rate will not be exact. <code>kPrTimeSuite_Success</code> otherwise <pre><code>prSuiteError (*GetTicksPerAudioSample)(\n  float    inSampleRate,\n  PrTime*  outTicksPerSample);\n</code></pre>"},{"location":"universals/sweetpea-suites/#video-segment-render-suite","title":"Video Segment Render Suite","text":"<p>This suite uses the built-in software path for rendering, and supports subtree rendering. This means the plugin can ask the host to render a part of the segment, and then still handle the rest of the rendering. This is useful if, for example, one of the layers has an effect that the plugin cannot render itself. The plugin can have the host render that layer, but then handle the other layers along with the compositing.</p> <p>In version 2, new in CS5.5, the new call <code>SupportsInitiateClipPrefetch()</code> can be used to query whether or not a clip supports prefetching.</p> <p>In version 3, new in CS6, the function signatures have been modernized, using <code>inSequenceTicksPerFrame</code> rather than <code>inFrameRateScale</code> and <code>inFrameRateSampleSize</code>.</p>"},{"location":"universals/sweetpea-suites/#video-segment-suite","title":"Video Segment Suite","text":"<p>This suite provides calls to parse a sequence and get details on video segments. All the queryable node properties are in PrSDKVideoSegmentProperties.h. These properties will be returned as PrSDKStrings, and should be managed using the String Suite. The segments provide a hash value that the caller can use to quickly determine whether or not a segment has changed. This hash value can be maintained even if a segment is shifted in time</p> <p>In version 4, new in CS5.5, the new call <code>AcquireNodeForTime()</code> passes back a segment node for a requested time. There are also a few new properties for media nodes: StreamIsContinuousTime, ColorProfileName, ColorProfileData, and ScanlineOffsetToImproveVerticalCentering.</p> <p>In version 5, new in CC, a new video segment property is available: Effect_ClipName. In version 6, new in CC 2014, <code>AcquireFirstNodeInTimeRange()</code> and</p> <p><code>AcquireOperatorOwnerNodeID()</code> were added, along with the new node type kVideoSegment_NodeType_AdjustmentEffect.</p> <p>The basic structure of the video segments is that of a tree structure. There is a Compositor node with n inputs. Each of those inputs is a Clip node, which has one input which is a Media node, and it also has n Operators, which are effects.</p> <p>So, a simple example, three clips in a stack, the top one with three effects looks like this:</p> <pre><code>Segment\n  Compositor Node\n    Clip Node\n      Media Node (bottom clip) Clip Node\n    Clip Node\n      Media Node (middle clip) Clip Node\n    Clip Node\n      Media Node (top clip)\n      Clip Operators (Blur, Color Corrector, Motion)\n</code></pre> <p>To get a good idea of the segment structure, try the SDK player, create a sequence using the SDK Editing Mode, and watch the text overlay in the Sequence Monitor as you perform edits.</p> <p>See PrSDKVideoSegmentSuite.h and PrSDKVideoSegmentProperties.h.</p>"},{"location":"universals/sweetpea-suites/#window-suite","title":"Window Suite","text":"<p>New in CS4. This is the new preferred way to get the handle of the mainframe window, especially for exporters, who don't have access to the legacy piSuites.</p>"},{"location":"universals/time/","title":"Time","text":"<p>There are two different representations of time: <code>scale over sampleSize</code>, and <code>ticks</code>.</p>"},{"location":"universals/time/#scale-over-samplesize","title":"scale over sampleSize","text":"<p>The first representation of time uses value/scale/<code>sampleSize</code> components, either separated, or combined in a TDB_TimeRecord structure. scale over <code>sampleSize</code> defines the timebase. For example, to represent the NTSC standard of 29.97 frames per second, <code>scale</code> / <code>sampleSize = 30000</code> / 1001. To represent the PAL standard of 25 frames per second, 25 / 1.</p> <p>To represent the 24p standard of 23.976, 23976 / 1000, or 24000 / 1001. To represent most other timebases, use <code>sampleSize = 1</code>, and scale is the frame rate (e.g. 15, 24, 30 fps, etc). Another way of thinking about scale and <code>sampleSize</code> is that <code>sampleSize</code> is the duration of a frame of video, and scale is that duration of a second of video.</p> <p><code>value</code> is the time in the timebase given by <code>scale</code> over <code>sampleSize</code>. So, for example, 30 frames with a sampleSize of 1001 have a value of 30030.</p> <p>To convert <code>value</code> to seconds, divide by scale. To convert <code>value</code> to frames, divide by <code>sampleSize</code>.</p> <p>Sometimes, as when handling audio-only media, <code>sampleSize</code> refers to a sample of audio, and <code>sampleSize = 1</code>. In this case, scale is the audio sampling rate (22050, 32000, 44100, 48000 Hz, etc).</p>"},{"location":"universals/time/#prtime","title":"PrTime","text":"<p>Most newer areas of the API use a tick-based time value that is stored in a signed 64-bit integer. Variables that use this new format are of type PrTime. When a frame rate is represented as a PrTime, the frame rate is the number of ticks in a frame duration.</p> <p>The current number of ticks per second must be retrieved using the callback in the Time Suite. This rate is guaranteed to be constant for the duration of the application's run-time.</p>"},{"location":"universals/universals/","title":"Universals","text":"<p>This chapter covers topics that are common to more than one type of Premiere plugin. We start by discussing fundamental concepts and common data structures. The rest of the chapter discusses the various function suites that are available to plugins.</p>"},{"location":"universals/video-frames/","title":"Video Frames","text":"<p>Premiere stores each video frame in a PPix structure. A PPixHand is a handle to a PPix. This structure should not be accessed directly, but manipulated using various suites such as the PPix Suite, PPix 2 Suite, PPix Creator Suite, and PPix Creator 2 Suite.</p> <p>Far from being just a boring buffer of RGB data, PPixes can contain a significant amount of information about a video frame, including: rectangle bounds (width, height), pixel aspect ratio, pixel format, field dominance, alpha interpretation, color space, gamma encoding, and more.</p> <p>In the pixel buffer itself, there may be padding between neighboring horizontal rows of pixels. So when iterating through the pixels in the buffer, don't assume that the first pixel on the next line is stored immediately after the last pixel on the current line. Honor the rowbytes, which is a measure of the size in bytes of a row of pixels, including any extra padding.</p> <p>Frames are guaranteed to be 16-byte aligned.</p>"},{"location":"video-filters/VideoRecord/","title":"VideoRecord","text":"<p>A video filter is passed a handle to a VideoRecord with almost every selector.</p> <pre><code>typedef struct {\n  PrMemoryHandle          specsHandle;\n  PPixHand                source;\n  PPixHand                destination;\n  csSDK_int32             part;\n  csSDK_int32             total;\n  char                    previewing;\n  void*                   privateData;\n  VFilterCallBackProcPtr  callBack;\n  BottleRec*              bottleNecks;\n  short                   version;\n  short                   sizeFlags;\n  csSDK_int32             flags;\n  TDB_TimeRecord*         tdb;\n  PrMemoryHandle          instanceData;\n  piSuitesPtr             piSuites;\n  PrTimelineID            timelineData;\n  char                    altName[MAX_FXALIAS];\n  PrPixelFormat           pixelFormatSupported;\n  csSDK_int32             pixelFormatIndex;\n  csSDK_uint32            instanceID;\n  TDB_TimeRecord          tdbTimelineLocation;\n  csSDK_int32             sessionPluginID;\n} VideoRecord, **VideoHandle;\n</code></pre> Member Description <code>specsHandle</code> Instance settings, persistent across Premiere sessions.Create this handle during <code>fsInitSpec</code> or <code>fsSetup</code>.Populated by Premiere if the filter's parameters can be manipulated in the Effect Controls Panel.Use Premiere's memory allocation callbacks to allocate memory for the <code>specsHandle</code>. <code>source</code> <code>PPixHand</code> for the source video frame. <code>destination</code> <code>PPixHand</code> for the destination video frame, always the same size as source.Store the output frame here during <code>fsExecute</code>. <code>part</code> How far into the effect you are.<code>part</code> varies from 0 to total, inclusive. <code>total</code> Total length of the video filter.Divide part by total to calculate the percentage of the time-variant filter for a given <code>fsExecute</code>.This value doesn't necessarily correspond to frames or fields. <code>previewing</code> Unsupported <code>privateData</code> Data private to Premiere.Pass to the frame-retrieval callback when requesting a frame. <code>callBack</code> Pointer to <code>VFilterCallbackProcPtr</code>, used for retrieving frames (or fields, for interlaced video) from source clips. <code>bottleNecks</code> Pointer to Premiere's bottleRec functions. <code>version</code> Version of this structure (<code>kVideoFilterVersion</code>).<ul><li>Premiere Pro CS5 = <code>VIDEO_FILTER_VERSION_11</code></li><li>Premiere Pro CS3 = <code>VIDEO_FILTER_VERSION_10</code></li></ul> <code>sizeFlags</code> Field-rendering information. <code>flags</code> If doing a lower-quality render, Premiere will pass in <code>kEffectFlags_DraftQuality</code> during <code>fsExecute</code>.The filter can then optionally render a faster, lower-quality image for previewing. <code>tdb</code> Pointer to a time database record describing the sequence timebase. <code>instanceData</code> Handle to private instance data that persists across invocations.Allocate the memory for this during <code>fsExecute</code> and deallocate during <code>fsDisposeData</code>.Do not use this field during fsSetup. <code>piSuites</code> Pointer to callback piSuites. <code>timelineData</code> Only available during <code>fsInitSpec</code> and <code>fsSetup</code>.This opaque handle to the timeline database is required by <code>timelineFuncs</code> callbacks available in piSuites.This handle is useful in order to have a preview in a modal setup dialog during <code>fsSetup</code>. <code>altName</code> Unused. <code>pixelFormatSupported</code> Only valid during <code>fsGetPixelFormatsSupported</code>.Return pixel type supported. <code>pixelFormatIndex</code> Only valid during <code>fsGetPixelFormatsSupported</code>.Index of fourCC of pixel type supported. <code>instanceID</code> The runtime instance ID uniquely identifies filters during a session.This is the same ID that is passed to players in <code>prtFilterRec</code>. <code>tdbTimelineLocation</code> A time database record describing the location of the filter in sequence.Only valid during <code>fsInitSpec</code> and <code>fsSetup</code>. <code>sessionPluginID</code> This ID should be used in the File Registration Suite for registering external files (such as textures, logos, etc) that are used by a plugin instance but do not appear as footage in the Project Panel.Registered files will be taken into account when trimming or copying a project using the Project Manager."},{"location":"video-filters/VideoRecord/#vfiltercallbackprocptr","title":"VFilterCallBackProcPtr","text":"<p>Pointer to a callback for retrieving frames (or fields, for interlaced video) from the source clip.</p> <p>Do not expect real-time performance from this callback.</p> <pre><code>typedef short (CALLBACK *VFilterCallBackProcPtr)(\n  csSDK_int32  frame;\n  PPixHand     thePort;\n  RECT*        theBox;\n  Handle       privateData);\n</code></pre> Parameter Description <code>frame</code> Frame requested. The frame value passed in should be frame * samplesize.The callback will always return the current field (upper or lower) during field rendering. <code>thePort</code> <code>PPixHand</code> where Premiere will store the frame <code>theBox</code> Bounds of the frame you want Premiere to retrieve. <code>privateData</code> Handle provided by Premiere in <code>VideoRecord.privateData</code>"},{"location":"video-filters/VideoRecord/#sizeflags","title":"sizeFlags","text":"<p>For sizeFlags, the following bit flags are of interest:</p> Flag Description <code>gvFieldsEven</code> The video filter should render upper-field dominance <code>gvFieldsOdd</code> The video filter should render lower-field dominance <code>gvFieldsFirst</code> The video filter is currently rendering the dominant field"},{"location":"video-filters/additional-details/","title":"Additional Details","text":""},{"location":"video-filters/additional-details/#fields-and-field-processing","title":"Fields and Field Processing","text":"<p>In an interlaced project, Premiere calls your video filter once per field.</p> <p>This allows video filters to have interlaced motion. <code>(*theData)-&gt;total</code> will be twice as large, each frame will be half-height, and rowbytes will double.</p> <p>Respect the value of rowbytes when traversing data or the output will be incorrect.</p>"},{"location":"video-filters/additional-details/#frame-caching","title":"Frame Caching","text":"<p>The rendered output of video filters is stored in the host media cache. For example, when the user scrubs over a frame with a filter on it, the filter will be called to render its effect on the frame and return the buffer to Premiere. Premiere caches the returned frame, so when the user scrubs over the same frame, Premiere will return the cached frame without having to call the filter again. If the user has modified the filter settings, the clip settings, the preview quality, etc, Premiere will call the filter to render with the new settings, but will keep the previously cache frame for a while. So if the changes are reversed, Premiere may still have the cached frame to return when appropriate.</p> <p>If the filter should generate random, non-deterministic output, or if it changes over time without keyframes, the randomness bit must be set in the <code>ANIM_FilterInfo</code> section in the PiPL (.r file).</p> <p>If you set the bit to noRandomness, Premiere will only render one frame of a still image.</p>"},{"location":"video-filters/additional-details/#creating-effect-presets","title":"Creating Effect Presets","text":"<p>Effect presets appear in the Presets bin in the Effects panel, and can be applied just like Effects with specific parameter settings and keyframes. Effect presets can be created as follows:</p> <ol> <li>Apply a filter to a clip</li> <li>Set the parameters of the filter, adding keyframes if desired</li> <li>Right-click on the filter name in the Effect Controls panel, and select \"Save Preset\u2026\"</li> <li>Create preset bins if desired by right-clicking in the Effects panel and choosing \"New Presets Bin\"</li> <li>Organize the presets in the preset folders</li> <li>Select the bins and/or presets you wish to export, right-click, and choose \"Export Preset\"</li> </ol> <p>On Windows, newly created presets are saved in the hidden Application Data folder of the user's Documents and Settings (e.g. <code>C:/Documents and Settings/[user]/Application Data/Adobe Premiere Pro/[version]/Effect Presets and Custom Items.prfpset</code>). On Mac OS, they are in the user folder, at <code>~/Library/Application Support/Adobe/Premiere Pro/[version]/Effect Presets and Custom Items.prfpset.</code></p> <p>Effect Presets should be installed as described in the section, \"Plug-in Installation\". Once they are installed in that folder, they will be read-only, and the user will not be able to move them to a different folder or change their names. User-created presets will be modifiable.</p>"},{"location":"video-filters/additional-details/#effect-badging","title":"Effect Badging","text":"<p>Starting in CS5, video filters now appear with badges in the Effects panel to advertise if they support YUV, 32-bit, and/or accelerated rendering. The user can filter the list of effects to show only the effects that support those rendering modes. Video filters will automatically receive YUV and 32-bit badges if they advertise support using the existing fsGetPixelFormatsSupported. Custom badges can also be created.</p> <p>To add your own effect badge, go to the following folder:</p> <p>On Windows: <code>[App installation path]\\Settings\\BadgeIcons\\\\</code></p> <p>On Mac OS: <code>Adobe Premiere Pro CS5.app/Contents/Settings/BadgeIcons/</code></p> <p>In that folder are the PNG graphics that are loaded at runtime for various badges, and an additional set of <code>'Sample-*.png'</code> and <code>'Sample.xml'</code> files.</p> <ol> <li>Make copies of the Sample- .png files, replacing the \"Sample\" prefix with the prefix that matches whatever you want to call the new badge (like 'NewBadge-.png'). Edit the PNG as you'd like, but don't change the image dimensions.</li> <li>Copy the Sample.xml file to a new name that matches whatever you want to call the new badge (like 'NewBadge.xml'). Edit the list of match names that you want to be decorated with your badge. Change the <code>&lt;Name&gt;</code> tag to the name you chose in step 1 (like 'NewBadge'). You can also add your tooltip text as the <code>&lt;DescriptionItem&gt;</code> tags. These tags act as a localization map with the langid as the key. If a language isn't found, 'en_US' is used by default. Provide your own GUID in the <code>&lt;Guid&gt;</code> tag.</li> <li>Relaunch the application. You'll get a badge filter icon next to the others and a badge icons next to each effect that was listed in the XML file.</li> </ol> <p>Note</p> <p>'Sample' is a special case that is intentionally excluded. Any other set of  .xml/.png files will be used.</p>"},{"location":"video-filters/additional-details/#premiere-elements-and-effect-thumbnail-previews","title":"Premiere Elements and Effect Thumbnail Previews","text":"<p>Premiere Elements (but not Premiere Pro) displays visual icons for each effect. You will need to provide icons for your effects, or else an empty black icon will be shown for your effects, or even worse behavior in Premiere Elements 8. The icons are 60x45 PNG files, and are placed here:</p> <p><code>/[Program Files]/Adobe/Adobe Premiere Elements [version]/Plug-ins/Common/Effect/Previews/</code></p> <p>The filename should be the match name of the effect, which you specify in the PiPL, prefixed with \"PR.\" So if the match name was \"MatchName\", then the filename should be \"PR.MatchName.png\"</p>"},{"location":"video-filters/getting-started/","title":"Getting Started","text":"<p>Begin with one of the two video filter sample projects, progressively replacing its functionality with your own.</p>"},{"location":"video-filters/getting-started/#resources","title":"Resources","text":"<p>Filter plugins can use PiPL resources to define their behaviors and supported properties.</p> <p>To provide any parameters in the Effect Controls panel, they must be defined in the PiPL in ANIM_ParamAtom sections, as demonstrated in the example below.</p> <p>The 'no UI' UI type is for non-keyframeable parameters. After making changes to the PiPL, rebuild the plugin each time, so that the PiPL will be recompiled.</p>"},{"location":"video-filters/getting-started/#a-filter-pipl-example","title":"A Filter PiPL Example","text":"<pre><code>#include \"PrSDKPiPLVer.h\"\n#ifndef PRWIN_ENV\n#include \"PrSDKPiPL.r\"\n#endif\n\n// The following two strings should be localized\n#define plugInName \"Cool Video Filter\"\n#define plugInCategory \"SDK Filters\"\n\n// This name should not be localized or updated\n#define plugInMatchName \"SDK Cool Filter\"\n\nresource 'PiPL' (16000) {\n  {\n    // The plugin type\n    Kind {PrEffect},\n\n    // The plugin name as it will appear to the user\n    Name {plugInName},\n\n    // The internal name of this plugin\n    AE_Effect_Match_Name {plugInMatchName},\n\n    // The folder containing the plugin in the Effects Panel\n    Category {plugInCategory},\n\n    // The version of the PiPL resource definition\n    AE_PiPL_Version {PiPLVerMajor, PiPLVerMinor},\n\n    // The ANIM properties describe the filter parameters, and also how the data is stored in the project file. There is one ANIM_FilterInfo property followed by n ANIM_ParamAtoms\n    ANIM_FilterInfo {\n      0,\n      #ifdef PiPLVer2p3\n\n      // Non-square pixel aspect ratio supported\n      notUnityPixelAspectRatio,\n      anyPixelAspectRatio,\n      reserved4False,\n      reserved3False,\n      reserved2False,\n\n      #endif\n    },\n\n    reserved1False, // These flags are for use by After Effects\n    reserved0False, // Not used by Premiere\n    driveMe, // Not used by Premiere\n    needsDialog, // Not used by Premiere\n    paramsNotPointer, // Not used by Premiere\n    paramsNotHandle, // Not used by Premiere\n    paramsNotMacHandle, // Not used by Premiere\n    dialogNotInRender, // Not used by Premiere\n    paramsNotInGlobals, // Not used by Premiere\n    bgAnimatable, // Not used by Premiere\n    fgAnimatable, // Not used by Premiere\n    geometric, // Not used by Premiere\n    noRandomness, // Not used by Premiere\n\n    // Put the number of parameters here\n    2,\n\n    plugInMatchName\n\n    // There is one ANIM_ParamAtom for each parameter\n    ANIM_ParamAtom {\n      // This is the first property - Zero based count\n      0,\n\n      // The name to appear for the control\n      \"Level\",\n\n      // Parameter number goes here - One based count\n      1,\n\n      // Put the data type here\n      ANIM_DT_SHORT,\n\n      // UI control type\n      ANIM_UI_SLIDER,\n      0x0,\n      0x0, // valid_min (0.0)\n      0x405fc000,\n      0x0, // valid_max (127.0)\n      0x0,\n      0x0, // ui_min (0.0)\n      0x40590000,\n      0x0, // ui_max (100.0)\n\n      #if PiPLVer2p3\n      // New - Scale/dontScale UI Range if user modifies\n      dontScaleUIRange,\n      #endif\n    },\n\n    // Set/don't set this if the param should be animated\n    animateParam,\n    dontRestrictBounds, // Not used by Premiere\n    spaceIsAbsolute, // Not used by Premiere\n    resIndependent, // Not used by Premiere\n\n    // Bytes size of the param data\n    2\n\n    ANIM_ParamAtom {\n      1,\n      \"Target Color\", 2,\n\n      // Put the data type here\n      ANIM_DT_COLOR_RGB,\n\n      // UI control type\n      ANIM_UI_COLOR_RGB,\n      0x0,\n      0x0,\n      0x0,\n      0x0,\n      0x0,\n      0x0,\n      0x0,\n      0x0,\n\n      #ifdef PiPLVer2p3\n      dontScaleUIRange,\n      #endif\n\n      // Set/don't set this if the param should be animated\n      animateParam,\n      dontRestrictBounds,\n      spaceIsAbsolute,\n      resIndependent,\n\n      // Bytes size of the param data\n      4\n    },\n  }\n};\n</code></pre>"},{"location":"video-filters/getting-started/#entry-point","title":"Entry Point","text":"<pre><code>short xFilter (\n  short        selector,\n  VideoHandle  theData)\n</code></pre> <ul> <li><code>selector</code> is the action Premiere wants the video filter to perform.</li> <li><code>EffectHandle</code> provides source and destination buffers, and other useful information.</li> </ul> <p>Return <code>fsNoErr</code> if successful, or an appropriate return code.</p>"},{"location":"video-filters/return-codes/","title":"Return Codes","text":"Return Code Reason <code>fsNoErr</code> Operation has completed without error. <code>fsBadFormatIndex</code> Return from <code>fsGetPixelFormatsSupported</code> when all pixel formats have been enumerated. <code>fsDoNotCacheOnLoad</code> Return from <code>fsCacheOnLoad</code> to disable plugin caching for this filter. <code>fsHasNoSetupDialog</code> Return from <code>fsHasSetupDialog</code> to disable setup button in Effect Controls panel <code>fsUnsupported</code> The selector is not recognized, or unsupported."},{"location":"video-filters/selector-descriptions/","title":"Selector Descriptions","text":""},{"location":"video-filters/selector-descriptions/#fsinitspec","title":"fsInitSpec","text":"<p>Responding to this selector is optional. This selector is sent when the filter is applied to a clip and the plugin is called for the first time. This call can be used to initialize the plugin parameters with default values in order to achieve an initial \"silent setup\", in which <code>fsSetup</code> is skipped when the filter is applied to a clip, to avoid popping the modal dialog that may be needed in <code>fsSetup</code>.</p> <p>Allocate and pass back a handle to a structure containing the parameter values in specsHandle. The filter is given the total duration (in samples), and number of the first sample in the source buffer.</p>"},{"location":"video-filters/selector-descriptions/#fshassetupdialog","title":"fsHasSetupDialog","text":"<p>New for Premiere Pro CS3. Optional. Specify whether or not the filter has a setup dialog, by <code>returning</code> <code>fsHasNoSetupDialog</code> or <code>fsNoErr</code>.</p>"},{"location":"video-filters/selector-descriptions/#fssetup","title":"fsSetup","text":"<p>Optional. Sent when the filter is applied, if <code>fsInitSpec</code> doesn't allocate a valid specsHandle. Also sent when the user clicks on the setup link in the Effect Controls Panel. The filter can optionally display a (platform-dependent) modal dialog to get new parameter values from the user. First, check <code>VideoHandle.specsHandle</code>. If NULL, the plugin is being called for the first time.</p> <p>Initialize the parameters to their default values. If non-NULL, load the parameter values from specsHandle. Now use the parameter values to display a modal setup dialog to get new values. Return a handle to a structure containing the parameter values in specsHandle.</p> <p>In order to properly store parameter values between calls to the plugin, describe the structure of your specsHandle data in your PiPL's ANIM properties. Premiere interpolates animatable parameter values as appropriate before sending <code>fsExecute</code>.</p> <p>The filter is given the total duration in samples and the sample number of the first sample in the source buffer.</p> <p>During <code>fsSetup</code>, the frames passed to <code>VideoRecord.source</code> will almost always be 320x240. The exception is if the plugin is receiving the <code>fsSetup</code> selector when the effect is initially applied, in which case it will receive a full height frame, with the width adjusted to make the frame square pixel aspect ratio. For example, a filter applied in a 1440x1080 HDV sequence will receive a full 1920x1080 buffer. The frame is the layer the filter is applied to at the current time indicator. If the CTI is not on the clip the filter is applied to, the frame is transparent black.</p> <p>If the filter has a setup dialog, the VFilterCallbackProcPtr should be used to get source frames for previews. <code>getPreviewFrameEx</code> can be used to get rendered frames, although if this call is used, the video filter should be ready to be called reentrantly with <code>fsExecute</code>.</p>"},{"location":"video-filters/selector-descriptions/#fsexecute","title":"fsExecute","text":"<p>This is really the only required selector for a video filter, and it's where the rendering happens. Take the input frame in <code>VideoHandle.source</code>, render the effect and return the frame to Premiere in <code>VideoHandle.destination</code>. The specsHandle contains your parameter settings (already interpolated if animatable). You can store a handle to any additional non-parameter data in <code>VideoHandle.InstanceData</code>. If you do so, deallocate the handle in response to <code>fsDisposeData</code>, or your plugin will leak memory.</p> <p>The video your filter receives may be interlaced, in the field order determined by the project settings. If interlaced, your plugin will be called twice for each frame of video, and each PPix will be half the frame height.</p>"},{"location":"video-filters/selector-descriptions/#fsdisposedata","title":"fsDisposeData","text":"<p>Optional. Called when the project closes. Dispose of any instance data created during <code>fsExecute</code>. See <code>VideoHandle-&gt;InstanceData</code>.</p>"},{"location":"video-filters/selector-descriptions/#fscanhandlepar","title":"fsCanHandlePAR","text":"<p>Optional. Indicate how your filter wants to handle pixel aspect ratio by returning a combination of the following flags.</p> <p>This selector is only sent if several conditions are met.</p> <p>The pixel aspect ratio of the clip to which the filter is applied must be known, and not be square (1.0).</p> <p>The clip must not be a solid color.</p> <p>The PiPL bits <code>anyPixelAspectRatio</code> and <code>unityPixelAspectRatio</code> must not be set.</p> Flag Description <code>prEffectCanHandlePAR</code> Premiere should not make any adjustment to the source image to compensate for PAR <code>prEffectUnityPARSetup</code> Premiere should render the source image to square pixels during <code>fsSetup</code> <code>prEffectUnityPARExecute</code> Premiere should render the source image to square pixels during <code>fsExecute</code>"},{"location":"video-filters/selector-descriptions/#fsgetpixelformatssupported","title":"fsGetPixelFormatsSupported","text":"<p>Optional.</p> <p>Gets pixel formats supported.</p> <p>Called iteratively until all formats have been given.</p> <p>Set <code>(*theData)-&gt;pixelFormatSupported</code> to a supported pixel format, and return <code>fsNoErr</code>.</p> <p>When all formats have been described, return <code>fsBadFormatIndex</code>.</p> <p>See the field-aware video filter sample for an example.</p>"},{"location":"video-filters/selector-descriptions/#fscacheonload","title":"fsCacheOnLoad","text":"<p>Optional. Return <code>fsDoNotCacheOnLoad</code> to disable plugin caching for this filter.</p>"},{"location":"video-filters/selector-table/","title":"Selector Table","text":"<p>This table summarizes the various selector commands a video filter can receive.</p> Selector Optional? Description fsInitSpec Yes Allocate and initialize your parameters with default values without popping a modal setup dialog. fsHasSetupDialog Yes New for Premiere Pro CS3. Specify whether or not the filter has a setup dialog. fsSetup Yes Allocate memory for your parameters if necessary.Display your modal setup dialog with default parameter values or previously stored values.Save the new values to <code>specsHandle</code>. fsExecute No Filter the video using the stored parameters from <code>specsHandle</code>.Be aware of interlaced video, and don't overlook the alpha channel! fsDisposeData Yes Dispose of any instance data created during <code>fsExecute</code>. fsCanHandlePAR Yes Tell Premiere how your effect handles pixel aspect ratio. fsGetPixelFormatsSupported Yes Gets pixel formats supported. Called iteratively until all formats have been given. fsCacheOnLoad Yes Return fsDoNotCacheOnLoad to disable plugin caching for this filter."},{"location":"video-filters/video-filters/","title":"Video Filters","text":"<p>We strongly recommend using the After Effects SDK to develop effects plugins.</p> <p>Almost all of the effects included in Premiere Pro are After Effects plugins, and future development will be based on the After Effects API.</p> <p>Video filters process a video frame into a destination frame. Filter parameters can vary with time.</p> <p>Premiere provides basic user interface in the Effect Controls panel, drawing sliders, color pickers, angle dials, and checkboxes based on the parameter definitions in the PiPL resource. Video filters can have their own custom modal setup dialog for additional settings.</p> <p>If you've never developed a video filter before, you can skip Whats New, and go directly to Getting Started.</p>"},{"location":"video-filters/whats-new/","title":"Whats New","text":""},{"location":"video-filters/whats-new/#whats-new-in-premiere-pro-cs5","title":"What's New in Premiere Pro CS5?","text":"<p>In the Effects panel, video filters now appear with badges to advertise if they support YUV, 32- bit, and accelerated rendering.</p> <p>The user can filter the list of effects to show only the effects that support those rendering modes. Video filters will automatically receive YUV and 32-bit badges if they advertise support using the existing <code>fsGetPixelFormatsSupported</code>.</p> <p>Custom badges can also be created. See Effect Badging for more information.</p>"},{"location":"video-filters/whats-new/#whats-new-in-premiere-pro-cs3","title":"What's New in Premiere Pro CS3?","text":"<p>Checkbox controls are now supported directly in the Effect Controls panel.</p> <p>Filters can specify whether or not they want a setup button in the Effect Controls panel during <code>fsHasSetupDialog</code>, by returning <code>fsHasNoSetupDialog</code> or <code>fsNoErr</code>.</p> <p>Previously, this was set in the PiPL resource.</p>"}]}